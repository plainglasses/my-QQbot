export declare type Dict<T = any, K extends string = string> = {
    [key in K]?: T;
};
export declare type Intersect<U> = (U extends any ? (arg: U) => void : never) extends ((arg: infer I) => void) ? I : never;
export declare function isNullable(value: any): boolean;
export declare function isPlainObject(data: any): boolean;
export declare function valueMap<T, U>(object: Dict<T>, transform: (value: T, key: string) => U): Dict<U>;
export declare function clone<T>(source: T): T;
interface Schema<S = any, T = S> extends Schema.Base<T> {
    (data: S): T;
    (data?: null): T;
    new (data: S): T;
    new (data?: null): T;
    [kSchema]: true;
    toJSON(): Schema.Base<T>;
    required(value?: boolean): Schema<S, T>;
    hidden(value?: boolean): Schema<S, T>;
    role(text: string): Schema<S, T>;
    link(link: string): Schema<S, T>;
    default(value: T): Schema<S, T>;
    comment(text: string): Schema<S, T>;
    description(text: string): Schema<S, T>;
    max(value: number): Schema<S, T>;
    min(value: number): Schema<S, T>;
    step(value: number): Schema<S, T>;
    set(key: string, value: Schema): Schema<S, T>;
    push(value: Schema): Schema<S, T>;
}
declare namespace Schema {
    export type From<T> = T extends string | number | boolean ? Schema<T> : T extends Schema ? T : T extends typeof String ? Schema<string> : T extends typeof Number ? Schema<number> : T extends typeof Boolean ? Schema<boolean> : T extends typeof Function ? Schema<Function, (...args: any[]) => any> : T extends Constructor<infer S> ? Schema<S> : never;
    type _TypeS<X> = X extends Schema<infer S, unknown> ? S : never;
    type _TypeT<X> = ReturnType<Extract<X, Schema>>;
    export type TypeS<X> = _TypeS<From<X>>;
    export type TypeT<X> = _TypeT<From<X>>;
    export type Resolve = (data: any, schema?: Schema, strict?: boolean) => [any, any?];
    export interface Base<T = any> {
        uid?: number;
        type?: string;
        sKey?: Schema;
        inner?: Schema;
        list?: Schema[];
        dict?: Dict<Schema>;
        callback?: Function;
        value?: T;
        meta?: Meta<T>;
        refs?: Dict<Schema>;
        toString(inline?: boolean): string;
    }
    export interface Meta<T = any> {
        default?: T extends {} ? Partial<T> : T;
        required?: boolean;
        hidden?: boolean;
        role?: string;
        link?: string;
        description?: string;
        comment?: string;
        max?: number;
        min?: number;
        step?: number;
    }
    type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[];
    type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[];
    type ObjectS<X extends Dict> = {
        [K in keyof X]?: TypeS<X[K]>;
    } & Dict;
    type ObjectT<X extends Dict> = {
        [K in keyof X]?: TypeT<X[K]>;
    } & Dict;
    type Constructor<T = any> = new (...args: any[]) => T;
    export interface Static {
        <T = any>(options: Base<T>): Schema<T>;
        new <T = any>(options: Base<T>): Schema<T>;
        prototype: Schema;
        resolve: Resolve;
        from<T = any>(source?: T): Schema<From<T>>;
        extend(type: string, resolve: Resolve): void;
        any(): Schema<any>;
        never(): Schema<never>;
        const<T>(value: T): Schema<T>;
        string(): Schema<string>;
        number(): Schema<number>;
        natural(): Schema<number>;
        percent(): Schema<number>;
        boolean(): Schema<boolean>;
        function(): Schema<Function, (...args: any[]) => any>;
        is<T>(constructor: Constructor<T>): Schema<T>;
        array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>;
        dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>;
        tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>;
        object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>;
        union<X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>;
        intersect<X>(list: readonly X[]): Schema<Intersect<TypeS<X>>, Intersect<TypeT<X>>>;
        transform<X, T>(inner: X, callback: (value: TypeS<X>) => T): Schema<TypeS<X>, T>;
    }
    export {};
}
declare const kSchema: unique symbol;
declare const Schema: Schema.Static;
export default Schema;
