var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// community/schemastery/src/index.ts
__export(exports, {
  clone: () => clone,
  default: () => src_default,
  isNullable: () => isNullable,
  isPlainObject: () => isPlainObject,
  valueMap: () => valueMap
});
function isNullable(value) {
  return value === null || value === void 0;
}
__name(isNullable, "isNullable");
function isPlainObject(data) {
  return data && typeof data === "object" && !Array.isArray(data);
}
__name(isPlainObject, "isPlainObject");
function valueMap(object, transform) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, transform(value, key)]));
}
__name(valueMap, "valueMap");
function clone(source) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map(clone);
  if (source instanceof Date)
    return new Date(source.valueOf());
  if (source instanceof RegExp)
    return new RegExp(source.source, source.flags);
  return valueMap(source, clone);
}
__name(clone, "clone");
var index = 0;
var kSchema = Symbol("schemastery");
var Schema = /* @__PURE__ */ __name(function(options) {
  const schema = /* @__PURE__ */ __name(function(data) {
    return Schema.resolve(data, schema)[0];
  }, "schema");
  if (options.refs) {
    const refs2 = valueMap(options.refs, (options2) => new Schema(options2));
    const getRef = /* @__PURE__ */ __name((uid) => refs2[uid], "getRef");
    for (const key in refs2) {
      const options2 = refs2[key];
      options2.sKey = getRef(options2.sKey);
      options2.inner = getRef(options2.inner);
      options2.list = options2.list && options2.list.map(getRef);
      options2.dict = options2.dict && valueMap(options2.dict, getRef);
    }
    return refs2[options.uid];
  }
  Object.assign(schema, options);
  Object.defineProperty(schema, "uid", { value: index++ });
  Object.setPrototypeOf(schema, Schema.prototype);
  schema.meta || (schema.meta = {});
  return schema;
}, "Schema");
Schema.prototype = Object.create(Function.prototype);
Schema.prototype[kSchema] = true;
var refs;
Schema.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
  var _a, _b;
  if (refs) {
    (_b = refs[_a = this.uid]) != null ? _b : refs[_a] = JSON.parse(JSON.stringify(__spreadValues({}, this)));
    return this.uid;
  }
  refs = { [this.uid]: __spreadValues({}, this) };
  refs[this.uid] = JSON.parse(JSON.stringify(__spreadValues({}, this)));
  const result = { uid: this.uid, refs };
  refs = null;
  return result;
}, "toJSON");
Schema.prototype.set = /* @__PURE__ */ __name(function set(key, value) {
  this.dict[key] = value;
  return this;
}, "set");
Schema.prototype.push = /* @__PURE__ */ __name(function push(value) {
  this.list.push(value);
  return this;
}, "push");
for (const key of ["required", "hidden"]) {
  Object.assign(Schema.prototype, {
    [key](value = true) {
      const schema = Schema(this);
      schema.meta = __spreadProps(__spreadValues({}, schema.meta), { [key]: value });
      return schema;
    }
  });
}
for (const key of ["default", "role", "link", "comment", "description", "max", "min", "step"]) {
  Object.assign(Schema.prototype, {
    [key](value) {
      const schema = Schema(this);
      schema.meta = __spreadProps(__spreadValues({}, schema.meta), { [key]: value });
      return schema;
    }
  });
}
var resolvers = {};
Schema.extend = /* @__PURE__ */ __name(function extend(type, resolve2) {
  resolvers[type] = resolve2;
}, "extend");
Schema.resolve = /* @__PURE__ */ __name(function resolve(data, schema, strict) {
  if (!schema)
    return [data];
  if (isNullable(data)) {
    if (schema.meta.required)
      throw new TypeError(`missing required value`);
    const fallback = schema.meta.default;
    if (isNullable(fallback))
      return [data];
    data = clone(fallback);
  }
  const callback = resolvers[schema.type];
  if (callback)
    return callback(data, schema, strict);
  throw new TypeError(`unsupported type "${schema.type}"`);
}, "resolve");
Schema.from = /* @__PURE__ */ __name(function from(source) {
  if (isNullable(source)) {
    return Schema.any();
  } else if (["string", "number", "boolean"].includes(typeof source)) {
    return Schema.const(source).required();
  } else if (source[kSchema]) {
    return source;
  } else if (typeof source === "function") {
    switch (source) {
      case String:
        return Schema.string().required();
      case Number:
        return Schema.number().required();
      case Boolean:
        return Schema.boolean().required();
      case Function:
        return Schema.function().required();
      default:
        return Schema.is(source).required();
    }
  } else {
    throw new TypeError(`cannot infer schema from ${source}`);
  }
}, "from");
Schema.natural = /* @__PURE__ */ __name(function natural() {
  return Schema.number().step(1).min(0);
}, "natural");
Schema.percent = /* @__PURE__ */ __name(function percent() {
  return Schema.number().step(0.01).min(0).max(1).role("slider");
}, "percent");
Schema.extend("any", (data) => {
  return [data];
});
Schema.extend("never", (data) => {
  throw new TypeError(`expected nullable but got ${data}`);
});
Schema.extend("const", (data, { value }) => {
  if (data === value)
    return [value];
  throw new TypeError(`expected ${value} but got ${data}`);
});
function checkWithinRange(data, meta, description) {
  const { max = Infinity, min = -Infinity } = meta;
  if (data > max)
    throw new TypeError(`expected ${description} <= ${max} but got ${data}`);
  if (data < min)
    throw new TypeError(`expected ${description} >= ${min} but got ${data}`);
}
__name(checkWithinRange, "checkWithinRange");
Schema.extend("string", (data, { meta }) => {
  if (typeof data !== "string")
    throw new TypeError(`expected string but got ${data}`);
  checkWithinRange(data.length, meta, "string length");
  return [data];
});
Schema.extend("number", (data, { meta }) => {
  var _a;
  if (typeof data !== "number")
    throw new TypeError(`expected number but got ${data}`);
  checkWithinRange(data, meta, "number");
  const { step } = meta;
  if (step) {
    const quotient = Math.abs(data - ((_a = meta.min) != null ? _a : 0)) % step;
    if (quotient >= Number.EPSILON && quotient < step - Number.EPSILON) {
      throw new TypeError(`expected number multiple of ${step} but got ${data}`);
    }
  }
  return [data];
});
Schema.extend("boolean", (data) => {
  if (typeof data === "boolean")
    return [data];
  throw new TypeError(`expected boolean but got ${data}`);
});
Schema.extend("function", (data) => {
  if (typeof data === "function")
    return [data];
  throw new TypeError(`expected function but got ${data}`);
});
Schema.extend("is", (data, { callback }) => {
  if (data instanceof callback)
    return [data];
  throw new TypeError(`expected ${callback.name} but got ${data}`);
});
function property(data, key, schema) {
  const [value, adapted] = Schema.resolve(data[key], schema);
  if (!isNullable(adapted))
    data[key] = adapted;
  return value;
}
__name(property, "property");
Schema.extend("array", (data, { inner, meta }) => {
  if (!Array.isArray(data))
    throw new TypeError(`expected array but got ${data}`);
  checkWithinRange(data.length, meta, "array length");
  return [data.map((_, index2) => property(data, index2, inner))];
});
Schema.extend("dict", (data, { inner, sKey }, strict) => {
  if (!isPlainObject(data))
    throw new TypeError(`expected object but got ${data}`);
  const result = {};
  for (const key in data) {
    let rKey;
    try {
      rKey = Schema.resolve(key, sKey)[0];
    } catch (error) {
      if (strict)
        continue;
      throw error;
    }
    result[rKey] = property(data, key, inner);
    data[rKey] = data[key];
    if (key !== rKey)
      delete data[key];
  }
  return [result];
});
Schema.extend("tuple", (data, { list }, strict) => {
  if (!Array.isArray(data))
    throw new TypeError(`expected array but got ${data}`);
  const result = list.map((inner, index2) => property(data, index2, inner));
  if (strict)
    return [result];
  result.push(...data.slice(list.length));
  return [result];
});
function merge(result, data) {
  for (const key in data) {
    if (key in result)
      continue;
    result[key] = data[key];
  }
}
__name(merge, "merge");
Schema.extend("object", (data, { dict }, strict) => {
  if (!isPlainObject(data))
    throw new TypeError(`expected object but got ${data}`);
  const result = {};
  for (const key in dict) {
    const value = property(data, key, dict[key]);
    if (!isNullable(value) || key in data) {
      result[key] = value;
    }
  }
  if (!strict)
    merge(result, data);
  return [result];
});
Schema.extend("union", (data, { list, toString }) => {
  const messages = [];
  for (const inner of list) {
    try {
      return Schema.resolve(data, inner);
    } catch (error) {
      messages.push(error.message);
    }
  }
  throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`);
});
Schema.extend("intersect", (data, { list }, strict) => {
  const result = {};
  for (const inner of list) {
    const value = Schema.resolve(data, inner, true)[0];
    Object.assign(result, value);
  }
  if (!strict && isPlainObject(data))
    merge(result, data);
  return [result];
});
Schema.extend("transform", (data, { inner, callback }) => {
  const [result, adapted = data] = Schema.resolve(data, inner, true);
  if (isPlainObject(data)) {
    const temp = {};
    for (const key in result) {
      if (!(key in data))
        continue;
      temp[key] = data[key];
      delete data[key];
    }
    Object.assign(data, callback(temp));
    return [callback(result)];
  } else {
    return [callback(result), callback(adapted)];
  }
});
function defineMethod(name, keys, format) {
  Object.assign(Schema, {
    [name](...args) {
      const schema = new Schema({ type: name });
      schema.toString = format.bind(null, schema);
      keys.forEach((key, index2) => {
        var _a;
        switch (key) {
          case "sKey":
            schema.sKey = (_a = args[index2]) != null ? _a : Schema.string();
            break;
          case "inner":
            schema.inner = Schema.from(args[index2]);
            break;
          case "list":
            schema.list = args[index2].map(Schema.from);
            break;
          case "dict":
            schema.dict = valueMap(args[index2], Schema.from);
            break;
          default:
            schema[key] = args[index2];
        }
      });
      if (name === "object" || name === "dict") {
        schema.meta.default = {};
      } else if (name === "array" || name === "tuple") {
        schema.meta.default = [];
      }
      return schema;
    }
  });
}
__name(defineMethod, "defineMethod");
defineMethod("is", ["callback"], ({ callback }) => callback.name);
defineMethod("any", [], () => "any");
defineMethod("never", [], () => "never");
defineMethod("const", ["value"], ({ value }) => typeof value === "string" ? JSON.stringify(value) : value);
defineMethod("string", [], () => "string");
defineMethod("number", [], () => "number");
defineMethod("boolean", [], () => "boolean");
defineMethod("function", [], () => "function");
defineMethod("array", ["inner"], ({ inner }) => `${inner.toString(true)}[]`);
defineMethod("dict", ["inner", "sKey"], ({ inner, sKey }) => `{ [key: ${sKey.toString()}]: ${inner.toString()} }`);
defineMethod("tuple", ["list"], ({ list }) => `[${list.map((inner) => inner.toString()).join(", ")}]`);
defineMethod("object", ["dict"], ({ dict }) => {
  if (Object.keys(dict).length === 0)
    return "{}";
  return `{ ${Object.entries(dict).map(([key, inner]) => {
    return `${key}${inner.meta.required ? "" : "?"}: ${inner.toString()}`;
  }).join(", ")} }`;
});
defineMethod("union", ["list"], ({ list }, inline) => {
  const result = list.map(({ toString: format }) => format()).join(" | ");
  return inline ? `(${result})` : result;
});
defineMethod("intersect", ["list"], ({ list }) => {
  return `${list.map((inner) => inner.toString(true)).join(" & ")}`;
});
defineMethod("transform", ["inner", "callback"], ({ inner }, isInner) => inner.toString(isInner));
var src_default = Schema;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  clone,
  isNullable,
  isPlainObject,
  valueMap
});
//# sourceMappingURL=node.js.map
