{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export type Dict<T = any, K extends string = string> = { [key in K]?: T }\nexport type Intersect<U> = (U extends any ? (arg: U) => void : never) extends ((arg: infer I) => void) ? I : never\n\nexport function isNullable(value: any) {\n  return value === null || value === undefined\n}\n\nexport function isPlainObject(data: any) {\n  return data && typeof data === 'object' && !Array.isArray(data)\n}\n\nexport function valueMap<T, U>(object: Dict<T>, transform: (value: T, key: string) => U): Dict<U> {\n  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, transform(value, key)]))\n}\n\nexport function clone<T>(source: T): T\nexport function clone(source: any) {\n  if (!source || typeof source !== 'object') return source\n  if (Array.isArray(source)) return source.map(clone)\n  if (source instanceof Date) return new Date(source.valueOf())\n  if (source instanceof RegExp) return new RegExp(source.source, source.flags)\n  return valueMap(source, clone)\n}\n\ninterface Schema<S = any, T = S> extends Schema.Base<T> {\n  (data: S): T\n  (data?: null): T\n  new (data: S): T\n  new (data?: null): T\n  [kSchema]: true\n  toJSON(): Schema.Base<T>\n  required(value?: boolean): Schema<S, T>\n  hidden(value?: boolean): Schema<S, T>\n  role(text: string): Schema<S, T>\n  link(link: string): Schema<S, T>\n  default(value: T): Schema<S, T>\n  comment(text: string): Schema<S, T>\n  description(text: string): Schema<S, T>\n  max(value: number): Schema<S, T>\n  min(value: number): Schema<S, T>\n  step(value: number): Schema<S, T>\n  set(key: string, value: Schema): Schema<S, T>\n  push(value: Schema): Schema<S, T>\n}\n\nnamespace Schema {\n  export type From<T> =\n    | T extends string | number | boolean ? Schema<T>\n    : T extends Schema ? T\n    : T extends typeof String ? Schema<string>\n    : T extends typeof Number ? Schema<number>\n    : T extends typeof Boolean ? Schema<boolean>\n    : T extends typeof Function ? Schema<Function, (...args: any[]) => any>\n    : T extends Constructor<infer S> ? Schema<S>\n    : never\n\n  type _TypeS<X> = X extends Schema<infer S, unknown> ? S : never\n  type _TypeT<X> = ReturnType<Extract<X, Schema>>\n\n  export type TypeS<X> = _TypeS<From<X>>\n  export type TypeT<X> = _TypeT<From<X>>\n  export type Resolve = (data: any, schema?: Schema, strict?: boolean) => [any, any?]\n\n  export interface Base<T = any> {\n    uid?: number\n    type?: string\n    sKey?: Schema\n    inner?: Schema\n    list?: Schema[]\n    dict?: Dict<Schema>\n    callback?: Function\n    value?: T\n    meta?: Meta<T>\n    refs?: Dict<Schema>\n    toString(inline?: boolean): string\n  }\n\n  export interface Meta<T = any> {\n    default?: T extends {} ? Partial<T> : T\n    required?: boolean\n    hidden?: boolean\n    role?: string\n    link?: string\n    description?: string\n    comment?: string\n    max?: number\n    min?: number\n    step?: number\n  }\n\n  type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[]\n  type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[]\n  type ObjectS<X extends Dict> = { [K in keyof X]?: TypeS<X[K]> } & Dict\n  type ObjectT<X extends Dict> = { [K in keyof X]?: TypeT<X[K]> } & Dict\n  type Constructor<T = any> = new (...args: any[]) => T\n\n  export interface Static {\n    <T = any>(options: Base<T>): Schema<T>\n    new <T = any>(options: Base<T>): Schema<T>\n    prototype: Schema\n    resolve: Resolve\n    from<T>(source: T): Schema<From<T>>\n    extend(type: string, resolve: Resolve): void\n    any(): Schema<any>\n    never(): Schema<never>\n    const<T>(value: T): Schema<T>\n    string(): Schema<string>\n    number(): Schema<number>\n    natural(): Schema<number>\n    percent(): Schema<number>\n    boolean(): Schema<boolean>\n    function(): Schema<Function, (...args: any[]) => any>\n    is<T>(constructor: Constructor<T>): Schema<T>\n    array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>\n    dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>\n    tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>\n    object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>\n    union<X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>\n    intersect<X>(list: readonly X[]): Schema<Intersect<TypeS<X>>, Intersect<TypeT<X>>>\n    transform<X, T>(inner: X, callback: (value: TypeS<X>) => T): Schema<TypeS<X>, T>\n  }\n}\n\nlet index = 0\n\nconst kSchema = Symbol('schemastery')\n\nconst Schema = function (options: Schema.Base) {\n  const schema = function (data: any) {\n    return Schema.resolve(data, schema)[0]\n  } as Schema\n\n  if (options.refs) {\n    const refs = valueMap(options.refs, options => new Schema(options))\n    const getRef = (uid: any) => refs[uid]\n    for (const key in refs) {\n      const options = refs[key]\n      options.sKey = getRef(options.sKey)\n      options.inner = getRef(options.inner)\n      options.list = options.list && options.list.map(getRef)\n      options.dict = options.dict && valueMap(options.dict, getRef)\n    }\n    return refs[options.uid]\n  }\n\n  Object.assign(schema, options)\n  Object.defineProperty(schema, 'uid', { value: index++ })\n  Object.setPrototypeOf(schema, Schema.prototype)\n  schema.meta ||= {}\n  return schema\n} as Schema.Static\n\nSchema.prototype = Object.create(Function.prototype)\n\nSchema.prototype[kSchema] = true\n\nlet refs: Dict<Schema>\n\nSchema.prototype.toJSON = function toJSON() {\n  if (refs) {\n    refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }))\n    return this.uid\n  }\n\n  refs = { [this.uid]: { ...this } }\n  refs[this.uid] = JSON.parse(JSON.stringify({ ...this }))\n  const result = { uid: this.uid, refs }\n  refs = null\n  return result\n}\n\nSchema.prototype.set = function set(key, value) {\n  this.dict[key] = value\n  return this\n}\n\nSchema.prototype.push = function push(value) {\n  this.list.push(value)\n  return this\n}\n\nfor (const key of ['required', 'hidden']) {\n  Object.assign(Schema.prototype, {\n    [key](value = true) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nfor (const key of ['default', 'role', 'link', 'comment', 'description', 'max', 'min', 'step']) {\n  Object.assign(Schema.prototype, {\n    [key](value: any) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nconst resolvers: Dict<Schema.Resolve> = {}\n\nSchema.extend = function extend(type: string, resolve) {\n  resolvers[type] = resolve\n}\n\nSchema.resolve = function resolve(data, schema, strict) {\n  if (!schema) return [data]\n\n  if (isNullable(data)) {\n    if (schema.meta.required) throw new TypeError(`missing required value`)\n    const fallback = schema.meta.default\n    if (isNullable(fallback)) return [data]\n    data = clone(fallback)\n  }\n\n  const callback = resolvers[schema.type]\n  if (callback) return callback(data, schema, strict)\n  throw new TypeError(`unsupported type \"${schema.type}\"`)\n}\n\nSchema.from = function from(source: any) {\n  if (isNullable(source)) {\n    return Schema.any()\n  } else if (['string', 'number', 'boolean'].includes(typeof source)) {\n    return Schema.const(source).required()\n  } else if (source[kSchema]) {\n    return source\n  } else if (typeof source === 'function') {\n    switch (source) {\n      case String: return Schema.string().required()\n      case Number: return Schema.number().required()\n      case Boolean: return Schema.boolean().required()\n      case Function: return Schema.function().required()\n      default: return Schema.is(source).required()\n    }\n  } else {\n    throw new TypeError(`cannot infer schema from ${source}`)\n  }\n}\n\nSchema.natural = function natural() {\n  return Schema.number().step(1).min(0)\n}\n\nSchema.percent = function percent() {\n  return Schema.number().step(0.01).min(0).max(1).role('slider')\n}\n\nSchema.extend('any', (data) => {\n  return [data]\n})\n\nSchema.extend('never', (data) => {\n  throw new TypeError(`expected nullable but got ${data}`)\n})\n\nSchema.extend('const', (data, { value }) => {\n  if (data === value) return [value]\n  throw new TypeError(`expected ${value} but got ${data}`)\n})\n\nSchema.extend('string', (data) => {\n  if (typeof data === 'string') return [data]\n  throw new TypeError(`expected string but got ${data}`)\n})\n\nSchema.extend('number', (data, { meta }) => {\n  const { max = Infinity, min = -Infinity, step } = meta\n  if (typeof data !== 'number') throw new TypeError(`expected number but got ${data}`)\n  if (data > max) throw new TypeError(`expected number <= ${max} but got ${data}`)\n  if (data < min) throw new TypeError(`expected number >= ${min} but got ${data}`)\n  if (step) {\n    const quotient = Math.abs(data - (meta.min ?? 0)) % step\n    if (quotient >= Number.EPSILON && quotient < step - Number.EPSILON) {\n      throw new TypeError(`expected number multiple of ${step} but got ${data}`)\n    }\n  }\n  return [data]\n})\n\nSchema.extend('boolean', (data) => {\n  if (typeof data === 'boolean') return [data]\n  throw new TypeError(`expected boolean but got ${data}`)\n})\n\nSchema.extend('function', (data) => {\n  if (typeof data === 'function') return [data]\n  throw new TypeError(`expected function but got ${data}`)\n})\n\nSchema.extend('is', (data, { callback }) => {\n  if (data instanceof callback) return [data]\n  throw new TypeError(`expected ${callback.name} but got ${data}`)\n})\n\nfunction property(data: any, key: keyof any, schema?: Schema) {\n  const [value, adapted] = Schema.resolve(data[key], schema)\n  if (!isNullable(adapted)) data[key] = adapted\n  return value\n}\n\nSchema.extend('array', (data, { inner }) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  return [data.map((_, index) => property(data, index, inner))]\n})\n\nSchema.extend('dict', (data, { inner, sKey }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result = {}\n  for (const key in data) {\n    let rKey: string\n    try {\n      rKey = Schema.resolve(key, sKey)[0]\n    } catch (error) {\n      if (strict) continue\n      throw error\n    }\n    result[rKey] = property(data, key, inner)\n    data[rKey] = data[key]\n    if (key !== rKey) delete data[key]\n  }\n  return [result]\n})\n\nSchema.extend('tuple', (data, { list }, strict) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  const result = list.map((inner, index) => property(data, index, inner))\n  if (strict) return [result]\n  result.push(...data.slice(list.length))\n  return [result]\n})\n\nfunction merge(result: any, data: any) {\n  for (const key in data) {\n    if (key in result) continue\n    result[key] = data[key]\n  }\n}\n\nSchema.extend('object', (data, { dict }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result = {}\n  for (const key in dict) {\n    const value = property(data, key, dict[key])\n    if (!isNullable(value) || key in data) {\n      result[key] = value\n    }\n  }\n  if (!strict) merge(result, data)\n  return [result]\n})\n\nSchema.extend('union', (data, { list, toString }) => {\n  const messages: string[] = []\n  for (const inner of list) {\n    try {\n      return Schema.resolve(data, inner)\n    } catch (error) {\n      messages.push(error.message)\n    }\n  }\n  throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n})\n\nSchema.extend('intersect', (data, { list }, strict) => {\n  const result = {}\n  for (const inner of list) {\n    const value = Schema.resolve(data, inner, true)[0]\n    Object.assign(result, value)\n  }\n  if (!strict && isPlainObject(data)) merge(result, data)\n  return [result]\n})\n\nSchema.extend('transform', (data, { inner, callback }) => {\n  const [result, adapted = data] = Schema.resolve(data, inner, true)\n  if (isPlainObject(data)) {\n    const temp = {}\n    for (const key in result) {\n      if (!(key in data)) continue\n      temp[key] = data[key]\n      delete data[key]\n    }\n    Object.assign(data, callback(temp))\n    return [callback(result)]\n  } else {\n    return [callback(result), callback(adapted)]\n  }\n})\n\ntype Formatter = (schema: Schema, inline?: boolean) => string\n\nfunction defineMethod(name: string, keys: (keyof Schema.Base)[], format: Formatter) {\n  Object.assign(Schema, {\n    [name](...args: any[]) {\n      const schema = new Schema({ type: name })\n      schema.toString = format.bind(null, schema)\n      keys.forEach((key: string, index) => {\n        switch (key) {\n          case 'sKey': schema.sKey = args[index] ?? Schema.string(); break\n          case 'inner': schema.inner = Schema.from(args[index]); break\n          case 'list': schema.list = args[index].map(Schema.from); break\n          case 'dict': schema.dict = valueMap(args[index], Schema.from); break\n          default: schema[key] = args[index]\n        }\n      })\n      if (name === 'object' || name === 'dict') {\n        schema.meta.default = {}\n      } else if (name === 'array' || name === 'tuple') {\n        schema.meta.default = []\n      }\n      return schema\n    },\n  })\n}\n\ndefineMethod('is', ['callback'], ({ callback }) => callback.name)\ndefineMethod('any', [], () => 'any')\ndefineMethod('never', [], () => 'never')\ndefineMethod('const', ['value'], ({ value }) => typeof value === 'string' ? JSON.stringify(value) : value)\ndefineMethod('string', [], () => 'string')\ndefineMethod('number', [], () => 'number')\ndefineMethod('boolean', [], () => 'boolean')\ndefineMethod('function', [], () => 'function')\ndefineMethod('array', ['inner'], ({ inner }) => `${inner.toString(true)}[]`)\ndefineMethod('dict', ['inner', 'sKey'], ({ inner, sKey }) => `{ [key: ${sKey.toString()}]: ${inner.toString()} }`)\ndefineMethod('tuple', ['list'], ({ list }) => `[${list.map((inner) => inner.toString()).join(', ')}]`)\n\ndefineMethod('object', ['dict'], ({ dict }) => {\n  if (Object.keys(dict).length === 0) return '{}'\n  return `{ ${Object.entries(dict).map(([key, inner]) => {\n    return `${key}${inner.meta.required ? '' : '?'}: ${inner.toString()}`\n  }).join(', ')} }`\n})\n\ndefineMethod('union', ['list'], ({ list }, inline) => {\n  const result = list.map(({ toString: format }) => format()).join(' | ')\n  return inline ? `(${result})` : result\n})\n\ndefineMethod('intersect', ['list'], ({ list }) => {\n  return `${list.map((inner) => inner.toString(true)).join(' & ')}`\n})\n\ndefineMethod('transform', ['inner', 'callback'], ({ inner }, isInner) => inner.toString(isInner))\n\nexport default Schema\n"],
  "mappings": "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",
  "names": []
}
