var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// yaml:/Users/shigma/Documents/code/koishi-next/packages/core/src/locales/zh.yml
var require_zh = __commonJS({
  "yaml:/Users/shigma/Documents/code/koishi-next/packages/core/src/locales/zh.yml"(exports, module2) {
    module2.exports = { general: { name: "中文", paren: "（{0}）", quote: "“{0}”", comma: "，", and: "和", or: "或", day: "天", hour: "小时", minute: "分钟", second: "秒" }, internal: { "low-authority": "权限不足。", "insufficient-arguments": "缺少参数，输入帮助以查看用法。", "redunant-arguments": "存在多余参数，输入帮助以查看用法。", "invalid-argument": "参数 {0} 输入无效，{1}", "unknown-option": "存在未知选项 {0}，输入帮助以查看用法。", "invalid-option": "选项 {0} 输入无效，{1}", "check-syntax": "输入帮助以查看用法。", "invalid-number": "请提供一个数字。", "invalid-integer": "请提供一个整数。", "invalid-posint": "请提供一个正整数。", "invalid-natural": "请提供一个非负整数。", "invalid-date": "请输入合法的时间。", "invalid-user": "请指定正确的用户。", "invalid-channel": "请指定正确的频道。" }, suggest: { hint: "您要找的是不是{0}？", "command-prefix": "", "command-suffix": "发送空行或句号以使用推测的指令。", "help-prefix": "指令未找到。", "help-suffix": "发送空行或句号以使用推测的指令。" }, commands: { help: { description: "显示帮助信息", options: { help: "显示此信息", authority: "显示权限设置", showHidden: "查看隐藏的选项和指令" }, messages: { "hint-authority": "括号内为对应的最低权限等级", "hint-subcommand": "标有星号的表示含有子指令", "command-aliases": "别名：{0}。", "command-examples": "使用示例：", "command-authority": "最低权限：{0} 级。", "subcommand-prolog": "可用的子指令有{0}：", "global-prolog": "当前可用的指令有{0}：", "global-epilog": "输入“帮助 指令名”查看特定指令的语法和使用示例。", "available-options": "可用的选项有：", "available-options-with-authority": "可用的选项有（括号内为额外要求的权限等级）：" } } } };
  }
});

// yaml:/Users/shigma/Documents/code/koishi-next/packages/core/src/locales/en.yml
var require_en = __commonJS({
  "yaml:/Users/shigma/Documents/code/koishi-next/packages/core/src/locales/en.yml"(exports, module2) {
    module2.exports = { general: { name: "English", paren: " ({0}) ", quote: '"{0}"', comma: ", ", and: "and", or: "or", day: "day", hour: "hour", minute: "minute", second: "second" }, internal: { "low-authority": "Low authority.", "insufficient-arguments": "Insufficient arguments, type help to see usage.", "redunant-arguments": "Redunant arguments, type help to see usage.", "invalid-argument": "Invalid argument {0}, {1}", "unknown-option": "Unknown option {0}, type help to see usage.", "invalid-option": "Invalid option {0}, {1}", "check-syntax": "Type help to see usage.", "invalid-number": "Expect a number.", "invalid-integer": "Expect an integer.", "invalid-posint": "Expect a positive integer.", "invalid-natural": "Expect a non-negative integer.", "invalid-date": "Expect a valid date.", "invalid-user": "Expect a valid user.", "invalid-channel": "Expect a valid channel." }, suggest: { hint: "Do you mean {0}?", "command-prefix": "", "command-suffix": "Send a period to apply the suggestion.", "help-prefix": "Command not found.", "help-suffix": "Send a blank line or a period to apply the suggestion." }, commands: { help: { description: "Show help", options: { help: "show this message", authority: "show authority requirements", showHidden: "show hidden options and commands" }, messages: { "hint-authority": "this minimum authority is marked in parentheses", "hint-subcommand": "those marked with an asterisk have subcommands", "command-aliases": "Aliases: {0}.", "command-examples": "Examples:", "command-authority": "Minimal authority: {0}.", "subcommand-prolog": "Available subcommands{0}:", "global-prolog": "Available commands{0}:", "global-epilog": 'Type "help <command>" to see syntax and examples for a specific command.', "available-options": "Available options:", "available-options-with-authority": "Available options (parentheses indicate additional authority requirement):" } } } };
  }
});

// packages/core/src/index.ts
__export(exports, {
  Adapter: () => Adapter,
  App: () => App,
  Argv: () => Argv,
  Bot: () => Bot,
  Channel: () => Channel,
  Command: () => Command,
  Context: () => Context,
  Database: () => Database,
  ModelService: () => ModelService,
  Modules: () => Modules,
  Next: () => Next,
  Plugin: () => Plugin,
  Service: () => Service,
  Session: () => Session,
  SharedCache: () => SharedCache,
  User: () => User,
  defineConfig: () => defineConfig,
  enableHelp: () => enableHelp,
  getCommandNames: () => getCommandNames,
  getSessionId: () => getSessionId,
  unwrapExports: () => unwrapExports,
  version: () => version
});
__reExport(exports, __toModule(require("@koishijs/utils")));
__reExport(exports, __toModule(require("@koishijs/orm")));

// packages/core/src/adapter.ts
var import_utils6 = __toModule(require("@koishijs/utils"));

// packages/core/src/bot.ts
var import_utils5 = __toModule(require("@koishijs/utils"));

// packages/core/src/command.ts
var import_utils3 = __toModule(require("@koishijs/utils"));

// packages/core/src/parser.ts
var import_utils = __toModule(require("@koishijs/utils"));
var leftQuotes = `"'“‘`;
var rightQuotes = `"'”’`;
var Argv;
(function(Argv2) {
  const bracs = {};
  function interpolate(initiator, terminator, parse2) {
    bracs[initiator] = { terminator, parse: parse2 };
  }
  Argv2.interpolate = interpolate;
  __name(interpolate, "interpolate");
  interpolate("$(", ")");
  class Tokenizer {
    constructor() {
      this.bracs = Object.create(bracs);
    }
    interpolate(initiator, terminator, parse2) {
      this.bracs[initiator] = { terminator, parse: parse2 };
    }
    parseToken(source, stopReg = "$") {
      const parent = { inters: [] };
      const index = leftQuotes.indexOf(source[0]);
      const quote = rightQuotes[index];
      let content = "";
      if (quote) {
        source = source.slice(1);
        stopReg = `${quote}(?=${stopReg})|$`;
      }
      stopReg += `|${Object.keys(__spreadValues(__spreadValues({}, this.bracs), bracs)).map(import_utils.escapeRegExp).join("|")}`;
      const regExp = new RegExp(stopReg);
      while (true) {
        const capture = regExp.exec(source);
        content += source.slice(0, capture.index);
        if (capture[0] in this.bracs) {
          source = source.slice(capture.index + capture[0].length).trimStart();
          const { parse: parse2, terminator } = this.bracs[capture[0]];
          const argv = (parse2 == null ? void 0 : parse2(source)) || this.parse(source, terminator);
          source = argv.rest;
          parent.inters.push(__spreadProps(__spreadValues({}, argv), { pos: content.length, initiator: capture[0] }));
        } else {
          const quoted = capture[0] === quote;
          const rest = source.slice(capture.index + +quoted);
          parent.rest = rest.trimStart();
          parent.quoted = quoted;
          parent.terminator = capture[0];
          if (quoted) {
            parent.terminator += rest.slice(0, -parent.rest.length);
          } else if (quote) {
            content = leftQuotes[index] + content;
            parent.inters.forEach((inter) => inter.pos += 1);
          }
          parent.content = content;
          if (quote === "'")
            Argv2.revert(parent);
          return parent;
        }
      }
    }
    parse(source, terminator = "") {
      const tokens = [];
      let rest = source, term = "";
      const stopReg = `\\s+|[${(0, import_utils.escapeRegExp)(terminator)}]|$`;
      while (rest && !(terminator && rest.startsWith(terminator))) {
        const token = this.parseToken(rest, stopReg);
        tokens.push(token);
        rest = token.rest;
        term = token.terminator;
        delete token.rest;
      }
      if (rest.startsWith(terminator))
        rest = rest.slice(1);
      source = source.slice(0, -(rest + term).length);
      return { tokens, rest, source };
    }
    stringify(argv) {
      const output = argv.tokens.reduce((prev, token) => {
        if (token.quoted)
          prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])] || "";
        return prev + token.content + token.terminator;
      }, "");
      if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {
        return output.slice(0, -1);
      }
      return output;
    }
  }
  __name(Tokenizer, "Tokenizer");
  Argv2.Tokenizer = Tokenizer;
  const defaultTokenizer = new Tokenizer();
  function parse(source, terminator = "") {
    return defaultTokenizer.parse(source, terminator);
  }
  Argv2.parse = parse;
  __name(parse, "parse");
  function stringify(argv) {
    return defaultTokenizer.stringify(argv);
  }
  Argv2.stringify = stringify;
  __name(stringify, "stringify");
  function revert(token) {
    while (token.inters.length) {
      const { pos, source, initiator } = token.inters.pop();
      token.content = token.content.slice(0, pos) + initiator + source + bracs[initiator].terminator + token.content.slice(pos);
    }
  }
  Argv2.revert = revert;
  __name(revert, "revert");
  function resolveConfig(type) {
    return typeof type === "string" ? builtin[type] || {} : {};
  }
  __name(resolveConfig, "resolveConfig");
  function resolveType(type) {
    var _a;
    if (typeof type === "function") {
      return type;
    } else if (type instanceof RegExp) {
      return (source) => {
        if (type.test(source))
          return source;
        throw new Error();
      };
    } else if (Array.isArray(type)) {
      return (source) => {
        if (type.includes(source))
          return source;
        throw new Error();
      };
    }
    return (_a = builtin[type]) == null ? void 0 : _a.transform;
  }
  __name(resolveType, "resolveType");
  const builtin = {};
  function createDomain(name, transform, options) {
    builtin[name] = __spreadProps(__spreadValues({}, options), { transform });
  }
  Argv2.createDomain = createDomain;
  __name(createDomain, "createDomain");
  createDomain("rawtext", (source) => source);
  createDomain("string", (source) => source);
  createDomain("text", (source) => source, { greedy: true });
  createDomain("rawtext", (source) => import_utils.segment.unescape(source), { greedy: true });
  createDomain("boolean", () => true);
  createDomain("number", (source, session) => {
    const value = +source;
    if (Number.isFinite(value))
      return value;
    throw new Error(session.text("internal.invalid-number"));
  });
  createDomain("integer", (source, session) => {
    const value = +source;
    if (value * 0 === 0 && Math.floor(value) === value)
      return value;
    throw new Error(session.text("internal.invalid-integer"));
  });
  createDomain("posint", (source, session) => {
    const value = +source;
    if (value * 0 === 0 && Math.floor(value) === value && value > 0)
      return value;
    throw new Error(session.text("internal.invalid-posint"));
  });
  createDomain("natural", (source, session) => {
    const value = +source;
    if (value * 0 === 0 && Math.floor(value) === value && value >= 0)
      return value;
    throw new Error(session.text("internal.invalid-natural"));
  });
  createDomain("date", (source, session) => {
    const timestamp = import_utils.Time.parseDate(source);
    if (+timestamp)
      return timestamp;
    throw new Error(session.text("internal.invalid-date"));
  });
  createDomain("user", (source, session) => {
    if (source.startsWith("@")) {
      source = source.slice(1);
      if (source.includes(":"))
        return source;
      return `${session.platform}:${source}`;
    }
    const code = import_utils.segment.from(source);
    if (code && code.type === "at") {
      return `${session.platform}:${code.data.id}`;
    }
    throw new Error(session.text("internal.invalid-user"));
  });
  createDomain("channel", (source, session) => {
    if (source.startsWith("#")) {
      source = source.slice(1);
      if (source.includes(":"))
        return source;
      return `${session.platform}:${source}`;
    }
    const code = import_utils.segment.from(source);
    if (code && code.type === "sharp") {
      return `${session.platform}:${code.data.id}`;
    }
    throw new Error(session.text("internal.invalid-channel"));
  });
  const BRACKET_REGEXP = /<[^>]+>|\[[^\]]+\]/g;
  function parseDecl(source) {
    let cap;
    const result = [];
    while (cap = BRACKET_REGEXP.exec(source)) {
      let rawName = cap[0].slice(1, -1);
      let variadic = false;
      if (rawName.startsWith("...")) {
        rawName = rawName.slice(3);
        variadic = true;
      }
      const [name, rawType] = rawName.split(":");
      const type = rawType ? rawType.trim() : void 0;
      result.push({
        name,
        variadic,
        type,
        required: cap[0][0] === "<"
      });
    }
    result.stripped = source.replace(/:[\w-]+[>\]]/g, (str) => str.slice(-1)).trimEnd();
    return result;
  }
  __name(parseDecl, "parseDecl");
  function parseValue(source, quoted, kind, argv, decl = {}) {
    const { name, type, fallback } = decl;
    const implicit = source === "" && !quoted;
    if (implicit && fallback !== void 0)
      return fallback;
    const transform = resolveType(type);
    if (transform) {
      try {
        return transform(source, argv.session);
      } catch (err) {
        if (!argv.session) {
          argv.error = `internal.invalid-${kind}`;
        } else {
          const message = err["message"] || argv.session.text("internal.check-syntax");
          argv.error = argv.session.text(`internal.invalid-${kind}`, [name, message]);
        }
        return;
      }
    }
    if (implicit)
      return true;
    if (quoted)
      return source;
    const n = +source;
    return n * 0 === 0 ? n : source;
  }
  Argv2.parseValue = parseValue;
  __name(parseValue, "parseValue");
  class CommandBase {
    constructor(name, declaration, context) {
      this.name = name;
      this.context = context;
      this._options = {};
      this._namedOptions = {};
      this._symbolicOptions = {};
      if (!name)
        throw new Error("expect a command name");
      const decl = this._arguments = parseDecl(declaration);
      this.declaration = decl.stripped;
    }
    _createOption(name, def, config) {
      var _a;
      const param = (0, import_utils.paramCase)(name);
      const decl = def.replace(/(?<=^|\s)[\w\x80-\uffff].*/, "");
      const desc = def.slice(decl.length);
      let syntax = decl.replace(/(?<=^|\s)(<[^<]+>|\[[^[]+\]).*/, "");
      const bracket = decl.slice(syntax.length);
      syntax = syntax.trim() || "--" + param;
      const names = [];
      const symbols = [];
      for (let param2 of syntax.trim().split(",")) {
        param2 = param2.trimStart();
        const name2 = param2.replace(/^-+/, "");
        if (!name2 || !param2.startsWith("-")) {
          symbols.push(param2);
        } else {
          names.push(name2);
        }
      }
      if (!config.value && !names.includes(param)) {
        syntax += ", --" + param;
      }
      const declList = parseDecl(bracket);
      if (declList.stripped)
        syntax += " " + declList.stripped;
      const option = (_a = this._options)[name] || (_a[name] = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, Command.defaultOptionConfig), declList[0]), config), {
        name,
        values: {},
        syntax
      }));
      if (desc)
        this.context.i18n.define("", `commands.${this.name}.options.${name}`, desc);
      const fallbackType = typeof option.fallback;
      if ("value" in config) {
        names.forEach((name2) => option.values[name2] = config.value);
      } else if (!bracket.trim()) {
        option.type = "boolean";
      } else if (!option.type && (fallbackType === "string" || fallbackType === "number")) {
        option.type = fallbackType;
      }
      this._assignOption(option, names, this._namedOptions);
      this._assignOption(option, symbols, this._symbolicOptions);
      if (!this._namedOptions[param]) {
        this._namedOptions[param] = option;
      }
    }
    _assignOption(option, names, optionMap) {
      for (const name of names) {
        if (name in optionMap) {
          throw new Error(`duplicate option name "${name}" for command "${this.name}"`);
        }
        optionMap[name] = option;
      }
    }
    removeOption(name) {
      if (!this._options[name])
        return false;
      const option = this._options[name];
      delete this._options[name];
      for (const key in this._namedOptions) {
        if (this._namedOptions[key] === option) {
          delete this._namedOptions[key];
        }
      }
      for (const key in this._symbolicOptions) {
        if (this._symbolicOptions[key] === option) {
          delete this._symbolicOptions[key];
        }
      }
      return true;
    }
    parse(argv, terminator, args = [], options = {}) {
      var _a;
      if (typeof argv === "string")
        argv = Argv2.parse(argv, terminator);
      const source = this.name + " " + Argv2.stringify(argv);
      while (!argv.error && argv.tokens.length) {
        const token = argv.tokens[0];
        let { content, quoted } = token;
        const argDecl = this._arguments[args.length];
        if (content[0] !== "-" && resolveConfig(argDecl == null ? void 0 : argDecl.type).greedy) {
          args.push(Argv2.parseValue(Argv2.stringify(argv), true, "argument", argv, argDecl));
          break;
        }
        argv.tokens.shift();
        let option;
        let names;
        let param;
        if (!quoted && (option = this._symbolicOptions[content])) {
          names = [(0, import_utils.paramCase)(option.name)];
        } else {
          if (content[0] !== "-" || quoted) {
            args.push(Argv2.parseValue(content, quoted, "argument", argv, argDecl || { type: "string" }));
            continue;
          }
          let i = 0;
          let name;
          for (; i < content.length; ++i) {
            if (content.charCodeAt(i) !== 45)
              break;
          }
          if (content.slice(i, i + 3) === "no-" && !this._namedOptions[content.slice(i)]) {
            name = content.slice(i + 3);
            options[(0, import_utils.camelCase)(name)] = false;
            continue;
          }
          let j = i + 1;
          for (; j < content.length; j++) {
            if (content.charCodeAt(j) === 61)
              break;
          }
          name = content.slice(i, j);
          names = i > 1 ? [name] : name;
          param = content.slice(++j);
          option = this._namedOptions[names[names.length - 1]];
        }
        quoted = false;
        if (!param) {
          const { type } = option || {};
          if (resolveConfig(type).greedy) {
            param = Argv2.stringify(argv);
            quoted = true;
            argv.tokens = [];
          } else if (type !== "boolean" && argv.tokens.length && (type || ((_a = argv.tokens[0]) == null ? void 0 : _a.content) !== "-")) {
            const token2 = argv.tokens.shift();
            param = token2.content;
            quoted = token2.quoted;
          }
        }
        for (let j = 0; j < names.length; j++) {
          const name = names[j];
          const optDecl = this._namedOptions[name];
          const key = optDecl ? optDecl.name : (0, import_utils.camelCase)(name);
          if (optDecl && name in optDecl.values) {
            options[key] = optDecl.values[name];
          } else {
            const source2 = j + 1 < names.length ? "" : param;
            options[key] = Argv2.parseValue(source2, quoted, "option", argv, optDecl);
          }
          if (argv.error)
            break;
        }
      }
      for (const { name, fallback } of Object.values(this._options)) {
        if (fallback !== void 0 && !(name in options)) {
          options[name] = fallback;
        }
      }
      delete argv.tokens;
      return { options, args, source, rest: argv.rest, error: argv.error || "" };
    }
    stringifyArg(value) {
      value = "" + value;
      return value.includes(" ") ? `"${value}"` : value;
    }
    stringify(args, options) {
      let output = this.name;
      for (const key in options) {
        const value = options[key];
        if (value === true) {
          output += ` --${key}`;
        } else if (value === false) {
          output += ` --no-${key}`;
        } else {
          output += ` --${key} ${this.stringifyArg(value)}`;
        }
      }
      for (const arg of args) {
        output += " " + this.stringifyArg(arg);
      }
      return output;
    }
  }
  __name(CommandBase, "CommandBase");
  Argv2.CommandBase = CommandBase;
})(Argv || (Argv = {}));

// packages/core/src/context.ts
var import_utils2 = __toModule(require("@koishijs/utils"));

// packages/core/src/database.ts
var import_orm = __toModule(require("@koishijs/orm"));
var User;
(function(User3) {
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["ignore"] = 1] = "ignore";
  })(Flag = User3.Flag || (User3.Flag = {}));
  User3.fields = [];
})(User || (User = {}));
var Channel;
(function(Channel2) {
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["ignore"] = 1] = "ignore";
    Flag2[Flag2["silent"] = 4] = "silent";
  })(Flag = Channel2.Flag || (Channel2.Flag = {}));
  Channel2.fields = [];
})(Channel || (Channel = {}));
var ModelService = class extends import_orm.Model {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.extend("user", {
      id: "string(63)",
      name: "string(63)",
      flag: "unsigned(20)",
      authority: "unsigned(4)",
      locale: "string(63)"
    }, {
      autoInc: true
    });
    this.extend("channel", {
      id: "string(63)",
      platform: "string(63)",
      flag: "unsigned(20)",
      assignee: "string(63)",
      guildId: "string(63)",
      locale: "string(63)"
    }, {
      primary: ["id", "platform"]
    });
  }
  extend(name, fields, extension) {
    super.extend(name, fields, extension);
    this.ctx.emit("model", name);
  }
};
__name(ModelService, "ModelService");
var Service = class {
  constructor(ctx, name, immediate) {
    this.ctx = ctx;
    this.name = name;
    this.immediate = immediate;
    Context.service(name);
    ctx.on("ready", async () => {
      await this.start();
      ctx[name] = this;
    });
    ctx.on("dispose", async () => {
      if (ctx[name] === this)
        ctx[name] = null;
      await this.stop();
    });
  }
  start() {
  }
  stop() {
  }
  get caller() {
    return this[Context.current] || this.ctx;
  }
};
__name(Service, "Service");
var Database = class extends import_orm.Driver {
  constructor(ctx) {
    super(ctx.model);
    this.ctx = ctx;
    ctx.on("ready", async () => {
      await this.start();
      ctx.database = this;
    });
    ctx.on("dispose", async () => {
      if (ctx.database === this)
        ctx.database = null;
      await this.stop();
    });
  }
  start() {
  }
  stop() {
  }
  async getUser(platform, id, modifier) {
    const data = await this.get("user", { [platform]: id }, modifier);
    if (Array.isArray(id))
      return data;
    if (data[0])
      Object.assign(data[0], { [platform]: id });
    return data[0];
  }
  setUser(platform, id, data) {
    return this.set("user", { [platform]: id }, data);
  }
  createUser(platform, id, data) {
    return this.create("user", __spreadValues({ [platform]: id }, data));
  }
  async getChannel(platform, id, modifier) {
    const data = await this.get("channel", { platform, id }, modifier);
    if (Array.isArray(id))
      return data;
    if (data[0])
      Object.assign(data[0], { platform, id });
    return data[0];
  }
  async getAssignedChannels(fields, assignMap = this.ctx.getSelfIds()) {
    return this.get("channel", {
      $or: Object.entries(assignMap).map(([platform, assignee]) => ({ platform, assignee }))
    }, fields);
  }
  setChannel(platform, id, data) {
    return this.set("channel", { platform, id }, data);
  }
  createChannel(platform, id, data) {
    return this.create("channel", __spreadValues({ platform, id }, data));
  }
};
__name(Database, "Database");
(function(Database3) {
  function extend(module2, extension) {
    const Database4 = typeof module2 === "string" ? Modules.require(module2) : module2;
    if (!Database4)
      return;
    if (typeof extension === "function") {
      extension(Database4);
    } else {
      Object.assign(Database4.prototype, extension);
    }
  }
  Database3.extend = extend;
  __name(extend, "extend");
})(Database || (Database = {}));
function unwrapExports(module2) {
  return (module2 == null ? void 0 : module2.default) || module2;
}
__name(unwrapExports, "unwrapExports");
var Modules;
(function(Modules2) {
  const cache = {};
  function define(name, value) {
    cache[name] = value;
  }
  Modules2.define = define;
  __name(define, "define");
  let internal;
  (function(internal2) {
    function require3(name) {
      return cache[name];
    }
    internal2.require = require3;
    __name(require3, "require");
    function resolve2(name) {
      if (name in cache)
        return name;
      throw new Error(`Cannot find module "${name}"`);
    }
    internal2.resolve = resolve2;
    __name(resolve2, "resolve");
    function paths(name) {
      const prefix1 = "koishi-plugin-";
      const prefix2 = "@koishijs/plugin-";
      if (name.includes(prefix1) || name.startsWith(prefix2)) {
        return [name];
      } else if (name[0] === "@") {
        const index = name.indexOf("/");
        return [name.slice(0, index + 1) + prefix1 + name.slice(index + 1)];
      } else {
        return [prefix1 + name, prefix2 + name];
      }
    }
    internal2.paths = paths;
    __name(paths, "paths");
  })(internal = Modules2.internal || (Modules2.internal = {}));
  function require2(name, forced = false) {
    try {
      const path = resolve(name);
      const exports = internal.require(path);
      return unwrapExports(exports);
    } catch (error) {
      if (forced)
        throw error;
    }
  }
  Modules2.require = require2;
  __name(require2, "require");
  function resolve(name) {
    const modules = internal.paths(name);
    for (const path of modules) {
      try {
        return internal.resolve(path);
      } catch {
      }
    }
    throw new Error(`cannot resolve plugin "${name}"`);
  }
  Modules2.resolve = resolve;
  __name(resolve, "resolve");
})(Modules || (Modules = {}));

// packages/core/src/context.ts
var Next;
(function(Next2) {
  Next2.MAX_DEPTH = 64;
  async function compose(callback, next) {
    return typeof callback === "function" ? callback(next) : callback;
  }
  Next2.compose = compose;
  __name(compose, "compose");
})(Next || (Next = {}));
var Plugin;
(function(Plugin3) {
  class Registry extends Map {
    resolve(plugin) {
      return plugin && (typeof plugin === "function" ? plugin : plugin.apply);
    }
    get(plugin) {
      return super.get(this.resolve(plugin));
    }
    set(plugin, state) {
      return super.set(this.resolve(plugin), state);
    }
    has(plugin) {
      return super.has(this.resolve(plugin));
    }
    delete(plugin) {
      return super.delete(this.resolve(plugin));
    }
  }
  __name(Registry, "Registry");
  Plugin3.Registry = Registry;
})(Plugin || (Plugin = {}));
function isBailed(value) {
  return value !== null && value !== false && value !== void 0;
}
__name(isBailed, "isBailed");
function isConstructor(func) {
  if (!func.prototype)
    return false;
  if (func.prototype.constructor !== func)
    return false;
  return true;
}
__name(isConstructor, "isConstructor");
function isApplicable(object) {
  return object && typeof object === "object" && typeof object.apply === "function";
}
__name(isApplicable, "isApplicable");
var selectors = ["user", "guild", "channel", "self", "private", "platform"];
var _Context = class {
  constructor(filter, app, _plugin = null) {
    this.filter = filter;
    this.app = app;
    this._plugin = _plugin;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this._plugin ? this._plugin.name : "root"}>`;
  }
  _property(key, ...values) {
    return this.intersect((session) => {
      return values.length ? values.includes(session[key]) : !!session[key];
    });
  }
  user(...values) {
    return this._property("userId", ...values);
  }
  self(...values) {
    return this._property("selfId", ...values);
  }
  guild(...values) {
    return this._property("guildId", ...values);
  }
  channel(...values) {
    return this._property("channelId", ...values);
  }
  platform(...values) {
    return this._property("platform", ...values);
  }
  private(...values) {
    return this.exclude(this._property("guildId"))._property("userId", ...values);
  }
  select(options) {
    let ctx = this;
    for (const type of selectors) {
      const value = options[`$${type}`];
      if (value === true) {
        ctx = ctx[type]();
      } else if (value === false) {
        ctx = ctx.exclude(ctx[type]());
      } else if (value !== void 0) {
        ctx = ctx[type](...(0, import_utils2.makeArray)(value).map((item) => "" + item));
      }
    }
    if (options.$and) {
      for (const selection of options.$and) {
        ctx = ctx.intersect(this.select(selection));
      }
    }
    if (options.$or) {
      let ctx2 = this.app;
      for (const selection of options.$or) {
        ctx2 = ctx2.union(this.select(selection));
      }
      ctx = ctx.intersect(ctx2);
    }
    if (options.$not) {
      ctx = ctx.exclude(this.select(options.$not));
    }
    return ctx;
  }
  logger(name) {
    return new import_utils2.Logger(name);
  }
  any() {
    return new _Context(() => true, this.app, this._plugin);
  }
  never() {
    return new _Context(() => false, this.app, this._plugin);
  }
  union(arg) {
    const filter = typeof arg === "function" ? arg : arg.filter;
    return new _Context((s) => this.filter(s) || filter(s), this.app, this._plugin);
  }
  intersect(arg) {
    const filter = typeof arg === "function" ? arg : arg.filter;
    return new _Context((s) => this.filter(s) && filter(s), this.app, this._plugin);
  }
  exclude(arg) {
    const filter = typeof arg === "function" ? arg : arg.filter;
    return new _Context((s) => this.filter(s) && !filter(s), this.app, this._plugin);
  }
  except(arg) {
    return this.exclude(arg);
  }
  match(session) {
    return !session || this.filter(session);
  }
  get state() {
    return this.app.registry.get(this._plugin);
  }
  using(using, callback) {
    return this.plugin({ using, apply: callback, name: callback.name });
  }
  validate(plugin, config) {
    if (config === false)
      return;
    if (config === true)
      config = void 0;
    config != null ? config : config = {};
    const schema = plugin["Config"] || plugin["schema"];
    if (schema)
      config = schema(config);
    return config;
  }
  plugin(entry, config) {
    const plugin = typeof entry === "string" ? Modules.require(entry, true) : entry;
    if (this.app.registry.has(plugin)) {
      this.logger("app").warn(`duplicate plugin detected: ${plugin.name}`);
      return this;
    }
    if (typeof plugin !== "function" && !isApplicable(plugin)) {
      throw new Error('invalid plugin, expect function or object with an "apply" method');
    }
    config = this.validate(plugin, config);
    if (!config)
      return this;
    const context = new _Context(this.filter, this.app, plugin).select(config);
    const schema = plugin["Config"] || plugin["schema"];
    const using = plugin["using"] || [];
    this.logger("app").debug("plugin:", plugin.name);
    this.app.registry.set(plugin, {
      plugin,
      schema,
      using,
      context,
      id: import_utils2.Random.id(),
      parent: this,
      config,
      children: [],
      disposables: []
    });
    this.state.children.push(plugin);
    this.emit("plugin-added", this.app.registry.get(plugin));
    if (using.length) {
      context.on("service", (name) => {
        if (!using.includes(name))
          return;
        context.state.children.slice().map((plugin2) => this.dispose(plugin2));
        context.state.disposables.slice(1).map((dispose) => dispose());
        callback();
      });
    }
    const callback = /* @__PURE__ */ __name(() => {
      if (using.some((name) => !this[name]))
        return;
      if (typeof plugin !== "function") {
        plugin.apply(context, config);
      } else if (isConstructor(plugin)) {
        const instance = new plugin(context, config);
        if (instance instanceof Service && instance.immediate) {
          context[instance.name] = instance;
        }
      } else {
        plugin(context, config);
      }
    }, "callback");
    callback();
    return this;
  }
  dispose(plugin = this._plugin) {
    if (!plugin)
      throw new Error("root level context cannot be disposed");
    const state = this.app.registry.get(plugin);
    if (!state)
      return;
    this.logger("app").debug("dispose:", plugin.name);
    state.children.slice().map((plugin2) => this.dispose(plugin2));
    state.disposables.slice().map((dispose) => dispose());
    this.app.registry.delete(plugin);
    (0, import_utils2.remove)(state.parent.state.children, plugin);
    this.emit("plugin-removed", state);
    return state;
  }
  *getHooks(name, session) {
    const hooks = this.app._hooks[name] || [];
    for (const [context, callback] of hooks.slice()) {
      if (!context.match(session))
        continue;
      yield callback;
    }
  }
  async parallel(...args) {
    const tasks = [];
    const session = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, session)) {
      tasks.push(Promise.resolve(callback.apply(session, args)).catch((error) => {
        this.logger("app").warn(error);
      }));
    }
    await Promise.all(tasks);
  }
  emit(...args) {
    this.parallel(...args);
  }
  async waterfall(...args) {
    const session = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, session)) {
      const result = await callback.apply(session, args);
      args[0] = result;
    }
    return args[0];
  }
  chain(...args) {
    const session = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, session)) {
      const result = callback.apply(session, args);
      args[0] = result;
    }
    return args[0];
  }
  async serial(...args) {
    const session = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, session)) {
      const result = await callback.apply(session, args);
      if (isBailed(result))
        return result;
    }
  }
  bail(...args) {
    const session = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, session)) {
      const result = callback.apply(session, args);
      if (isBailed(result))
        return result;
    }
  }
  on(name, listener, prepend = false) {
    var _a;
    const method = prepend ? "unshift" : "push";
    if (typeof name === "string" && name in _Context.deprecatedEvents) {
      const alternative = _Context.deprecatedEvents[name];
      this.logger("app").warn(`event "${name}" is deprecated, use "${alternative}" instead`);
      name = alternative;
    }
    if (name === "ready" && this.app.isActive) {
      this.app._tasks.queue((0, import_utils2.sleep)(0).then(() => listener()));
      return () => false;
    } else if (name === "dispose") {
      this.state.disposables[method](listener);
      return () => (0, import_utils2.remove)(this.state.disposables, listener);
    }
    const hooks = (_a = this.app._hooks)[name] || (_a[name] = []);
    if (hooks.length >= this.app.options.maxListeners) {
      this.logger("app").warn('max listener count (%d) for event "%s" exceeded, which may be caused by a memory leak', this.app.options.maxListeners, name);
    }
    hooks[method]([this, listener]);
    const dispose = /* @__PURE__ */ __name(() => {
      (0, import_utils2.remove)(this.state.disposables, dispose);
      return this.off(name, listener);
    }, "dispose");
    this.state.disposables.push(dispose);
    return dispose;
  }
  before(name, listener, append = false) {
    const seg = name.split("/");
    seg[seg.length - 1] = "before-" + seg[seg.length - 1];
    return this.on(seg.join("/"), listener, !append);
  }
  once(name, listener, prepend = false) {
    const dispose = this.on(name, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, prepend);
    return dispose;
  }
  off(name, listener) {
    const index = (this.app._hooks[name] || []).findIndex(([context, callback]) => context === this && callback === listener);
    if (index >= 0) {
      this.app._hooks[name].splice(index, 1);
      return true;
    }
  }
  middleware(middleware, prepend = false) {
    return this.on(_Context.middleware, middleware, prepend);
  }
  createTimerDispose(timer) {
    const dispose = /* @__PURE__ */ __name(() => {
      clearTimeout(timer);
      if (!this.state)
        return;
      return (0, import_utils2.remove)(this.state.disposables, dispose);
    }, "dispose");
    this.state.disposables.push(dispose);
    return dispose;
  }
  setTimeout(callback, ms, ...args) {
    const dispose = this.createTimerDispose(setTimeout(() => {
      dispose();
      callback();
    }, ms, ...args));
    return dispose;
  }
  setInterval(callback, ms, ...args) {
    return this.createTimerDispose(setInterval(callback, ms, ...args));
  }
  getCommand(name) {
    return this.app._commands.get(name);
  }
  command(def, ...args) {
    const desc = typeof args[0] === "string" ? args.shift() : "";
    const config = args[0];
    const path = def.split(" ", 1)[0].toLowerCase();
    const decl = def.slice(path.length);
    const segments = path.split(/(?=[./])/g);
    let parent, root;
    const list = [];
    segments.forEach((segment3, index) => {
      const code = segment3.charCodeAt(0);
      const name = code === 46 ? parent.name + segment3 : code === 47 ? segment3.slice(1) : segment3;
      let command2 = this.getCommand(name);
      if (command2) {
        if (parent) {
          if (command2 === parent) {
            throw new Error(`cannot set a command (${command2.name}) as its own subcommand`);
          }
          if (command2.parent) {
            if (command2.parent !== parent) {
              throw new Error(`cannot create subcommand ${path}: ${command2.parent.name}/${command2.name} already exists`);
            }
          } else {
            command2.parent = parent;
            parent.children.push(command2);
          }
        }
        return parent = command2;
      }
      command2 = new Command(name, decl, this);
      list.push(command2);
      if (!root)
        root = command2;
      if (parent) {
        command2.parent = parent;
        command2.config.authority = parent.config.authority;
        parent.children.push(command2);
      }
      parent = command2;
    });
    if (desc)
      this.i18n.define("", `commands.${parent.name}.description`, desc);
    Object.assign(parent.config, config);
    list.forEach((command2) => this.emit("command-added", command2));
    if (!(config == null ? void 0 : config.patch)) {
      if (root)
        this.state.disposables.unshift(() => root.dispose());
      return parent;
    }
    if (root)
      root.dispose();
    const command = Object.create(parent);
    command._disposables = this.state.disposables;
    return command;
  }
  getSelfIds(type, assignees) {
    var _a;
    if (type) {
      assignees || (assignees = this.bots.filter((bot) => bot.platform === type).map((bot) => bot.selfId));
      return { [type]: assignees };
    }
    const platforms = {};
    for (const bot of this.bots) {
      (platforms[_a = bot.platform] || (platforms[_a] = [])).push(bot.selfId);
    }
    return platforms;
  }
  async broadcast(...args) {
    var _a;
    let channels;
    if (Array.isArray(args[0]))
      channels = args.shift();
    const [content, forced] = args;
    if (!content)
      return [];
    const data = await this.database.getAssignedChannels(["id", "assignee", "flag", "platform", "guildId"]);
    const assignMap = {};
    for (const { id, assignee, flag, platform, guildId } of data) {
      if (channels && !channels.includes(`${platform}:${id}`))
        continue;
      if (!forced && flag & Channel.Flag.silent)
        continue;
      ((_a = assignMap[platform] || (assignMap[platform] = {}))[assignee] || (_a[assignee] = [])).push([id, guildId]);
    }
    return (await Promise.all(Object.entries(assignMap).flatMap(([platform, map]) => {
      return this.bots.map((bot) => {
        if (bot.platform !== platform)
          return Promise.resolve([]);
        return bot.broadcast(map[bot.selfId] || [], content);
      });
    }))).flat(1);
  }
};
var Context = _Context;
__name(Context, "Context");
Context.middleware = Symbol("middleware");
Context.current = Symbol("source");
(function(Context4) {
  Context4.Services = [];
  function service(key) {
    if (Object.prototype.hasOwnProperty.call(Context4.prototype, key))
      return;
    Context4.Services.push(key);
    const privateKey = Symbol(key);
    Object.defineProperty(Context4.prototype, key, {
      get() {
        const value = this.app[privateKey];
        if (!value)
          return;
        (0, import_utils2.defineProperty)(value, Context4.current, this);
        return value;
      },
      set(value) {
        const oldValue = this.app[privateKey];
        if (oldValue === value)
          return;
        this.app[privateKey] = value;
        this.emit("service", key);
        const action = value ? oldValue ? "changed" : "enabled" : "disabled";
        this.logger("service").debug(key, action);
      }
    });
  }
  Context4.service = service;
  __name(service, "service");
  service("bots");
  service("database");
  service("i18n");
  service("model");
  Context4.deprecatedEvents = {
    "connect": "ready",
    "disconnect": "dispose",
    "before-command": "command/before-execute"
  };
})(Context || (Context = {}));

// packages/core/src/command.ts
var logger = new import_utils3.Logger("command");
var _Command = class extends Argv.CommandBase {
  constructor(name, decl, context) {
    super(name, decl, context);
    this.children = [];
    this.parent = null;
    this._aliases = [];
    this._examples = [];
    this._userFields = [["locale"]];
    this._channelFields = [["locale"]];
    this._actions = [];
    this._checkers = [async (argv) => {
      return this.app.serial(argv.session, "command/before-execute", argv);
    }];
    this.config = __spreadValues({}, _Command.defaultConfig);
    this._registerAlias(name);
    context.app._commandList.push(this);
  }
  static userFields(fields) {
    this._userFields.push(fields);
    return this;
  }
  static channelFields(fields) {
    this._channelFields.push(fields);
    return this;
  }
  get app() {
    return this.context.app;
  }
  get displayName() {
    return this._aliases[0];
  }
  set displayName(name) {
    this._registerAlias(name, true);
  }
  _registerAlias(name, prepend = false) {
    var _a;
    name = name.toLowerCase();
    const done = this._aliases.includes(name);
    if (done) {
      if (prepend) {
        (0, import_utils3.remove)(this._aliases, name);
        this._aliases.unshift(name);
      }
      return;
    } else if (prepend) {
      this._aliases.unshift(name);
    } else {
      this._aliases.push(name);
    }
    const previous = this.app.getCommand(name);
    if (!previous) {
      this.app._commands.set(name, this);
    } else if (previous !== this) {
      throw new Error(`duplicate command names: "${name}"`);
    }
    (_a = this._disposables) == null ? void 0 : _a.push(() => {
      (0, import_utils3.remove)(this._aliases, name);
      this.app._commands.delete(name);
    });
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Command <${this.name}>`;
  }
  userFields(fields) {
    this._userFields.push(fields);
    return this;
  }
  channelFields(fields) {
    this._channelFields.push(fields);
    return this;
  }
  alias(...names) {
    if (this._disposed)
      return this;
    for (const name of names) {
      this._registerAlias(name);
    }
    return this;
  }
  shortcut(name, config = {}) {
    var _a;
    if (this._disposed)
      return this;
    config.name = name;
    config.command = this;
    this.app._shortcuts.push(config);
    (_a = this._disposables) == null ? void 0 : _a.push(() => (0, import_utils3.remove)(this.app._shortcuts, config));
    return this;
  }
  subcommand(def, ...args) {
    def = this.name + (def.charCodeAt(0) === 46 ? "" : "/") + def;
    const desc = typeof args[0] === "string" ? args.shift() : "";
    const config = args[0] || {};
    if (this._disposed)
      config.patch = true;
    return this.context.command(def, desc, config);
  }
  usage(text) {
    this._usage = text;
    return this;
  }
  example(example) {
    this._examples.push(example);
    return this;
  }
  option(name, desc, config = {}) {
    var _a;
    this._createOption(name, desc, config);
    (_a = this._disposables) == null ? void 0 : _a.push(() => this.removeOption(name));
    return this;
  }
  match(session) {
    const { authority = Infinity } = session.user || {};
    return this.context.match(session) && this.config.authority <= authority;
  }
  getConfig(key, session) {
    const value = this.config[key];
    return typeof value === "function" ? value(session) : value;
  }
  check(callback, append = false) {
    return this.before(callback, append);
  }
  before(callback, append = false) {
    var _a;
    if (append) {
      this._checkers.push(callback);
    } else {
      this._checkers.unshift(callback);
    }
    (_a = this._disposables) == null ? void 0 : _a.push(() => (0, import_utils3.remove)(this._checkers, callback));
    return this;
  }
  action(callback, prepend = false) {
    var _a;
    if (prepend) {
      this._actions.unshift(callback);
    } else {
      this._actions.push(callback);
    }
    (_a = this._disposables) == null ? void 0 : _a.push(() => (0, import_utils3.remove)(this._actions, callback));
    return this;
  }
  use(callback, ...args) {
    return callback(this, ...args);
  }
  async execute(argv, fallback = Next.compose) {
    var _a, _b, _c;
    (_a = argv.command) != null ? _a : argv.command = this;
    (_b = argv.args) != null ? _b : argv.args = [];
    (_c = argv.options) != null ? _c : argv.options = {};
    const { args, options, error } = argv;
    if (error)
      return error;
    if (logger.level >= 3)
      logger.debug(argv.source || (argv.source = this.stringify(args, options)));
    for (const validator of this._checkers) {
      const result = await validator.call(this, argv, ...args);
      if (typeof result === "string")
        return result;
    }
    if (!this._actions.length)
      return "";
    let index = 0;
    const queue = this._actions.map((action) => async () => {
      return await action.call(this, argv, ...args);
    });
    queue.push(fallback);
    const length = queue.length;
    argv.next = async (callback) => {
      var _a2;
      if (callback !== void 0) {
        queue.push((next) => Next.compose(callback, next));
        if (queue.length > Next.MAX_DEPTH) {
          throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`);
        }
      }
      return (_a2 = queue[index++]) == null ? void 0 : _a2.call(queue, argv.next);
    };
    try {
      const result = await argv.next();
      if (typeof result === "string")
        return result;
    } catch (error2) {
      if (index === length)
        throw error2;
      const stack = (0, import_utils3.coerce)(error2);
      logger.warn(`${argv.source || (argv.source = this.stringify(args, options))}
${stack}`);
      this.app.emit(argv.session, "command-error", argv, error2);
    }
    return "";
  }
  dispose() {
    this._disposed = true;
    this.app.emit("command-removed", this);
    for (const cmd of this.children.slice()) {
      cmd.dispose();
    }
    this.app._shortcuts = this.app._shortcuts.filter((s) => s.command !== this);
    this._aliases.forEach((name) => this.app._commands.delete(name));
    (0, import_utils3.remove)(this.app._commandList, this);
    if (this.parent) {
      (0, import_utils3.remove)(this.parent.children, this);
    }
  }
};
var Command = _Command;
__name(Command, "Command");
Command.defaultConfig = {
  authority: 1,
  showWarning: true
};
Command.defaultOptionConfig = {
  authority: 0
};
Command._userFields = [];
Command._channelFields = [];
(function(Command2) {
  Command2.Config = import_utils3.Schema.object({
    authority: import_utils3.Schema.natural().default(1),
    hidden: import_utils3.Schema.boolean().default(false),
    checkArgCount: import_utils3.Schema.boolean().default(false),
    checkUnknown: import_utils3.Schema.boolean().default(false)
  });
})(Command || (Command = {}));

// packages/core/src/session.ts
var import_utils4 = __toModule(require("@koishijs/utils"));
var logger2 = new import_utils4.Logger("session");
var Session = class {
  constructor(bot, session) {
    Object.assign(this, session);
    this.platform = bot.platform;
    (0, import_utils4.defineProperty)(this, "app", bot.app);
    (0, import_utils4.defineProperty)(this, "bot", bot);
    (0, import_utils4.defineProperty)(this, "user", null);
    (0, import_utils4.defineProperty)(this, "channel", null);
    (0, import_utils4.defineProperty)(this, "id", import_utils4.Random.id());
    (0, import_utils4.defineProperty)(this, "_queued", Promise.resolve());
    (0, import_utils4.defineProperty)(this, "_hooks", []);
  }
  get uid() {
    return `${this.platform}:${this.userId}`;
  }
  get gid() {
    return `${this.platform}:${this.guildId}`;
  }
  get cid() {
    return `${this.platform}:${this.channelId}`;
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this).filter(([key]) => {
      return !key.startsWith("_") && !key.startsWith("$");
    }));
  }
  async _preprocess() {
    let node;
    let content = this.content.trim();
    if (node = import_utils4.segment.from(content, { type: "quote", caret: true })) {
      content = content.slice(node.capture[0].length).trimStart();
      this.quote = await this.bot.getMessage(node.data.channelId || this.channelId, node.data.id).catch((error) => {
        logger2.warn(error);
        return void 0;
      });
    }
    return content;
  }
  async preprocess() {
    return this._promise || (this._promise = this._preprocess());
  }
  get username() {
    const defaultName = this.user && this.user["name"] ? this.user["name"] : this.author ? this.author.nickname || this.author.username : this.userId;
    return this.app.chain("appellation", defaultName, this);
  }
  async send(content) {
    if (!content)
      return;
    return this.bot.sendMessage(this.channelId, content, this.guildId).catch((error) => {
      logger2.warn(error);
      return [];
    });
  }
  cancelQueued(delay = this.app.options.delay.cancel) {
    this._hooks.forEach(Reflect.apply);
    this._delay = delay;
  }
  async sendQueued(content, delay) {
    if (!content)
      return;
    if (typeof delay === "undefined") {
      const { message, character } = this.app.options.delay;
      delay = Math.max(message, character * content.length);
    }
    return this._queued = this._queued.then(() => new Promise((resolve) => {
      const hook = /* @__PURE__ */ __name(() => {
        resolve();
        clearTimeout(timer);
        (0, import_utils4.remove)(this._hooks, hook);
      }, "hook");
      this._hooks.push(hook);
      const timer = setTimeout(async () => {
        await this.send(content);
        this._delay = delay;
        hook();
      }, this._delay || 0);
    }));
  }
  resolveValue(source) {
    return typeof source === "function" ? Reflect.apply(source, null, [this]) : source;
  }
  async getChannel(id = this.channelId, fields = []) {
    const { app, platform, guildId } = this;
    if (!fields.length)
      return { platform, id, guildId };
    const channel = await app.database.getChannel(platform, id, fields);
    if (channel)
      return channel;
    const assignee = await this.resolveValue(app.options.autoAssign) ? this.selfId : "";
    if (assignee) {
      return app.database.createChannel(platform, id, { assignee, guildId });
    } else {
      const channel2 = app.model.create("channel");
      Object.assign(channel2, { platform, id, guildId });
      return channel2;
    }
  }
  async _observeChannelLike(channelId, fields = []) {
    const fieldSet = new Set(fields);
    const { platform } = this;
    const key = `${platform}:${channelId}`;
    let cache = this.app._channelCache.get(this.id, key);
    if (cache) {
      for (const key2 in cache) {
        fieldSet.delete(key2);
      }
      if (!fieldSet.size)
        return cache;
    }
    const data = await this.getChannel(channelId, [...fieldSet]);
    cache = this.app._channelCache.get(this.id, key);
    if (cache) {
      cache.$merge(data);
    } else {
      cache = (0, import_utils4.observe)(data, (diff) => this.app.database.setChannel(platform, channelId, diff), `channel ${key}`);
      this.app._channelCache.set(this.id, key, cache);
    }
    return cache;
  }
  async observeChannel(fields = []) {
    const tasks = [this._observeChannelLike(this.channelId, fields)];
    if (this.channelId !== this.guildId) {
      tasks.push(this._observeChannelLike(this.guildId, fields));
    }
    const [channel, guild = channel] = await Promise.all(tasks);
    this.guild = guild;
    this.channel = channel;
    return channel;
  }
  async getUser(id = this.userId, fields = []) {
    const { app, platform } = this;
    if (!fields.length)
      return { [platform]: id };
    const user = await app.database.getUser(platform, id, fields);
    if (user)
      return user;
    const authority = await this.resolveValue(app.options.autoAuthorize);
    if (authority) {
      return app.database.createUser(platform, id, { authority });
    } else {
      const user2 = app.model.create("user");
      Object.assign(user2, { [platform]: id, authority });
      return user2;
    }
  }
  async observeUser(fields = []) {
    var _a;
    const fieldSet = new Set(fields);
    const { userId, platform } = this;
    let cache = this.app._userCache.get(this.id, this.uid);
    if (cache) {
      for (const key in cache) {
        fieldSet.delete(key);
      }
      if (!fieldSet.size)
        return this.user = cache;
    }
    if ((_a = this.author) == null ? void 0 : _a.anonymous) {
      const fallback = this.app.model.create("user");
      fallback[platform] = userId;
      fallback.authority = await this.resolveValue(this.app.options.autoAuthorize);
      const user = (0, import_utils4.observe)(fallback, () => Promise.resolve());
      return this.user = user;
    }
    const data = await this.getUser(userId, [...fieldSet]);
    cache = this.app._userCache.get(this.id, this.uid);
    if (cache) {
      cache.$merge(data);
    } else {
      cache = (0, import_utils4.observe)(data, (diff) => this.app.database.setUser(this.platform, userId, diff), `user ${this.uid}`);
      this.app._userCache.set(this.id, this.uid, cache);
    }
    return this.user = cache;
  }
  async withScope(scope, callback) {
    const oldScope = this.scope;
    try {
      this.scope = scope;
      return await callback();
    } finally {
      this.scope = oldScope;
    }
  }
  text(path, params = {}) {
    var _a, _b, _c;
    const locales = [this.app.options.locale];
    locales.unshift((_a = this.user) == null ? void 0 : _a["locale"]);
    if (this.subtype === "group") {
      locales.unshift((_b = this.guild) == null ? void 0 : _b["locale"]);
      locales.unshift((_c = this.channel) == null ? void 0 : _c["locale"]);
    }
    const paths = (0, import_utils4.makeArray)(path).map((path2) => {
      if (!path2.startsWith("."))
        return path2;
      if (!this.scope) {
        this.app.logger("i18n").warn(new Error("missing scope"));
        return "";
      }
      return this.scope + path2;
    });
    return this.app.i18n.text(locales, paths, params);
  }
  collect(key, argv, fields = new Set()) {
    const collect = /* @__PURE__ */ __name((argv2) => {
      argv2.session = this;
      if (argv2.tokens) {
        for (const { inters } of argv2.tokens) {
          inters.forEach(collect);
        }
      }
      if (!this.resolve(argv2))
        return;
      this.app.emit(argv2.session, `command/before-attach-${key}`, argv2, fields);
      collectFields(argv2, Command[`_${key}Fields`], fields);
      collectFields(argv2, argv2.command[`_${key}Fields`], fields);
    }, "collect");
    collect(argv);
    return fields;
  }
  inferCommand(argv) {
    if (argv.command)
      return argv.command;
    if (argv.name)
      return argv.command = this.app._commands.resolve(argv.name);
    const { parsed, subtype } = this;
    if (argv.root && subtype !== "private" && parsed.prefix === null && !parsed.appel)
      return;
    if (!argv.tokens.length)
      return;
    const cmd = this.app._commands.resolve(argv.tokens[0].content);
    if (cmd) {
      argv.tokens.shift();
      return argv.command = cmd;
    }
  }
  resolve(argv) {
    var _a;
    if (!this.inferCommand(argv))
      return;
    if ((_a = argv.tokens) == null ? void 0 : _a.every((token) => !token.inters.length)) {
      const { options, args, error } = argv.command.parse(argv);
      argv.options = __spreadValues(__spreadValues({}, argv.options), options);
      argv.args = [...argv.args || [], ...args];
      argv.error = error;
    }
    return argv.command;
  }
  async execute(argv, next) {
    if (typeof argv === "string")
      argv = Argv.parse(argv);
    argv.session = this;
    if (argv.tokens) {
      for (const arg of argv.tokens) {
        const { inters } = arg;
        const output = [];
        for (let i = 0; i < inters.length; ++i) {
          output.push(await this.execute(inters[i], true));
        }
        for (let i = inters.length - 1; i >= 0; --i) {
          const { pos } = inters[i];
          arg.content = arg.content.slice(0, pos) + output[i] + arg.content.slice(pos);
        }
        arg.inters = [];
      }
      if (!this.resolve(argv))
        return "";
    } else {
      argv.command || (argv.command = this.app.getCommand(argv.name));
      if (!argv.command) {
        logger2.warn(new Error(`cannot find command ${argv.name}`));
        return "";
      }
    }
    const { command } = argv;
    if (!command.context.match(this))
      return "";
    if (this.app.database) {
      if (this.subtype === "group") {
        await this.observeChannel(this.collect("channel", argv));
      }
      await this.observeUser(this.collect("user", argv));
    }
    let shouldEmit = true;
    if (next === true) {
      shouldEmit = false;
      next = void 0;
    }
    return this.withScope(`commands.${command.name}.messages`, async () => {
      const result = await command.execute(argv, next);
      if (!shouldEmit)
        return result;
      await this.send(result);
      return "";
    });
  }
  middleware(middleware) {
    const identifier = getSessionId(this);
    return this.app.middleware(async (session, next) => {
      if (identifier && getSessionId(session) !== identifier)
        return next();
      return middleware(session, next);
    }, true);
  }
  prompt(timeout = this.app.options.delay.prompt) {
    return new Promise((resolve) => {
      const dispose = this.middleware((session) => {
        clearTimeout(timer);
        dispose();
        resolve(session.content);
      });
      const timer = setTimeout(() => {
        dispose();
        resolve("");
      }, timeout);
    });
  }
};
__name(Session, "Session");
function getSessionId(session) {
  return "" + session.userId + session.channelId;
}
__name(getSessionId, "getSessionId");
function collectFields(argv, collectors, fields) {
  for (const collector of collectors) {
    if (typeof collector === "function") {
      collector(argv, fields);
      continue;
    }
    for (const field of collector) {
      fields.add(field);
    }
  }
  return fields;
}
__name(collectFields, "collectFields");

// packages/core/src/bot.ts
var logger3 = new import_utils5.Logger("bot");
var Bot = class {
  constructor(adapter, config) {
    this.adapter = adapter;
    this.config = config;
    this.id = import_utils5.Random.id();
    this.app = adapter.ctx.app;
    this.platform = config.platform || adapter.platform;
    this.logger = new import_utils5.Logger(adapter.platform);
    this._status = "offline";
    this.extendModel();
    adapter.ctx.on("ready", () => this.start());
    adapter.ctx.on("dispose", () => this.stop());
  }
  extendModel() {
    if (this.platform in this.app.model.config.user.fields)
      return;
    this.app.model.extend("user", {
      [this.platform]: { type: "string", length: 63 }
    }, {
      unique: [this.platform]
    });
  }
  get status() {
    return this._status;
  }
  set status(value) {
    this._status = value;
    if (this.app.bots.includes(this)) {
      this.app.emit("bot-status-updated", this);
    }
  }
  resolve() {
    this.status = "online";
    logger3.success("logged in to %s as %c (%s)", this.platform, this.username, this.selfId);
  }
  reject(error) {
    this.error = error;
    this.status = "offline";
    logger3.error(error);
  }
  async start() {
    if (this.config.disabled)
      return;
    if (["connect", "reconnect", "online"].includes(this.status))
      return;
    this.status = "connect";
    try {
      await this.app.parallel("bot-connect", this);
      await this.adapter.connect(this);
    } catch (error) {
      this.reject(error);
    }
  }
  async stop() {
    if (["disconnect", "offline"].includes(this.status))
      return;
    this.status = "disconnect";
    try {
      await this.app.parallel("bot-disconnect", this);
      await this.adapter.disconnect(this);
    } catch (error) {
      this.logger.warn(error);
    }
    this.status = "offline";
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  createSession(session) {
    return new Session(this, __spreadProps(__spreadValues({}, session), {
      type: "send",
      selfId: this.selfId,
      platform: this.platform,
      timestamp: Date.now(),
      author: {
        userId: this.selfId,
        username: this.username,
        avatar: this.avatar,
        discriminator: this.discriminator,
        isBot: true
      }
    }));
  }
  async session(data) {
    const session = this.createSession(data);
    if (await this.app.serial(session, "before-send", session))
      return;
    return session;
  }
  async getGuildMemberMap(guildId) {
    const list = await this.getGuildMemberList(guildId);
    return Object.fromEntries(list.map((info) => [info.userId, info.nickname || info.username]));
  }
  async broadcast(channels, content, delay = this.app.options.delay.broadcast) {
    const messageIds = [];
    for (let index = 0; index < channels.length; index++) {
      if (index && delay)
        await (0, import_utils5.sleep)(delay);
      try {
        const [channelId, guildId] = (0, import_utils5.makeArray)(channels[index]);
        messageIds.push(...await this.sendMessage(channelId, content, guildId));
      } catch (error) {
        this.app.logger("bot").warn(error);
      }
    }
    return messageIds;
  }
};
__name(Bot, "Bot");
(function(Bot2) {
  Bot2.library = {};
})(Bot || (Bot = {}));

// packages/core/src/adapter.ts
var Adapter = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.bots = [];
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  connect(bot) {
  }
  disconnect(bot) {
  }
  dispatch(session) {
    if (!this.ctx.app.isActive)
      return;
    const events = [session.type];
    if (session.subtype) {
      events.unshift(events[0] + "/" + session.subtype);
      if (session.subsubtype) {
        events.unshift(events[0] + "/" + session.subsubtype);
      }
    }
    for (const event of events) {
      this.ctx.emit(session, (0, import_utils6.paramCase)(event), session);
    }
  }
};
__name(Adapter, "Adapter");
var logger4 = new import_utils6.Logger("app");
(function(Adapter2) {
  Adapter2.redirect = Symbol("koishi.adapter.redirect");
  Adapter2.library = {};
  Adapter2.configMap = {};
  function join(platform, protocol) {
    return protocol ? `${platform}.${protocol}` : platform;
  }
  Adapter2.join = join;
  __name(join, "join");
  function define(platform, constructor, ...args) {
    const name = platform + "-adapter";
    platform = platform.toLowerCase();
    Bot.library[platform] = constructor;
    let BotConfig;
    if (typeof args[0] === "function") {
      Adapter2.library[platform] = args[0];
      BotConfig = args[0].schema;
    } else {
      let flatten = function(schema) {
        if (schema.type === "union" || schema.type === "intersect") {
          schema.list.forEach(flatten);
        } else if (schema.type === "object") {
          for (const key in schema.dict) {
            FlatConfig.dict[key] = new import_utils6.Schema(schema.dict[key]);
            FlatConfig.dict[key].meta = __spreadProps(__spreadValues({}, schema.dict[key].meta), { required: false });
          }
        } else {
          throw new Error("cannot flatten bot schema");
        }
      };
      __name(flatten, "flatten");
      Adapter2.library[platform] = { [Adapter2.redirect]: args[1] };
      BotConfig = Adapter2.library[platform].schema = import_utils6.Schema.union([]).description("机器人要使用的协议。");
      const FlatConfig = import_utils6.Schema.object({ protocol: import_utils6.Schema.string() });
      for (const protocol in args[0]) {
        Adapter2.library[join(platform, protocol)] = args[0][protocol];
        flatten(args[0][protocol].schema);
        BotConfig.list.push(import_utils6.Schema.intersect([
          import_utils6.Schema.object({
            protocol: import_utils6.Schema.const(protocol).required()
          }),
          args[0][protocol].schema
        ]).description(protocol));
      }
      BotConfig.list.push(import_utils6.Schema.transform(FlatConfig, (value) => {
        if (value.protocol)
          throw new Error(`unknown protocol "${value.protocol}"`);
        value.protocol = args[1](value);
        logger4.debug("infer type as %s", value.protocol);
        return value;
      }));
    }
    const Config = import_utils6.Schema.intersect([
      constructor.schema,
      import_utils6.Schema.union([
        import_utils6.Schema.object({ bots: import_utils6.Schema.array(BotConfig).required().hidden() }),
        import_utils6.Schema.transform(BotConfig, (config) => ({ bots: [config] }))
      ])
    ]);
    function apply(ctx, config = {}) {
      ctx.emit("adapter", platform);
      Adapter2.configMap[platform] = config;
      for (const options of config.bots) {
        ctx.bots.create(platform, options, constructor);
      }
    }
    __name(apply, "apply");
    return { name, Config, apply };
  }
  Adapter2.define = define;
  __name(define, "define");
  class BotList extends Array {
    constructor(app) {
      super();
      this.app = app;
      this.adapters = {};
    }
    get(sid) {
      return this.find((bot) => bot.sid === sid);
    }
    create(platform, options, constructor) {
      constructor || (constructor = Bot.library[platform]);
      const adapter = this.resolve(platform, options);
      const bot = new constructor(adapter, options);
      adapter.bots.push(bot);
      this.push(bot);
      this.app.emit("bot-added", bot);
      return bot;
    }
    async remove(id) {
      const index = this.findIndex((bot2) => bot2.id === id);
      if (index < 0)
        return;
      const [bot] = this.splice(index, 1);
      (0, import_utils6.remove)(bot.adapter.bots, bot);
      bot.config.disabled = true;
      this.app.emit("bot-removed", bot);
      return bot.stop();
    }
    resolve(platform, config) {
      const type = join(platform, config.protocol);
      if (this.adapters[type])
        return this.adapters[type];
      const constructor = Adapter2.library[type];
      if (!constructor) {
        throw new Error(`unsupported protocol "${type}"`);
      }
      if (constructor[Adapter2.redirect]) {
        config.protocol = constructor[Adapter2.redirect](config);
        return this.resolve(platform, config);
      }
      const adapter = new constructor(this[Context.current], Adapter2.configMap[platform]);
      adapter.platform = platform;
      return this.adapters[type] = adapter;
    }
  }
  __name(BotList, "BotList");
  Adapter2.BotList = BotList;
})(Adapter || (Adapter = {}));

// packages/core/src/app.ts
var import_utils9 = __toModule(require("@koishijs/utils"));

// packages/core/src/i18n.ts
var import_utils7 = __toModule(require("@koishijs/utils"));
var logger5 = new import_utils7.Logger("i18n");
var I18n = class {
  constructor(ctx) {
    this.ctx = ctx;
    this._data = {};
    this._formatters = {};
    this._renderers = {};
    this.define("", { "": "" });
    this.define("zh", require_zh());
    this.define("en", require_en());
    const { day, hour, minute, second } = import_utils7.Time;
    this.formatter("time", (ms, _, locale) => {
      let result;
      if (ms >= day - hour / 2) {
        ms += hour / 2;
        result = Math.floor(ms / day) + " " + this.text([locale], ["general.day"], {});
        if (ms % day > hour) {
          result += ` ${Math.floor(ms % day / hour)} ` + this.text([locale], ["general.hour"], {});
        }
      } else if (ms >= hour - minute / 2) {
        ms += minute / 2;
        result = Math.floor(ms / hour) + " " + this.text([locale], ["general.hour"], {});
        if (ms % hour > minute) {
          result += ` ${Math.floor(ms % hour / minute)} ` + this.text([locale], ["general.minute"], {});
        }
      } else if (ms >= minute - second / 2) {
        ms += second / 2;
        result = Math.floor(ms / minute) + " " + this.text([locale], ["general.minute"], {});
        if (ms % minute > second) {
          result += ` ${Math.floor(ms % minute / second)} ` + this.text([locale], ["general.second"], {});
        }
      } else {
        result = Math.round(ms / second) + " " + this.text([locale], ["general.second"], {});
      }
      return result;
    });
    this.renderer("list", (data, params, locale) => {
      const list = params.map((value) => {
        return this.render(data.item, { value }, locale);
      });
      if (data.header)
        list.unshift(this.render(data.header, params, locale));
      if (data.footer)
        list.push(this.render(data.footer, params, locale));
      return list.join("\n");
    });
    this.renderer("inline-list", (data, params, locale) => {
      let output = "";
      params.forEach((value, index) => {
        var _a, _b;
        if (index) {
          if (index === params.length - 1 && data.conj !== void 0) {
            output += data.conj;
          } else {
            output += (_a = data.separator) != null ? _a : this.text([locale], ["general.comma"], {});
          }
        }
        output += (_b = this.render(data.item, { value }, locale)) != null ? _b : value;
      });
      const path = params.length in data ? params.length : "body";
      if (data[path] === void 0)
        return output;
      return this.render(data[path], [output, params.length], locale);
    });
  }
  static isTemplate(data) {
    return typeof data === "string" || (data == null ? void 0 : data.$);
  }
  set(locale, prefix, value) {
    var _a;
    if (I18n.isTemplate(value)) {
      const dict = this._data[locale];
      const path = prefix.slice(0, -1);
      if (!(0, import_utils7.isNullable)(dict[path]) && !locale.startsWith("$")) {
        logger5.warn("override", locale, path);
      }
      dict[path] = value;
      (_a = this[Context.current]) == null ? void 0 : _a.on("dispose", () => {
        delete dict[path];
      });
    } else if (value) {
      for (const key in value) {
        this.set(locale, prefix + key + ".", value[key]);
      }
    }
  }
  define(locale, ...args) {
    var _a;
    (_a = this._data)[locale] || (_a[locale] = {});
    if (typeof args[0] === "string") {
      this.set(locale, args[0] + ".", args[1]);
    } else {
      this.set(locale, "", args[0]);
    }
  }
  formatter(name, callback) {
    this._formatters[name] = callback;
  }
  renderer(name, callback) {
    this._renderers[name] = callback;
  }
  render(value, params, locale) {
    if (value === void 0)
      return;
    if (typeof value !== "string") {
      const render = this._renderers[value.$];
      if (!render)
        throw new Error(`Renderer "${value.$}" not found`);
      return render(value, params, locale);
    }
    return value.replace(/\{(.+?)\}/g, (_, inner) => {
      const [path, ...exprs] = inner.split("|");
      const segments = path.trim().split(".");
      let result = params;
      for (const segment3 of segments) {
        result = result[segment3];
        if ((0, import_utils7.isNullable)(result))
          return "";
      }
      for (const expr of exprs) {
        const cap = expr.trim().match(/(\w+)(?:\((.+)\))?/);
        const formatter = this._formatters[cap[1]];
        if (!formatter)
          throw new Error(`Formatter "${cap[1]}" not found`);
        const args = cap[2] ? cap[2].split(",").map((v) => v.trim()) : [];
        result = formatter(result, args, locale);
      }
      return result.toString();
    });
  }
  text(locales, paths, params) {
    var _a;
    const queue = new Set();
    for (const locale of locales) {
      if (!locale)
        continue;
      queue.add(locale);
    }
    for (const locale in this._data) {
      if (locale.startsWith("$"))
        continue;
      queue.add(locale);
    }
    for (const path of paths) {
      for (const locale of queue) {
        for (const key of ["$" + locale, locale]) {
          const value = (_a = this._data[key]) == null ? void 0 : _a[path];
          if (value === void 0)
            continue;
          return this.render(value, params, locale);
        }
      }
    }
    logger5.warn("missing", paths[0]);
    return paths[0];
  }
};
__name(I18n, "I18n");

// packages/core/src/internal/runtime.ts
var import_utils8 = __toModule(require("@koishijs/utils"));
function runtime(ctx) {
  ctx.before("parse", (content, session) => {
    const argv = Argv.parse(content);
    if (session.quote) {
      argv.tokens.push({
        content: session.quote.content,
        quoted: true,
        inters: [],
        terminator: ""
      });
    }
    return argv;
  });
  ctx.before("parse", (content, session) => {
    const { parsed, quote } = session;
    if (parsed.prefix || quote)
      return;
    for (const shortcut of ctx.app._shortcuts) {
      const { name, fuzzy, command, prefix, options = {}, args = [] } = shortcut;
      if (prefix && !parsed.appel || !command.context.match(session))
        continue;
      if (typeof name === "string") {
        if (!fuzzy && content !== name || !content.startsWith(name))
          continue;
        const message = content.slice(name.length);
        if (fuzzy && !parsed.appel && message.match(/^\S/))
          continue;
        const argv = command.parse(message.trim(), "", [...args], __spreadValues({}, options));
        argv.command = command;
        return argv;
      } else {
        let escape = function(source) {
          if (typeof source !== "string")
            return source;
          source = source.replace(/\$\$/g, "@@__PLACEHOLDER__@@");
          capture.forEach((segment3, index) => {
            if (!index || index > 9)
              return;
            source = source.replace(new RegExp(`\\$${index}`, "g"), (segment3 || "").replace(/\$/g, "@@__PLACEHOLDER__@@"));
          });
          return source.replace(/@@__PLACEHOLDER__@@/g, "$");
        };
        __name(escape, "escape");
        const capture = name.exec(content);
        if (!capture)
          continue;
        return {
          command,
          args: args.map(escape),
          options: (0, import_utils8.valueMap)(options, escape)
        };
      }
    }
  });
  ctx.before("attach", (session) => {
    (0, import_utils8.defineProperty)(session, "argv", ctx.bail("before-parse", session.parsed.content, session));
    session.argv.root = true;
    session.argv.session = session;
  });
  ctx.middleware((session, next) => {
    if (!session.resolve(session.argv))
      return next();
    return session.execute(session.argv, next);
  });
  function executeHelp(session, name) {
    if (!ctx.getCommand("help"))
      return;
    return session.execute({
      name: "help",
      args: [name]
    });
  }
  __name(executeHelp, "executeHelp");
  ctx.before("command/execute", (argv) => {
    const { args, command, options, session } = argv;
    if (options["help"] && command._options.help) {
      return executeHelp(session, command.name);
    }
    if (command["_actions"].length)
      return;
    const arg0 = args.shift() || "";
    const subcommand = ctx.getCommand(command.name + "." + arg0);
    if (subcommand) {
      return session.execute(__spreadProps(__spreadValues({}, argv), { command: subcommand }));
    } else {
      return executeHelp(session, command.name);
    }
  });
}
__name(runtime, "runtime");

// packages/core/src/internal/validate.ts
function validate(ctx) {
  ctx.on("command-added", (cmd) => {
    cmd.userFields(({ tokens, command, options = {} }, fields) => {
      if (!command)
        return;
      const { authority } = command.config;
      let shouldFetchAuthority = authority > 0;
      for (const { name, authority: authority2 } of Object.values(command._options)) {
        if (name in options) {
          if (authority2 > 0)
            shouldFetchAuthority = true;
        } else if (tokens) {
          if (authority2 > 0)
            shouldFetchAuthority = true;
        }
      }
      if (shouldFetchAuthority)
        fields.add("authority");
    });
  });
  ctx.before("command/execute", (argv) => {
    const { session, options, command } = argv;
    if (!session.user)
      return;
    function sendHint(message, ...param) {
      return command.config.showWarning ? session.text(message, param) : "";
    }
    __name(sendHint, "sendHint");
    if (session.user.authority) {
      const authority = command.getConfig("authority", session);
      if (authority > session.user.authority) {
        return sendHint("internal.low-authority");
      }
    }
    for (const option of Object.values(command._options)) {
      if (option.name in options) {
        if (option.authority > session.user.authority) {
          return sendHint("internal.low-authority");
        }
      }
    }
  });
  ctx.before("command/execute", (argv) => {
    const { args, options, command, session } = argv;
    function sendHint(message, ...param) {
      return command.config.showWarning ? session.text(message, param) : "";
    }
    __name(sendHint, "sendHint");
    if (command.config.checkArgCount) {
      const nextArg = command._arguments[args.length] || {};
      if (nextArg.required) {
        return sendHint("internal.insufficient-arguments");
      }
      const finalArg = command._arguments[command._arguments.length - 1] || {};
      if (args.length > command._arguments.length && finalArg.type !== "text" && !finalArg.variadic) {
        return sendHint("internal.redunant-arguments");
      }
    }
    if (command.config.checkUnknown) {
      const unknown = Object.keys(options).filter((key) => !command._options[key]);
      if (unknown.length) {
        return sendHint("internal.unknown-option", unknown.join(", "));
      }
    }
  });
}
__name(validate, "validate");

// packages/core/src/internal/suggest.ts
var import_fastest_levenshtein = __toModule(require("fastest-levenshtein"));

// packages/core/src/internal/help.ts
function enableHelp(cmd) {
  return cmd.option("help", "-h", {
    hidden: true,
    descPath: "commands.help.options.help"
  });
}
__name(enableHelp, "enableHelp");
function help(ctx, config = {}) {
  if (config.options !== false) {
    ctx.on("command-added", (cmd2) => cmd2.use(enableHelp));
  }
  const app = ctx.app;
  function findCommand(target) {
    const command = app._commands.resolve(target);
    if (command)
      return command;
    const shortcut = app._shortcuts.find(({ name }) => {
      return typeof name === "string" ? name === target : name.test(target);
    });
    if (shortcut)
      return shortcut.command;
  }
  __name(findCommand, "findCommand");
  const createCollector = /* @__PURE__ */ __name((key) => (argv, fields) => {
    const { args: [target], session } = argv;
    const command = findCommand(target);
    if (!command)
      return;
    session.collect(key, __spreadProps(__spreadValues({}, argv), { command, args: [], options: { help: true } }), fields);
  }, "createCollector");
  const cmd = ctx.command("help [command:string]", __spreadValues({ authority: 0 }, config)).userFields(["authority"]).userFields(createCollector("user")).channelFields(createCollector("channel")).option("authority", "-a").option("showHidden", "-H").action(async ({ session, options }, target) => {
    if (!target) {
      const commands = app._commandList.filter((cmd2) => cmd2.parent === null);
      const output = formatCommands(".global-prolog", session, commands, options);
      const epilog = session.text(".global-epilog");
      if (epilog)
        output.push(epilog);
      return output.filter(Boolean).join("\n");
    }
    const command = findCommand(target);
    if (!(command == null ? void 0 : command.context.match(session))) {
      return session.suggest({
        target,
        items: getCommandNames(session),
        prefix: session.text("suggest.help-prefix"),
        suffix: session.text("suggest.help-suffix"),
        async apply(suggestion) {
          return showHelp(ctx.getCommand(suggestion), this, options);
        }
      });
    }
    return showHelp(command, session, options);
  });
  if (config.shortcut !== false)
    cmd.shortcut("帮助", { fuzzy: true });
}
__name(help, "help");
function getCommandNames(session) {
  return session.app._commandList.filter((cmd) => cmd.match(session) && !cmd.config.hidden).flatMap((cmd) => cmd._aliases);
}
__name(getCommandNames, "getCommandNames");
function* getCommands(session, commands, showHidden = false) {
  for (const command of commands) {
    if (!showHidden && command.config.hidden)
      continue;
    if (command.match(session)) {
      yield command;
    } else {
      yield* getCommands(session, command.children, showHidden);
    }
  }
}
__name(getCommands, "getCommands");
function formatCommands(path, session, children, options) {
  const commands = Array.from(getCommands(session, children, options.showHidden)).sort((a, b) => a.displayName > b.displayName ? 1 : -1);
  if (!commands.length)
    return [];
  let hasSubcommand = false;
  const output = commands.map(({ name, displayName, config, children: children2 }) => {
    let output2 = "    " + displayName;
    if (options.authority) {
      output2 += ` (${config.authority}${children2.length ? (hasSubcommand = true, "*") : ""})`;
    }
    output2 += "  " + session.text([`commands.${name}.description`, ""]);
    return output2;
  });
  const hints = [];
  if (options.authority)
    hints.push(session.text(".hint-authority"));
  if (hasSubcommand)
    hints.push(session.text(".hint-subcommand"));
  const hintText = hints.length ? session.text("general.paren", [hints.join(session.text("general.comma"))]) : "";
  output.unshift(session.text(path, [hintText]));
  return output;
}
__name(formatCommands, "formatCommands");
function getOptionVisibility(option, session) {
  if (session.user && option.authority > session.user.authority)
    return false;
  return !session.resolveValue(option.hidden);
}
__name(getOptionVisibility, "getOptionVisibility");
function getOptions(command, session, config) {
  if (command.config.hideOptions && !config.showHidden)
    return [];
  const options = config.showHidden ? Object.values(command._options) : Object.values(command._options).filter((option) => getOptionVisibility(option, session));
  if (!options.length)
    return [];
  const output = config.authority && options.some((o) => o.authority) ? [session.text(".available-options-with-authority")] : [session.text(".available-options")];
  options.forEach((option) => {
    var _a;
    const authority = option.authority && config.authority ? `(${option.authority}) ` : "";
    let line = `${authority}${option.syntax}`;
    const description = session.text((_a = option.descPath) != null ? _a : [`commands.${command.name}.options.${option.name}`, ""]);
    if (description)
      line += "  " + description;
    line = command.app.chain("help/option", line, option, command, session);
    output.push("    " + line);
  });
  return output;
}
__name(getOptions, "getOptions");
async function showHelp(command, session, config) {
  const output = [command.displayName + command.declaration];
  const description = session.text([`commands.${command.name}.description`, ""]);
  if (description)
    output.push(description);
  if (session.app.database) {
    const argv = { command, args: [], options: { help: true } };
    const userFields = session.collect("user", argv);
    await session.observeUser(userFields);
    if (session.subtype === "group") {
      const channelFields = session.collect("channel", argv);
      await session.observeChannel(channelFields);
    }
  }
  if (command._aliases.length > 1) {
    output.push(session.text(".command-aliases", [Array.from(command._aliases.slice(1)).join("，")]));
  }
  session.app.emit(session, "help/command", output, command, session);
  if (session.user && command.config.authority > 1) {
    output.push(session.text(".command-authority", [command.config.authority]));
  }
  if (command._usage) {
    output.push(typeof command._usage === "string" ? command._usage : await command._usage(session));
  } else {
    const text = session.text([`commands.${command.name}.usage`, ""]);
    if (text)
      output.push(text);
  }
  output.push(...getOptions(command, session, config));
  if (command._examples.length) {
    output.push(session.text(".command-examples"), ...command._examples.map((example) => "    " + example));
  } else {
    const text = session.text([`commands.${command.name}.examples`, ""]);
    if (text)
      output.push(...text.split("\n").map((line) => "    " + line));
  }
  output.push(...formatCommands(".subcommand-prolog", session, command.children, config));
  return output.filter(Boolean).join("\n");
}
__name(showHelp, "showHelp");

// packages/core/src/internal/suggest.ts
Session.prototype.suggest = /* @__PURE__ */ __name(function suggest(options) {
  const {
    target,
    items,
    prefix = "",
    suffix,
    apply,
    next = Next.compose,
    minSimilarity = this.app.options.minSimilarity
  } = options;
  const sendNext = /* @__PURE__ */ __name(async (callback) => {
    const result = await next(callback);
    if (result)
      await this.send(result);
  }, "sendNext");
  let suggestions, minDistance = Infinity;
  for (const name of items) {
    const dist = (0, import_fastest_levenshtein.distance)(name, target);
    if (name.length <= 2 || dist > name.length * minSimilarity)
      continue;
    if (dist === minDistance) {
      suggestions.push(name);
    } else if (dist < minDistance) {
      suggestions = [name];
      minDistance = dist;
    }
  }
  if (!suggestions)
    return sendNext(async () => prefix);
  const scope = this.scope;
  return sendNext(async () => {
    const message = prefix + this.text("suggest.hint", [suggestions.map((text) => {
      return this.text("general.quote", [text]);
    }).join(this.text("general.or"))]);
    if (suggestions.length > 1)
      return message;
    const dispose = this.middleware((session, next2) => {
      dispose();
      const message2 = session.content.trim();
      if (message2 && message2 !== "." && message2 !== "。")
        return next2();
      return session.withScope(scope, () => {
        return apply.call(session, suggestions[0], next2);
      });
    });
    return message + suffix;
  });
}, "suggest");
function suggest2(ctx) {
  ctx.middleware((session, next) => {
    const { argv, quote, subtype, parsed: { content, prefix, appel } } = session;
    if (argv.command || subtype !== "private" && !prefix && !appel)
      return next();
    const target = content.split(/\s/, 1)[0].toLowerCase();
    if (!target)
      return next();
    return session.suggest({
      target,
      next,
      items: getCommandNames(session),
      prefix: session.text("suggest.command-prefix"),
      suffix: session.text("suggest.command-suffix"),
      async apply(suggestion, next2) {
        const newMessage = suggestion + content.slice(target.length) + (quote ? " " + quote.content : "");
        return this.execute(newMessage, next2);
      }
    });
  });
}
__name(suggest2, "suggest");

// packages/core/src/app.ts
function createLeadingRE(patterns, prefix = "", suffix = "") {
  return patterns.length ? new RegExp(`^${prefix}(${patterns.map(import_utils9.escapeRegExp).join("|")})${suffix}`) : /$^/;
}
__name(createLeadingRE, "createLeadingRE");
var logger6 = new import_utils9.Logger("app");
var App = class extends Context {
  constructor(options = {}) {
    super(() => true);
    this._commandList = [];
    this._commands = new Map();
    this._shortcuts = [];
    this._tasks = new TaskQueue();
    this._hooks = {};
    this._sessions = Object.create(null);
    this._userCache = new SharedCache();
    this._channelCache = new SharedCache();
    this.app = this;
    this.isActive = false;
    this.registry = new Plugin.Registry();
    this.options = new App.Config(options);
    this.registry.set(null, {
      id: "",
      parent: null,
      using: [],
      children: [],
      disposables: []
    });
    this.model = new ModelService(this);
    this.i18n = new I18n(this);
    this.bots = new Adapter.BotList(this);
    this._commands.resolve = (key) => {
      if (!key)
        return;
      const segments = key.split(".");
      let i = 1, name = segments[0], cmd;
      while ((cmd = this.getCommand(name)) && i < segments.length) {
        name = cmd.name + "." + segments[i++];
      }
      return cmd;
    };
    this.prepare();
    this.middleware(this._process.bind(this));
    this.on("message", this._handleMessage.bind(this));
    this.before("attach-user", (session, fields) => {
      session.collect("user", session.argv, fields);
    });
    this.before("attach-channel", (session, fields) => {
      session.collect("channel", session.argv, fields);
    });
    this.plugin(runtime);
    this.plugin(validate);
    this.plugin(suggest2);
    this.plugin(help, options.help);
  }
  prepare() {
    const { nickname } = this.options;
    this.options.nickname = (0, import_utils9.makeArray)(nickname);
    this._nameRE = createLeadingRE(this.options.nickname, "@?", "([,，]\\s*|\\s+)");
  }
  async start() {
    this.isActive = true;
    logger6.debug("started");
    for (const callback of this.getHooks("ready")) {
      this._tasks.queue(callback());
    }
    delete this._hooks.ready;
    await this._tasks.flush();
  }
  async stop() {
    this.isActive = false;
    logger6.debug("stopped");
    await Promise.all(this.state.disposables.map((dispose) => dispose()));
  }
  _resolvePrefixes(session) {
    const temp = session.resolveValue(this.options.prefix);
    return Array.isArray(temp) ? temp : [temp || ""];
  }
  async _process(session, next) {
    let capture;
    let atSelf = false, appel = false, prefix = null;
    const pattern = /^\[CQ:(\w+)((,\w+=[^,\]]*)*)\]/;
    let content = await session.preprocess();
    if (session.subtype !== "private" && (capture = content.match(pattern)) && capture[1] === "at" && capture[2].includes("id=" + session.selfId)) {
      atSelf = appel = true;
      content = content.slice(capture[0].length).trimStart();
    } else if (capture = content.match(this._nameRE)) {
      appel = true;
      content = content.slice(capture[0].length);
    }
    for (const _prefix of this._resolvePrefixes(session)) {
      if (!content.startsWith(_prefix))
        continue;
      prefix = _prefix;
      content = content.slice(_prefix.length);
    }
    (0, import_utils9.defineProperty)(session, "parsed", { content, appel, prefix });
    this.emit(session, "before-attach", session);
    if (this.database) {
      if (session.subtype === "group") {
        const channelFields = new Set(["flag", "assignee", "guildId", "locale"]);
        this.emit("before-attach-channel", session, channelFields);
        const channel = await session.observeChannel(channelFields);
        channel.guildId = session.guildId;
        if (await this.serial(session, "attach-channel", session))
          return;
        if (channel.flag & Channel.Flag.ignore)
          return;
        if (channel.assignee !== session.selfId && !atSelf)
          return;
      }
      const userFields = new Set(["flag", "authority", "locale"]);
      this.emit("before-attach-user", session, userFields);
      const user = await session.observeUser(userFields);
      if (await this.serial(session, "attach-user", session))
        return;
      if (user.flag & User.Flag.ignore)
        return;
    }
    this.emit(session, "attach", session);
    return next();
  }
  async _handleMessage(session) {
    var _a, _b, _c;
    this._sessions[session.id] = session;
    const queue = this._hooks[Context.middleware].filter(([context]) => context.match(session)).map(([, middleware]) => middleware.bind(null, session));
    let index = 0, midStack = "", lastCall = "";
    const { prettyErrors } = this.options;
    const next = /* @__PURE__ */ __name(async (callback) => {
      var _a2;
      if (prettyErrors) {
        lastCall = new Error().stack.split("\n", 3)[2];
        if (index) {
          const capture = lastCall.match(/\((.+)\)/);
          midStack = `
  - ${capture ? capture[1] : lastCall.slice(7)}${midStack}`;
        }
      }
      try {
        if (!this._sessions[session.id]) {
          throw new Error("isolated next function detected");
        }
        if (callback !== void 0) {
          queue.push((next2) => Next.compose(callback, next2));
          if (queue.length > Next.MAX_DEPTH) {
            throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`);
          }
        }
        return await ((_a2 = queue[index++]) == null ? void 0 : _a2.call(queue, next));
      } catch (error) {
        let stack = (0, import_utils9.coerce)(error);
        if (prettyErrors) {
          const index2 = stack.indexOf(lastCall);
          if (index2 >= 0) {
            stack = stack.slice(0, index2);
          } else {
            stack += "\n";
          }
          stack += `Middleware stack:${midStack}`;
        }
        this.logger("session").warn(`${session.content}
${stack}`);
      }
    }, "next");
    try {
      const result = await next();
      if (result)
        await session.send(result);
    } finally {
      delete this._sessions[session.id];
      this.emit(session, "middleware", session);
      this._userCache.delete(session.id);
      this._channelCache.delete(session.id);
      await ((_a = session.user) == null ? void 0 : _a.$update());
      await ((_b = session.channel) == null ? void 0 : _b.$update());
      await ((_c = session.guild) == null ? void 0 : _c.$update());
    }
  }
};
__name(App, "App");
(function(App2) {
  App2.Config = import_utils9.Schema.intersect([]);
  (0, import_utils9.defineProperty)(App2.Config, "Basic", import_utils9.Schema.object({
    locale: import_utils9.Schema.string().default("zh").description("默认使用的语言。"),
    prefix: import_utils9.Schema.union([
      import_utils9.Schema.array(String),
      import_utils9.Schema.transform(String, (prefix) => [prefix])
    ]).default([""]).description("指令前缀字符，可以是字符串或字符串数组。将用于指令前缀的匹配。"),
    nickname: import_utils9.Schema.union([
      import_utils9.Schema.array(String),
      import_utils9.Schema.transform(String, (nickname) => [nickname])
    ]).description("机器人的昵称，可以是字符串或字符串数组。将用于指令前缀的匹配。"),
    autoAssign: import_utils9.Schema.union([Boolean, Function]).default(true).description("当获取不到频道数据时，是否使用接受者作为代理者。"),
    autoAuthorize: import_utils9.Schema.union([import_utils9.Schema.natural(), Function]).default(1).description("当获取不到用户数据时默认使用的权限等级。"),
    minSimilarity: import_utils9.Schema.percent().default(0.4).description("用于模糊匹配的相似系数，应该是一个 0 到 1 之间的数值。数值越高，模糊匹配越严格。设置为 1 可以完全禁用模糊匹配。")
  }).description("基础设置"));
  (0, import_utils9.defineProperty)(App2.Config, "Features", import_utils9.Schema.object({
    delay: import_utils9.Schema.object({
      character: import_utils9.Schema.natural().role("ms").default(0).description("调用 `session.sendQueued()` 时消息间发送的最小延迟，按前一条消息的字数计算。"),
      message: import_utils9.Schema.natural().role("ms").default(0.1 * import_utils9.Time.second).description("调用 `session.sendQueued()` 时消息间发送的最小延迟，按固定值计算。"),
      cancel: import_utils9.Schema.natural().role("ms").default(0).description("调用 `session.cancelQueued()` 时默认的延迟。"),
      broadcast: import_utils9.Schema.natural().role("ms").default(0.5 * import_utils9.Time.second).description("调用 `bot.broadcast()` 时默认的延迟。"),
      prompt: import_utils9.Schema.natural().role("ms").default(import_utils9.Time.minute).description("调用 `session.prompt()` 时默认的等待时间。")
    })
  }).description("消息设置"));
  (0, import_utils9.defineProperty)(App2.Config, "Advanced", import_utils9.Schema.object({
    prettyErrors: import_utils9.Schema.boolean().default(true).description("启用报错优化模式。在此模式下 Koishi 会对程序抛出的异常进行整理，过滤掉框架内部的调用记录，输出更易读的提示信息。"),
    maxListeners: import_utils9.Schema.natural().default(64).description("每种监听器的最大数量。如果超过这个数量，Koishi 会认定为发生了内存泄漏，将产生一个警告。")
  }).description("高级设置"));
  App2.Config.list.push(App2.Config.Basic, App2.Config.Features, App2.Config.Advanced);
})(App || (App = {}));
function defineConfig(config) {
  return config;
}
__name(defineConfig, "defineConfig");
var _internal;
var TaskQueue = class {
  constructor() {
    __privateAdd(this, _internal, new Set());
  }
  queue(value) {
    const task = Promise.resolve(value).catch((err) => logger6.warn(err)).then(() => __privateGet(this, _internal).delete(task));
    __privateGet(this, _internal).add(task);
  }
  async flush() {
    while (__privateGet(this, _internal).size) {
      await Promise.all(Array.from(__privateGet(this, _internal)));
    }
  }
};
__name(TaskQueue, "TaskQueue");
_internal = new WeakMap();
var _keyMap;
var SharedCache = class {
  constructor() {
    __privateAdd(this, _keyMap, Object.create(null));
  }
  get(ref, key) {
    const entry = __privateGet(this, _keyMap)[key];
    if (!entry)
      return;
    entry.refs.add(ref);
    return entry.value;
  }
  set(ref, key, value) {
    var _a;
    const entry = (_a = __privateGet(this, _keyMap))[key] || (_a[key] = { value, key, refs: new Set() });
    entry.refs.add(ref);
  }
  delete(ref) {
    for (const key in __privateGet(this, _keyMap)) {
      const { refs } = __privateGet(this, _keyMap)[key];
      refs.delete(ref);
      if (!refs.size) {
        delete __privateGet(this, _keyMap)[key];
      }
    }
  }
};
__name(SharedCache, "SharedCache");
_keyMap = new WeakMap();

// packages/core/src/index.ts
var version = "4.5.1";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Adapter,
  App,
  Argv,
  Bot,
  Channel,
  Command,
  Context,
  Database,
  ModelService,
  Modules,
  Next,
  Plugin,
  Service,
  Session,
  SharedCache,
  User,
  defineConfig,
  enableHelp,
  getCommandNames,
  getSessionId,
  unwrapExports,
  version
});
//# sourceMappingURL=node.js.map
