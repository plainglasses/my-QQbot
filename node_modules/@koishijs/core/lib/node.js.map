{
  "version": 3,
  "sources": ["../src/index.ts", "../src/adapter.ts", "../src/bot.ts", "../src/command.ts", "../src/parser.ts", "../src/context.ts", "../src/database.ts", "../src/session.ts", "../src/app.ts", "../src/i18n.ts", "../src/internal/runtime.ts", "../src/internal/validate.ts", "../src/internal/suggest.ts", "../src/internal/help.ts"],
  "sourcesContent": ["export * from '@koishijs/utils'\nexport * from '@koishijs/orm'\nexport * from './adapter'\nexport * from './app'\nexport * from './bot'\nexport * from './command'\nexport * from './context'\nexport * from './database'\nexport * from './parser'\nexport * from './session'\nexport * from './internal'\n\ndeclare const KOISHI_VERSION: string\nexport const version = KOISHI_VERSION\n", "import { Awaitable, Dict, Logger, paramCase, remove, Schema } from '@koishijs/utils'\nimport { Session } from './session'\nimport { App } from './app'\nimport { Bot } from './bot'\nimport { Context, Plugin } from './context'\n\nexport abstract class Adapter<S extends Bot.BaseConfig = Bot.BaseConfig, T = {}> {\n  public bots: Bot<S>[] = []\n  public platform: string\n\n  protected abstract start(): Awaitable<void>\n  protected abstract stop(): Awaitable<void>\n\n  constructor(public ctx: Context, public config: T) {\n    ctx.on('ready', () => this.start())\n    ctx.on('dispose', () => this.stop())\n  }\n\n  connect(bot: Bot): Awaitable<void> {}\n  disconnect(bot: Bot): Awaitable<void> {}\n\n  dispatch(session: Session) {\n    if (!this.ctx.app.isActive) return\n    const events: string[] = [session.type]\n    if (session.subtype) {\n      events.unshift(events[0] + '/' + session.subtype)\n      if (session.subsubtype) {\n        events.unshift(events[0] + '/' + session.subsubtype)\n      }\n    }\n    for (const event of events) {\n      this.ctx.emit(session, paramCase<any>(event), session)\n    }\n  }\n}\n\nconst logger = new Logger('app')\n\nexport namespace Adapter {\n  export interface Constructor<T extends Bot.BaseConfig = Bot.BaseConfig, S = any> {\n    new (ctx: Context, options?: S): Adapter<T>\n    [redirect]?(bot: any): string\n    schema?: Schema\n  }\n\n  export const redirect = Symbol('koishi.adapter.redirect')\n  export const library: Dict<Constructor> = {}\n  export const configMap: Dict = {}\n\n  export type BotConfig<R> = R & { bots?: R[] }\n  export type PluginConfig<S = any, R = any> = S & BotConfig<R>\n\n  export function join(platform: string, protocol: string) {\n    return protocol ? `${platform}.${protocol}` : platform\n  }\n\n  type CreatePluginRestParams = [Constructor] | [Dict<Constructor>, ((bot: any) => string)?]\n\n  export function define<T extends Bot.BaseConfig, S>(\n    platform: string,\n    bot: Bot.Constructor<T>,\n    adapter: Constructor<T, S>,\n  ): Plugin.Object<PluginConfig<S, T>>\n\n  export function define<T extends Bot.BaseConfig, S, K extends string>(\n    platform: string,\n    bot: Bot.Constructor<T>,\n    adapters: Record<K, Constructor<T, S>>,\n    redirect?: (config: T) => K,\n  ): Plugin.Object<PluginConfig<S, T>>\n\n  export function define(platform: string, constructor: Bot.Constructor, ...args: CreatePluginRestParams) {\n    const name = platform + '-adapter'\n    platform = platform.toLowerCase()\n    Bot.library[platform] = constructor\n\n    let BotConfig: Schema\n    if (typeof args[0] === 'function') {\n      library[platform] = args[0]\n      BotConfig = args[0].schema\n    } else {\n      library[platform] = { [redirect]: args[1] } as Constructor\n      BotConfig = library[platform].schema = Schema.union([]).description('机器人要使用的协议。')\n      const FlatConfig = Schema.object({ protocol: Schema.string() })\n      function flatten(schema: Schema) {\n        if (schema.type === 'union' || schema.type === 'intersect') {\n          schema.list.forEach(flatten)\n        } else if (schema.type === 'object') {\n          for (const key in schema.dict) {\n            FlatConfig.dict[key] = new Schema(schema.dict[key])\n            FlatConfig.dict[key].meta = { ...schema.dict[key].meta, required: false }\n          }\n        } else {\n          throw new Error('cannot flatten bot schema')\n        }\n      }\n\n      for (const protocol in args[0]) {\n        library[join(platform, protocol)] = args[0][protocol]\n        flatten(args[0][protocol].schema)\n        BotConfig.list.push(Schema.intersect([\n          Schema.object({\n            protocol: Schema.const(protocol).required(),\n          }),\n          args[0][protocol].schema,\n        ]).description(protocol))\n      }\n      BotConfig.list.push(Schema.transform(FlatConfig, (value) => {\n        if (value.protocol) throw new Error(`unknown protocol \"${value.protocol}\"`)\n        value.protocol = args[1](value) as never\n        logger.debug('infer type as %s', value.protocol)\n        return value\n      }))\n    }\n\n    const Config = Schema.intersect([\n      constructor.schema,\n      Schema.union([\n        Schema.object({ bots: Schema.array(BotConfig).required().hidden() }),\n        Schema.transform(BotConfig, config => ({ bots: [config] })),\n      ]),\n    ])\n\n    function apply(ctx: Context, config: PluginConfig = {}) {\n      ctx.emit('adapter', platform)\n      configMap[platform] = config\n\n      for (const options of config.bots) {\n        ctx.bots.create(platform, options, constructor)\n      }\n    }\n\n    return { name, Config, apply }\n  }\n\n  export class BotList extends Array<Bot> {\n    adapters: Dict<Adapter> = {}\n\n    constructor(private app: App) {\n      super()\n    }\n\n    get(sid: string) {\n      return this.find(bot => bot.sid === sid)\n    }\n\n    create<T extends Bot>(platform: string, options: any, constructor?: new (adapter: Adapter, config: any) => T): T {\n      constructor ||= Bot.library[platform] as any\n      const adapter = this.resolve(platform, options)\n      const bot = new constructor(adapter, options)\n      adapter.bots.push(bot)\n      this.push(bot)\n      this.app.emit('bot-added', bot)\n      return bot\n    }\n\n    async remove(id: string) {\n      const index = this.findIndex(bot => bot.id === id)\n      if (index < 0) return\n      const [bot] = this.splice(index, 1)\n      remove(bot.adapter.bots, bot)\n      bot.config.disabled = true\n      this.app.emit('bot-removed', bot)\n      return bot.stop()\n    }\n\n    private resolve(platform: string, config: Bot.BaseConfig): Adapter {\n      const type = join(platform, config.protocol)\n      if (this.adapters[type]) return this.adapters[type]\n\n      const constructor = Adapter.library[type]\n      if (!constructor) {\n        throw new Error(`unsupported protocol \"${type}\"`)\n      }\n\n      if (constructor[redirect]) {\n        config.protocol = constructor[redirect](config)\n        return this.resolve(platform, config)\n      }\n\n      const adapter = new constructor(this[Context.current], configMap[platform])\n      adapter.platform = platform\n      return this.adapters[type] = adapter\n    }\n  }\n}\n", "import { Dict, Logger, makeArray, Random, Schema, sleep } from '@koishijs/utils'\nimport { Adapter } from './adapter'\nimport { App } from './app'\nimport { Session } from './session'\n\nconst logger = new Logger('bot')\n\nexport interface Bot extends Bot.BaseConfig, Bot.Methods, Bot.UserBase {}\n\nexport abstract class Bot<T extends Bot.BaseConfig = Bot.BaseConfig> {\n  public app: App\n  public platform: string\n  public hidden?: boolean\n  public internal?: any\n  public selfId?: string\n  public logger: Logger\n  public id = Random.id()\n\n  private _status: Bot.Status\n\n  error?: Error\n\n  constructor(public adapter: Adapter, public config: T) {\n    this.app = adapter.ctx.app\n    this.platform = config.platform || adapter.platform\n    this.logger = new Logger(adapter.platform)\n    this._status = 'offline'\n    this.extendModel()\n\n    adapter.ctx.on('ready', () => this.start())\n    adapter.ctx.on('dispose', () => this.stop())\n  }\n\n  private extendModel() {\n    if (this.platform in this.app.model.config.user.fields) return\n    this.app.model.extend('user', {\n      [this.platform]: { type: 'string', length: 63 },\n    }, {\n      unique: [this.platform as never],\n    })\n  }\n\n  get status() {\n    return this._status\n  }\n\n  set status(value) {\n    this._status = value\n    if (this.app.bots.includes(this)) {\n      this.app.emit('bot-status-updated', this)\n    }\n  }\n\n  resolve() {\n    this.status = 'online'\n    logger.success('logged in to %s as %c (%s)', this.platform, this.username, this.selfId)\n  }\n\n  reject(error: Error) {\n    this.error = error\n    this.status = 'offline'\n    logger.error(error)\n  }\n\n  async start() {\n    if (this.config.disabled) return\n    if (['connect', 'reconnect', 'online'].includes(this.status)) return\n    this.status = 'connect'\n    try {\n      await this.app.parallel('bot-connect', this)\n      await this.adapter.connect(this)\n    } catch (error) {\n      this.reject(error)\n    }\n  }\n\n  async stop() {\n    if (['disconnect', 'offline'].includes(this.status)) return\n    this.status = 'disconnect'\n    try {\n      await this.app.parallel('bot-disconnect', this)\n      await this.adapter.disconnect(this)\n    } catch (error) {\n      this.logger.warn(error)\n    }\n    this.status = 'offline'\n  }\n\n  get sid() {\n    return `${this.platform}:${this.selfId}`\n  }\n\n  /** @deprecated using `bot.session()` instead */\n  createSession(session: Partial<Session>) {\n    return new Session(this, {\n      ...session,\n      type: 'send',\n      selfId: this.selfId,\n      platform: this.platform,\n      timestamp: Date.now(),\n      author: {\n        userId: this.selfId,\n        username: this.username,\n        avatar: this.avatar,\n        discriminator: this.discriminator,\n        isBot: true,\n      },\n    })\n  }\n\n  async session(data: Partial<Session>) {\n    const session = this.createSession(data)\n    if (await this.app.serial(session, 'before-send', session)) return\n    return session\n  }\n\n  async getGuildMemberMap(guildId: string) {\n    const list = await this.getGuildMemberList(guildId)\n    return Object.fromEntries(list.map(info => [info.userId, info.nickname || info.username]))\n  }\n\n  async broadcast(channels: (string | [string, string])[], content: string, delay = this.app.options.delay.broadcast) {\n    const messageIds: string[] = []\n    for (let index = 0; index < channels.length; index++) {\n      if (index && delay) await sleep(delay)\n      try {\n        const [channelId, guildId] = makeArray(channels[index])\n        messageIds.push(...await this.sendMessage(channelId, content, guildId))\n      } catch (error) {\n        this.app.logger('bot').warn(error)\n      }\n    }\n    return messageIds\n  }\n}\n\nexport namespace Bot {\n  export const library: Dict<Bot.Constructor> = {}\n\n  export interface BaseConfig {\n    disabled?: boolean\n    protocol?: string\n    platform?: string\n  }\n\n  export interface Constructor<S extends Bot.BaseConfig = Bot.BaseConfig> {\n    new (adapter: Adapter, config: S): Bot<S>\n    schema?: Schema\n  }\n\n  export type Status = 'offline' | 'online' | 'connect' | 'disconnect' | 'reconnect'\n\n  export interface Methods {\n    // message\n    sendMessage(channelId: string, content: string, guildId?: string): Promise<string[]>\n    sendPrivateMessage(userId: string, content: string): Promise<string[]>\n    getMessage(channelId: string, messageId: string): Promise<Message>\n    editMessage(channelId: string, messageId: string, content: string): Promise<void>\n    deleteMessage(channelId: string, messageId: string): Promise<void>\n\n    // user\n    getSelf(): Promise<User>\n    getUser(userId: string): Promise<User>\n    getFriendList(): Promise<User[]>\n    deleteFriend(userId: string): Promise<void>\n\n    // guild\n    getGuild(guildId: string): Promise<Guild>\n    getGuildList(): Promise<Guild[]>\n\n    // guild member\n    getGuildMember(guildId: string, userId: string): Promise<GuildMember>\n    getGuildMemberList(guildId: string): Promise<GuildMember[]>\n\n    // channel\n    getChannel(channelId: string, guildId?: string): Promise<Channel>\n    getChannelList(guildId: string): Promise<Channel[]>\n\n    // request\n    handleFriendRequest(messageId: string, approve: boolean, comment?: string): Promise<void>\n    handleGuildRequest(messageId: string, approve: boolean, comment?: string): Promise<void>\n    handleGuildMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>\n  }\n\n  export interface Channel {\n    channelId: string\n    channelName?: string\n  }\n\n  export interface Guild {\n    guildId: string\n    guildName?: string\n  }\n\n  export interface UserBase {\n    username?: string\n    nickname?: string\n    avatar?: string\n    discriminator?: string\n    isBot?: boolean\n  }\n\n  export interface User extends UserBase {\n    userId: string\n  }\n\n  export interface GuildMember extends User {\n    roles?: string[]\n  }\n\n  export interface Author extends GuildMember {\n    anonymous?: string\n  }\n\n  export interface Role {\n    id: string\n  }\n\n  export interface MessageBase {\n    messageId?: string\n    channelId?: string\n    guildId?: string\n    userId?: string\n    content?: string\n    timestamp?: number\n    author?: Author\n    quote?: Message\n  }\n\n  export interface Message extends MessageBase {\n    subtype?: 'private' | 'group'\n  }\n}\n", "import { Awaitable, coerce, Dict, Logger, remove, Schema } from '@koishijs/utils'\nimport { Argv } from './parser'\nimport { Context, Disposable, Next } from './context'\nimport { Channel, User } from './database'\nimport { Computed, FieldCollector, Session } from './session'\nimport * as internal from './internal'\n\nconst logger = new Logger('command')\n\nexport type Extend<O extends {}, K extends string, T> = {\n  [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown)\n}\n\nexport namespace Command {\n  export interface Shortcut {\n    name?: string | RegExp\n    command?: Command\n    prefix?: boolean\n    fuzzy?: boolean\n    args?: string[]\n    options?: Dict\n  }\n\n  export type Action<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}>\n    = (argv: Argv<U, G, A, O>, ...args: A) => Awaitable<void | string>\n\n  export type Usage<U extends User.Field = never, G extends Channel.Field = never>\n    = string | ((session: Session<U, G>) => Awaitable<string>)\n}\n\nexport class Command<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> extends Argv.CommandBase {\n  config: Command.Config\n  children: Command[] = []\n  parent: Command = null\n\n  _aliases: string[] = []\n  _examples: string[] = []\n  _usage?: Command.Usage\n  _disposed?: boolean\n  _disposables?: Disposable[]\n\n  private _userFields: FieldCollector<'user'>[] = [['locale']]\n  private _channelFields: FieldCollector<'channel'>[] = [['locale']]\n  private _actions: Command.Action[] = []\n  private _checkers: Command.Action[] = [async (argv) => {\n    return this.app.serial(argv.session, 'command/before-execute', argv)\n  }]\n\n  public static enableHelp: typeof internal.enableHelp\n\n  static defaultConfig: Command.Config = {\n    authority: 1,\n    showWarning: true,\n  }\n\n  static defaultOptionConfig: Argv.OptionConfig = {\n    authority: 0,\n  }\n\n  private static _userFields: FieldCollector<'user'>[] = []\n  private static _channelFields: FieldCollector<'channel'>[] = []\n\n  /** @deprecated use `command-added` event instead */\n  static userFields(fields: FieldCollector<'user'>) {\n    this._userFields.push(fields)\n    return this\n  }\n\n  /** @deprecated use `command-added` event instead */\n  static channelFields(fields: FieldCollector<'channel'>) {\n    this._channelFields.push(fields)\n    return this\n  }\n\n  constructor(name: string, decl: string, context: Context) {\n    super(name, decl, context)\n    this.config = { ...Command.defaultConfig }\n    this._registerAlias(name)\n    context.app._commandList.push(this)\n  }\n\n  get app() {\n    return this.context.app\n  }\n\n  get displayName() {\n    return this._aliases[0]\n  }\n\n  set displayName(name) {\n    this._registerAlias(name, true)\n  }\n\n  private _registerAlias(name: string, prepend = false) {\n    name = name.toLowerCase()\n\n    // add to list\n    const done = this._aliases.includes(name)\n    if (done) {\n      if (prepend) {\n        remove(this._aliases, name)\n        this._aliases.unshift(name)\n      }\n      return\n    } else if (prepend) {\n      this._aliases.unshift(name)\n    } else {\n      this._aliases.push(name)\n    }\n\n    // register global\n    const previous = this.app.getCommand(name)\n    if (!previous) {\n      this.app._commands.set(name, this)\n    } else if (previous !== this) {\n      throw new Error(`duplicate command names: \"${name}\"`)\n    }\n\n    // add disposable\n    this._disposables?.push(() => {\n      remove(this._aliases, name)\n      this.app._commands.delete(name)\n    })\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `Command <${this.name}>`\n  }\n\n  userFields<T extends User.Field = never>(fields: FieldCollector<'user', T, A, O>): Command<U | T, G, A, O> {\n    this._userFields.push(fields)\n    return this as any\n  }\n\n  channelFields<T extends Channel.Field = never>(fields: FieldCollector<'channel', T, A, O>): Command<U, G | T, A, O> {\n    this._channelFields.push(fields)\n    return this as any\n  }\n\n  alias(...names: string[]) {\n    if (this._disposed) return this\n    for (const name of names) {\n      this._registerAlias(name)\n    }\n    return this\n  }\n\n  shortcut(name: string | RegExp, config: Command.Shortcut = {}) {\n    if (this._disposed) return this\n    config.name = name\n    config.command = this\n    this.app._shortcuts.push(config)\n    this._disposables?.push(() => remove(this.app._shortcuts, config))\n    return this\n  }\n\n  subcommand<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  subcommand(def: string, ...args: any[]) {\n    def = this.name + (def.charCodeAt(0) === 46 ? '' : '/') + def\n    const desc = typeof args[0] === 'string' ? args.shift() as string : ''\n    const config = args[0] as Command.Config || {}\n    if (this._disposed) config.patch = true\n    return this.context.command(def, desc, config)\n  }\n\n  usage(text: Command.Usage<U, G>) {\n    this._usage = text\n    return this\n  }\n\n  example(example: string) {\n    this._examples.push(example)\n    return this\n  }\n\n  option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<U, G, A, Extend<O, K, string>>\n  option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<U, G, A, Extend<O, K, R>>\n  option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<U, G, A, Extend<O, K, R>>\n  option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<U, G, A, Extend<O, K, Argv.OptionType<D>>>\n  option(name: string, desc: string, config: Argv.OptionConfig = {}) {\n    this._createOption(name, desc, config)\n    this._disposables?.push(() => this.removeOption(name))\n    return this\n  }\n\n  match(session: Session) {\n    const { authority = Infinity } = (session.user || {}) as User\n    return this.context.match(session) && this.config.authority <= authority\n  }\n\n  getConfig<K extends keyof Command.Config>(key: K, session: Session): Exclude<Command.Config[K], (session: Session) => any> {\n    const value = this.config[key] as any\n    return typeof value === 'function' ? value(session) : value\n  }\n\n  check(callback: Command.Action<U, G, A, O>, append = false) {\n    return this.before(callback, append)\n  }\n\n  before(callback: Command.Action<U, G, A, O>, append = false) {\n    if (append) {\n      this._checkers.push(callback)\n    } else {\n      this._checkers.unshift(callback)\n    }\n    this._disposables?.push(() => remove(this._checkers, callback))\n    return this\n  }\n\n  action(callback: Command.Action<U, G, A, O>, prepend = false) {\n    if (prepend) {\n      this._actions.unshift(callback)\n    } else {\n      this._actions.push(callback)\n    }\n    this._disposables?.push(() => remove(this._actions, callback))\n    return this\n  }\n\n  use<T extends Command, R extends any[]>(callback: (command: this, ...args: R) => T, ...args: R): T {\n    return callback(this, ...args)\n  }\n\n  async execute(argv: Argv<U, G, A, O>, fallback = Next.compose): Promise<string> {\n    argv.command ??= this\n    argv.args ??= [] as any\n    argv.options ??= {} as any\n\n    const { args, options, error } = argv\n    if (error) return error\n    if (logger.level >= 3) logger.debug(argv.source ||= this.stringify(args, options))\n\n    // before hooks\n    for (const validator of this._checkers) {\n      const result = await validator.call(this, argv, ...args)\n      if (typeof result === 'string') return result\n    }\n\n    // FIXME empty actions will cause infinite loop\n    if (!this._actions.length) return ''\n\n    let index = 0\n    const queue: Next.Queue = this._actions.map(action => async () => {\n      return await action.call(this, argv, ...args)\n    })\n\n    queue.push(fallback)\n    const length = queue.length\n    argv.next = async (callback) => {\n      if (callback !== undefined) {\n        queue.push(next => Next.compose(callback, next))\n        if (queue.length > Next.MAX_DEPTH) {\n          throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`)\n        }\n      }\n      return queue[index++]?.(argv.next)\n    }\n\n    try {\n      const result = await argv.next()\n      if (typeof result === 'string') return result\n    } catch (error) {\n      if (index === length) throw error\n      const stack = coerce(error)\n      logger.warn(`${argv.source ||= this.stringify(args, options)}\\n${stack}`)\n      this.app.emit(argv.session, 'command-error', argv, error)\n    }\n\n    return ''\n  }\n\n  dispose() {\n    this._disposed = true\n    this.app.emit('command-removed', this)\n    for (const cmd of this.children.slice()) {\n      cmd.dispose()\n    }\n    this.app._shortcuts = this.app._shortcuts.filter(s => s.command !== this)\n    this._aliases.forEach(name => this.app._commands.delete(name))\n    remove(this.app._commandList, this)\n    if (this.parent) {\n      remove(this.parent.children, this)\n    }\n  }\n}\n\nexport namespace Command {\n  export interface Config {\n    /** hide all options by default */\n    hideOptions?: boolean\n    /** hide command */\n    hidden?: boolean\n    /** min authority */\n    authority?: Computed<number>\n    /** disallow unknown options */\n    checkUnknown?: boolean\n    /** check argument count */\n    checkArgCount?: boolean\n    /** show command warnings */\n    showWarning?: boolean\n    /** depend on existing commands */\n    patch?: boolean\n  }\n\n  export const Config: Schema<Config> = Schema.object({\n    authority: Schema.natural().default(1),\n    hidden: Schema.boolean().default(false),\n    checkArgCount: Schema.boolean().default(false),\n    checkUnknown: Schema.boolean().default(false),\n  })\n}\n", "import { camelCase, Dict, escapeRegExp, paramCase, segment, Time } from '@koishijs/utils'\nimport { Command } from './command'\nimport { Context, Next } from './context'\nimport { Channel, User } from './database'\nimport { Session } from './session'\n\nexport interface Token {\n  rest?: string\n  content: string\n  quoted: boolean\n  terminator: string\n  inters: Argv[]\n}\n\nexport interface Argv<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O = {}> {\n  args?: A\n  options?: O\n  error?: string\n  source?: string\n  initiator?: string\n  terminator?: string\n  session?: Session<U, G>\n  command?: Command<U, G, A, O>\n  rest?: string\n  pos?: number\n  root?: boolean\n  tokens?: Token[]\n  name?: string\n  next?: Next\n}\n\nconst leftQuotes = `\"'“‘`\nconst rightQuotes = `\"'”’`\n\nexport namespace Argv {\n  export interface Interpolation {\n    terminator?: string\n    parse?(source: string): Argv\n  }\n\n  const bracs: Dict<Interpolation> = {}\n\n  export function interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv) {\n    bracs[initiator] = { terminator, parse }\n  }\n\n  interpolate('$(', ')')\n\n  export class Tokenizer {\n    private bracs: Dict<Interpolation>\n\n    constructor() {\n      this.bracs = Object.create(bracs)\n    }\n\n    interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv) {\n      this.bracs[initiator] = { terminator, parse }\n    }\n\n    parseToken(source: string, stopReg = '$'): Token {\n      const parent = { inters: [] } as Token\n      const index = leftQuotes.indexOf(source[0])\n      const quote = rightQuotes[index]\n      let content = ''\n      if (quote) {\n        source = source.slice(1)\n        stopReg = `${quote}(?=${stopReg})|$`\n      }\n      stopReg += `|${Object.keys({ ...this.bracs, ...bracs }).map(escapeRegExp).join('|')}`\n      const regExp = new RegExp(stopReg)\n      while (true) {\n        const capture = regExp.exec(source)\n        content += source.slice(0, capture.index)\n        if (capture[0] in this.bracs) {\n          source = source.slice(capture.index + capture[0].length).trimStart()\n          const { parse, terminator } = this.bracs[capture[0]]\n          const argv = parse?.(source) || this.parse(source, terminator)\n          source = argv.rest\n          parent.inters.push({ ...argv, pos: content.length, initiator: capture[0] })\n        } else {\n          const quoted = capture[0] === quote\n          const rest = source.slice(capture.index + +quoted)\n          parent.rest = rest.trimStart()\n          parent.quoted = quoted\n          parent.terminator = capture[0]\n          if (quoted) {\n            parent.terminator += rest.slice(0, -parent.rest.length)\n          } else if (quote) {\n            content = leftQuotes[index] + content\n            parent.inters.forEach(inter => inter.pos += 1)\n          }\n          parent.content = content\n          if (quote === \"'\") Argv.revert(parent)\n          return parent\n        }\n      }\n    }\n\n    parse(source: string, terminator = ''): Argv {\n      const tokens: Token[] = []\n      let rest = source, term = ''\n      const stopReg = `\\\\s+|[${escapeRegExp(terminator)}]|$`\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (rest && !(terminator && rest.startsWith(terminator))) {\n        const token = this.parseToken(rest, stopReg)\n        tokens.push(token)\n        rest = token.rest\n        term = token.terminator\n        delete token.rest\n      }\n      if (rest.startsWith(terminator)) rest = rest.slice(1)\n      source = source.slice(0, -(rest + term).length)\n      return { tokens, rest, source }\n    }\n\n    stringify(argv: Argv) {\n      const output = argv.tokens.reduce((prev, token) => {\n        if (token.quoted) prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])] || ''\n        return prev + token.content + token.terminator\n      }, '')\n      if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {\n        return output.slice(0, -1)\n      }\n      return output\n    }\n  }\n\n  const defaultTokenizer = new Tokenizer()\n\n  export function parse(source: string, terminator = '') {\n    return defaultTokenizer.parse(source, terminator)\n  }\n\n  export function stringify(argv: Argv) {\n    return defaultTokenizer.stringify(argv)\n  }\n\n  export function revert(token: Token) {\n    while (token.inters.length) {\n      const { pos, source, initiator } = token.inters.pop()\n      token.content = token.content.slice(0, pos)\n        + initiator + source + bracs[initiator].terminator\n        + token.content.slice(pos)\n    }\n  }\n\n  // builtin domains\n  export interface Domain {\n    string: string\n    number: number\n    boolean: boolean\n    text: string\n    rawtext: string\n    user: string\n    channel: string\n    integer: number\n    posint: number\n    natural: number\n    date: Date\n  }\n\n  type DomainType = keyof Domain\n\n  type ParamType<S extends string, F>\n    = S extends `${any}:${infer T}` ? T extends DomainType ? Domain[T] : F : F\n\n  type Replace<S extends string, X extends string, Y extends string>\n    = S extends `${infer L}${X}${infer R}` ? `${L}${Y}${Replace<R, X, Y>}` : S\n\n  type ExtractAll<S extends string, F>\n    = S extends `${infer L}]${infer R}` ? [ParamType<L, F>, ...ExtractAll<R, F>] : []\n\n  type ExtractFirst<S extends string, F>\n    = S extends `${infer L}]${any}` ? ParamType<L, F> : boolean\n\n  type ExtractSpread<S extends string> = S extends `${infer L}...${infer R}`\n    ? [...ExtractAll<L, string>, ...ExtractFirst<R, string>[]]\n    : [...ExtractAll<S, string>, ...string[]]\n\n  export type ArgumentType<S extends string> = ExtractSpread<Replace<S, '>', ']'>>\n\n  export type OptionType<S extends string> = ExtractFirst<Replace<S, '>', ']'>, any>\n\n  export type Type = DomainType | RegExp | string[] | Transform<any>\n\n  export interface Declaration {\n    name?: string\n    type?: Type\n    fallback?: any\n    variadic?: boolean\n    required?: boolean\n  }\n\n  export type Transform<T> = (source: string, session: Session) => T\n\n  export interface DomainConfig<T> {\n    transform?: Transform<T>\n    greedy?: boolean\n  }\n\n  function resolveConfig(type: Type) {\n    return typeof type === 'string' ? builtin[type] || {} : {}\n  }\n\n  function resolveType(type: Type) {\n    if (typeof type === 'function') {\n      return type\n    } else if (type instanceof RegExp) {\n      return (source: string) => {\n        if (type.test(source)) return source\n        throw new Error()\n      }\n    } else if (Array.isArray(type)) {\n      return (source: string) => {\n        if (type.includes(source)) return source\n        throw new Error()\n      }\n    }\n    return builtin[type]?.transform\n  }\n\n  const builtin: Dict<DomainConfig<any>> = {}\n\n  export function createDomain<K extends keyof Domain>(name: K, transform: Transform<Domain[K]>, options?: DomainConfig<Domain[K]>) {\n    builtin[name] = { ...options, transform }\n  }\n\n  createDomain('rawtext', source => source)\n  createDomain('string', source => source)\n  createDomain('text', source => source, { greedy: true })\n  createDomain('rawtext', source => segment.unescape(source), { greedy: true })\n  createDomain('boolean', () => true)\n\n  createDomain('number', (source, session) => {\n    const value = +source\n    if (Number.isFinite(value)) return value\n    throw new Error(session.text('internal.invalid-number'))\n  })\n\n  createDomain('integer', (source, session) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value) return value\n    throw new Error(session.text('internal.invalid-integer'))\n  })\n\n  createDomain('posint', (source, session) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value && value > 0) return value\n    throw new Error(session.text('internal.invalid-posint'))\n  })\n\n  createDomain('natural', (source, session) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value && value >= 0) return value\n    throw new Error(session.text('internal.invalid-natural'))\n  })\n\n  createDomain('date', (source, session) => {\n    const timestamp = Time.parseDate(source)\n    if (+timestamp) return timestamp\n    throw new Error(session.text('internal.invalid-date'))\n  })\n\n  createDomain('user', (source, session) => {\n    if (source.startsWith('@')) {\n      source = source.slice(1)\n      if (source.includes(':')) return source\n      return `${session.platform}:${source}`\n    }\n    const code = segment.from(source)\n    if (code && code.type === 'at') {\n      return `${session.platform}:${code.data.id}`\n    }\n    throw new Error(session.text('internal.invalid-user'))\n  })\n\n  createDomain('channel', (source, session) => {\n    if (source.startsWith('#')) {\n      source = source.slice(1)\n      if (source.includes(':')) return source\n      return `${session.platform}:${source}`\n    }\n    const code = segment.from(source)\n    if (code && code.type === 'sharp') {\n      return `${session.platform}:${code.data.id}`\n    }\n    throw new Error(session.text('internal.invalid-channel'))\n  })\n\n  const BRACKET_REGEXP = /<[^>]+>|\\[[^\\]]+\\]/g\n\n  interface DeclarationList extends Array<Declaration> {\n    stripped: string\n  }\n\n  function parseDecl(source: string) {\n    let cap: RegExpExecArray\n    const result = [] as DeclarationList\n    // eslint-disable-next-line no-cond-assign\n    while (cap = BRACKET_REGEXP.exec(source)) {\n      let rawName = cap[0].slice(1, -1)\n      let variadic = false\n      if (rawName.startsWith('...')) {\n        rawName = rawName.slice(3)\n        variadic = true\n      }\n      const [name, rawType] = rawName.split(':')\n      const type = rawType ? rawType.trim() as DomainType : undefined\n      result.push({\n        name,\n        variadic,\n        type,\n        required: cap[0][0] === '<',\n      })\n    }\n    result.stripped = source.replace(/:[\\w-]+[>\\]]/g, str => str.slice(-1)).trimEnd()\n    return result\n  }\n\n  export function parseValue(source: string, quoted: boolean, kind: string, argv: Argv, decl: Declaration = {}) {\n    const { name, type, fallback } = decl\n\n    // no explicit parameter & has fallback\n    const implicit = source === '' && !quoted\n    if (implicit && fallback !== undefined) return fallback\n\n    // apply domain callback\n    const transform = resolveType(type)\n    if (transform) {\n      try {\n        return transform(source, argv.session)\n      } catch (err) {\n        if (!argv.session) {\n          argv.error = `internal.invalid-${kind}`\n        } else {\n          const message = err['message'] || argv.session.text('internal.check-syntax')\n          argv.error = argv.session.text(`internal.invalid-${kind}`, [name, message])\n        }\n        return\n      }\n    }\n\n    // default behavior\n    if (implicit) return true\n    if (quoted) return source\n    const n = +source\n    return n * 0 === 0 ? n : source\n  }\n\n  export interface OptionConfig<T extends Type = Type> {\n    value?: any\n    fallback?: any\n    type?: T\n    /** hide the option by default */\n    hidden?: boolean | ((session: Session) => boolean)\n    authority?: number\n    notUsage?: boolean\n    descPath?: string\n  }\n\n  export interface TypedOptionConfig<T extends Type> extends OptionConfig<T> {\n    type: T\n  }\n\n  export interface OptionDeclaration extends Declaration, OptionConfig {\n    syntax: string\n    values?: Dict<any>\n  }\n\n  type OptionDeclarationMap = Dict<OptionDeclaration>\n\n  export class CommandBase {\n    public declaration: string\n\n    public _arguments: Declaration[]\n    public _options: OptionDeclarationMap = {}\n\n    private _namedOptions: OptionDeclarationMap = {}\n    private _symbolicOptions: OptionDeclarationMap = {}\n\n    constructor(public readonly name: string, declaration: string, public context: Context) {\n      if (!name) throw new Error('expect a command name')\n      const decl = this._arguments = parseDecl(declaration)\n      this.declaration = decl.stripped\n    }\n\n    _createOption(name: string, def: string, config: OptionConfig) {\n      const param = paramCase(name)\n      const decl = def.replace(/(?<=^|\\s)[\\w\\x80-\\uffff].*/, '')\n      const desc = def.slice(decl.length)\n      let syntax = decl.replace(/(?<=^|\\s)(<[^<]+>|\\[[^[]+\\]).*/, '')\n      const bracket = decl.slice(syntax.length)\n      syntax = syntax.trim() || '--' + param\n\n      const names: string[] = []\n      const symbols: string[] = []\n      for (let param of syntax.trim().split(',')) {\n        param = param.trimStart()\n        const name = param.replace(/^-+/, '')\n        if (!name || !param.startsWith('-')) {\n          symbols.push(param)\n        } else {\n          names.push(name)\n        }\n      }\n\n      if (!config.value && !names.includes(param)) {\n        syntax += ', --' + param\n      }\n\n      const declList = parseDecl(bracket)\n      if (declList.stripped) syntax += ' ' + declList.stripped\n      const option = this._options[name] ||= {\n        ...Command.defaultOptionConfig,\n        ...declList[0],\n        ...config,\n        name,\n        values: {},\n        syntax,\n      }\n\n      if (desc) this.context.i18n.define('', `commands.${this.name}.options.${name}`, desc)\n\n      const fallbackType = typeof option.fallback\n      if ('value' in config) {\n        names.forEach(name => option.values[name] = config.value)\n      } else if (!bracket.trim()) {\n        option.type = 'boolean'\n      } else if (!option.type && (fallbackType === 'string' || fallbackType === 'number')) {\n        option.type = fallbackType\n      }\n\n      this._assignOption(option, names, this._namedOptions)\n      this._assignOption(option, symbols, this._symbolicOptions)\n      if (!this._namedOptions[param]) {\n        this._namedOptions[param] = option\n      }\n    }\n\n    private _assignOption(option: OptionDeclaration, names: readonly string[], optionMap: OptionDeclarationMap) {\n      for (const name of names) {\n        if (name in optionMap) {\n          throw new Error(`duplicate option name \"${name}\" for command \"${this.name}\"`)\n        }\n        optionMap[name] = option\n      }\n    }\n\n    removeOption<K extends string>(name: K) {\n      if (!this._options[name]) return false\n      const option = this._options[name]\n      delete this._options[name]\n      for (const key in this._namedOptions) {\n        if (this._namedOptions[key] === option) {\n          delete this._namedOptions[key]\n        }\n      }\n      for (const key in this._symbolicOptions) {\n        if (this._symbolicOptions[key] === option) {\n          delete this._symbolicOptions[key]\n        }\n      }\n      return true\n    }\n\n    parse(argv: Argv): Argv\n    parse(source: string, terminator?: string, args?: any[], options?: Dict<any>): Argv\n    parse(argv: string | Argv, terminator?: string, args = [], options = {}): Argv {\n      if (typeof argv === 'string') argv = Argv.parse(argv, terminator)\n\n      const source = this.name + ' ' + Argv.stringify(argv)\n      while (!argv.error && argv.tokens.length) {\n        const token = argv.tokens[0]\n        let { content, quoted } = token\n\n        // greedy argument\n        const argDecl = this._arguments[args.length]\n        if (content[0] !== '-' && resolveConfig(argDecl?.type).greedy) {\n          args.push(Argv.parseValue(Argv.stringify(argv), true, 'argument', argv, argDecl))\n          break\n        }\n\n        // parse token\n        argv.tokens.shift()\n        let option: OptionDeclaration\n        let names: string | string[]\n        let param: string\n        // symbolic option\n        if (!quoted && (option = this._symbolicOptions[content])) {\n          names = [paramCase(option.name)]\n        } else {\n          // normal argument\n          if (content[0] !== '-' || quoted) {\n            args.push(Argv.parseValue(content, quoted, 'argument', argv, argDecl || { type: 'string' }))\n            continue\n          }\n\n          // find -\n          let i = 0\n          let name: string\n          for (; i < content.length; ++i) {\n            if (content.charCodeAt(i) !== 45) break\n          }\n          if (content.slice(i, i + 3) === 'no-' && !this._namedOptions[content.slice(i)]) {\n            name = content.slice(i + 3)\n            options[camelCase(name)] = false\n            continue\n          }\n\n          // find =\n          let j = i + 1\n          for (; j < content.length; j++) {\n            if (content.charCodeAt(j) === 61) break\n          }\n          name = content.slice(i, j)\n          names = i > 1 ? [name] : name\n          param = content.slice(++j)\n          option = this._namedOptions[names[names.length - 1]]\n        }\n\n        // get parameter from next token\n        quoted = false\n        if (!param) {\n          const { type } = option || {}\n          if (resolveConfig(type).greedy) {\n            param = Argv.stringify(argv)\n            quoted = true\n            argv.tokens = []\n          } else if (type !== 'boolean' && argv.tokens.length && (type || argv.tokens[0]?.content !== '-')) {\n            const token = argv.tokens.shift()\n            param = token.content\n            quoted = token.quoted\n          }\n        }\n\n        // handle each name\n        for (let j = 0; j < names.length; j++) {\n          const name = names[j]\n          const optDecl = this._namedOptions[name]\n          const key = optDecl ? optDecl.name : camelCase(name)\n          if (optDecl && name in optDecl.values) {\n            options[key] = optDecl.values[name]\n          } else {\n            const source = j + 1 < names.length ? '' : param\n            options[key] = Argv.parseValue(source, quoted, 'option', argv, optDecl)\n          }\n          if (argv.error) break\n        }\n      }\n\n      // assign default values\n      for (const { name, fallback } of Object.values(this._options)) {\n        if (fallback !== undefined && !(name in options)) {\n          options[name] = fallback\n        }\n      }\n\n      delete argv.tokens\n      return { options, args, source, rest: argv.rest, error: argv.error || '' }\n    }\n\n    private stringifyArg(value: any) {\n      value = '' + value\n      return value.includes(' ') ? `\"${value}\"` : value\n    }\n\n    stringify(args: readonly string[], options: any) {\n      let output = this.name\n      for (const key in options) {\n        const value = options[key]\n        if (value === true) {\n          output += ` --${key}`\n        } else if (value === false) {\n          output += ` --no-${key}`\n        } else {\n          output += ` --${key} ${this.stringifyArg(value)}`\n        }\n      }\n      for (const arg of args) {\n        output += ' ' + this.stringifyArg(arg)\n      }\n      return output\n    }\n  }\n}\n", "import { Awaitable, defineProperty, Dict, Logger, makeArray, MaybeArray, Promisify, Random, remove, Schema, sleep } from '@koishijs/utils'\nimport { Command } from './command'\nimport { Session } from './session'\nimport { Channel, Database, ModelService, Modules, Service, Tables, User } from './database'\nimport { Argv } from './parser'\nimport { App } from './app'\nimport { Bot } from './bot'\nimport { Adapter } from './adapter'\nimport { I18n } from './i18n'\n\nexport type Next = (next?: Next.Callback) => Promise<void | string>\nexport type Middleware = (session: Session, next: Next) => Awaitable<void | string>\nexport type Disposable = () => void\n\nexport namespace Next {\n  export const MAX_DEPTH = 64\n\n  export type Queue = ((next?: Next) => Promise<void | string>)[]\n  export type Callback = void | string | ((next?: Next) => Awaitable<void | string>)\n\n  export async function compose(callback: Callback, next?: Next) {\n    return typeof callback === 'function' ? callback(next) : callback\n  }\n}\n\nexport type Plugin = Plugin.Function | Plugin.Object\n\nexport namespace Plugin {\n  export type Function<T = any> = (ctx: Context, options: T) => void\n  export type Constructor<T = any> = new (ctx: Context, options: T) => void\n\n  export interface Object<T = any> {\n    name?: string\n    apply: Function<T>\n    Config?: Schema\n    using?: readonly (keyof Context.Services)[]\n  }\n\n  export interface ObjectWithSchema<T = any> {\n    name?: string\n    apply: Function\n    schema?: Schema<T, any>\n    using?: readonly (keyof Context.Services)[]\n  }\n\n  export type Config<T extends Plugin> =\n    | T extends Constructor<infer U> ? U\n    : T extends Function<infer U> ? U\n    : T extends ObjectWithSchema<infer U> ? U\n    : T extends Object<infer U> ? U\n    : never\n\n  export interface State {\n    id: string\n    parent: Context\n    context?: Context\n    config?: any\n    using: readonly (keyof Context.Services)[]\n    schema?: Schema\n    plugin?: Plugin\n    children: Plugin[]\n    disposables: Disposable[]\n  }\n\n  export class Registry extends Map<Plugin, State> {\n    private resolve(plugin: Plugin) {\n      return plugin && (typeof plugin === 'function' ? plugin : plugin.apply)\n    }\n\n    get(plugin: Plugin) {\n      return super.get(this.resolve(plugin))\n    }\n\n    set(plugin: Plugin, state: State) {\n      return super.set(this.resolve(plugin), state)\n    }\n\n    has(plugin: Plugin) {\n      return super.has(this.resolve(plugin))\n    }\n\n    delete(plugin: Plugin) {\n      return super.delete(this.resolve(plugin))\n    }\n  }\n}\n\nfunction isBailed(value: any) {\n  return value !== null && value !== false && value !== undefined\n}\n\nfunction isConstructor(func: Function) {\n  // async function or arrow function\n  if (!func.prototype) return false\n  // generator function or malformed definition\n  if (func.prototype.constructor !== func) return false\n  return true\n}\n\nfunction isApplicable(object: Plugin) {\n  return object && typeof object === 'object' && typeof object.apply === 'function'\n}\n\nconst selectors = ['user', 'guild', 'channel', 'self', 'private', 'platform'] as const\n\nexport type Filter = (session: Session) => boolean\nexport type SelectorType = typeof selectors[number]\nexport type SelectorValue = boolean | MaybeArray<string | number>\nexport type BaseSelection = { [K in SelectorType as `$${K}`]?: SelectorValue }\n\nexport interface Selection extends BaseSelection {\n  $and?: Selection[]\n  $or?: Selection[]\n  $not?: Selection\n}\n\nexport interface Context extends Context.Services {}\n\nexport class Context {\n  static readonly middleware = Symbol('middleware')\n  static readonly current = Symbol('source')\n\n  protected constructor(public filter: Filter, public app?: App, private _plugin: Plugin = null) {}\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `Context <${this._plugin ? this._plugin.name : 'root'}>`\n  }\n\n  private _property<K extends keyof Session>(key: K, ...values: Session[K][]) {\n    return this.intersect((session) => {\n      return values.length ? values.includes(session[key]) : !!session[key]\n    })\n  }\n\n  user(...values: string[]) {\n    return this._property('userId', ...values)\n  }\n\n  self(...values: string[]) {\n    return this._property('selfId', ...values)\n  }\n\n  guild(...values: string[]) {\n    return this._property('guildId', ...values)\n  }\n\n  channel(...values: string[]) {\n    return this._property('channelId', ...values)\n  }\n\n  platform(...values: string[]) {\n    return this._property('platform', ...values)\n  }\n\n  private(...values: string[]) {\n    return this.exclude(this._property('guildId'))._property('userId', ...values)\n  }\n\n  select(options: Selection) {\n    let ctx: Context = this\n\n    // basic selectors\n    for (const type of selectors) {\n      const value = options[`$${type}`] as SelectorValue\n      if (value === true) {\n        ctx = ctx[type]()\n      } else if (value === false) {\n        ctx = ctx.exclude(ctx[type]())\n      } else if (value !== undefined) {\n        // we turn everything into string\n        ctx = ctx[type](...makeArray(value).map(item => '' + item))\n      }\n    }\n\n    // intersect\n    if (options.$and) {\n      for (const selection of options.$and) {\n        ctx = ctx.intersect(this.select(selection))\n      }\n    }\n\n    // union\n    if (options.$or) {\n      let ctx2: Context = this.app\n      for (const selection of options.$or) {\n        ctx2 = ctx2.union(this.select(selection))\n      }\n      ctx = ctx.intersect(ctx2)\n    }\n\n    // exclude\n    if (options.$not) {\n      ctx = ctx.exclude(this.select(options.$not))\n    }\n\n    return ctx\n  }\n\n  logger(name: string) {\n    return new Logger(name)\n  }\n\n  any() {\n    return new Context(() => true, this.app, this._plugin)\n  }\n\n  never() {\n    return new Context(() => false, this.app, this._plugin)\n  }\n\n  union(arg: Filter | Context) {\n    const filter = typeof arg === 'function' ? arg : arg.filter\n    return new Context(s => this.filter(s) || filter(s), this.app, this._plugin)\n  }\n\n  intersect(arg: Filter | Context) {\n    const filter = typeof arg === 'function' ? arg : arg.filter\n    return new Context(s => this.filter(s) && filter(s), this.app, this._plugin)\n  }\n\n  exclude(arg: Filter | Context) {\n    const filter = typeof arg === 'function' ? arg : arg.filter\n    return new Context(s => this.filter(s) && !filter(s), this.app, this._plugin)\n  }\n\n  /** @deprecated use `ctx.exclude()` instead */\n  except(arg: Filter | Context) {\n    return this.exclude(arg)\n  }\n\n  match(session?: Session) {\n    return !session || this.filter(session)\n  }\n\n  get state() {\n    return this.app.registry.get(this._plugin)\n  }\n\n  using(using: readonly (keyof Context.Services)[], callback: Plugin.Function<void>) {\n    return this.plugin({ using, apply: callback, name: callback.name })\n  }\n\n  validate<T extends Plugin>(plugin: T, config: any) {\n    if (config === false) return\n    if (config === true) config = undefined\n    config ??= {}\n\n    const schema = plugin['Config'] || plugin['schema']\n    if (schema) config = schema(config)\n    return config\n  }\n\n  plugin(name: string, config?: any): this\n  plugin<T extends Plugin>(plugin: T, config?: boolean | Plugin.Config<T>): this\n  plugin(entry: string | Plugin, config?: any) {\n    // load plugin by name\n    const plugin: Plugin = typeof entry === 'string' ? Modules.require(entry, true) : entry\n\n    // check duplication\n    if (this.app.registry.has(plugin)) {\n      this.logger('app').warn(`duplicate plugin detected: ${plugin.name}`)\n      return this\n    }\n\n    // check if it's a valid plugin\n    if (typeof plugin !== 'function' && !isApplicable(plugin)) {\n      throw new Error('invalid plugin, expect function or object with an \"apply\" method')\n    }\n\n    // validate plugin config\n    config = this.validate(plugin, config)\n    if (!config) return this\n\n    const context = new Context(this.filter, this.app, plugin).select(config)\n    const schema = plugin['Config'] || plugin['schema']\n    const using = plugin['using'] || []\n\n    this.logger('app').debug('plugin:', plugin.name)\n    this.app.registry.set(plugin, {\n      plugin,\n      schema,\n      using,\n      context,\n      id: Random.id(),\n      parent: this,\n      config: config,\n      children: [],\n      disposables: [],\n    })\n\n    this.state.children.push(plugin)\n    this.emit('plugin-added', this.app.registry.get(plugin))\n\n    if (using.length) {\n      context.on('service', (name) => {\n        if (!using.includes(name)) return\n        context.state.children.slice().map(plugin => this.dispose(plugin))\n        context.state.disposables.slice(1).map(dispose => dispose())\n        callback()\n      })\n    }\n\n    const callback = () => {\n      if (using.some(name => !this[name])) return\n      if (typeof plugin !== 'function') {\n        plugin.apply(context, config)\n      } else if (isConstructor(plugin)) {\n        // eslint-disable-next-line new-cap\n        const instance = new plugin(context, config)\n        if (instance instanceof Service && instance.immediate) {\n          context[instance.name] = instance as never\n        }\n      } else {\n        plugin(context, config)\n      }\n    }\n\n    callback()\n    return this\n  }\n\n  dispose(plugin = this._plugin) {\n    if (!plugin) throw new Error('root level context cannot be disposed')\n    const state = this.app.registry.get(plugin)\n    if (!state) return\n    this.logger('app').debug('dispose:', plugin.name)\n    state.children.slice().map(plugin => this.dispose(plugin))\n    state.disposables.slice().map(dispose => dispose())\n    this.app.registry.delete(plugin)\n    remove(state.parent.state.children, plugin)\n    this.emit('plugin-removed', state)\n    return state\n  }\n\n  * getHooks(name: EventName, session?: Session) {\n    const hooks = this.app._hooks[name] || []\n    for (const [context, callback] of hooks.slice()) {\n      if (!context.match(session)) continue\n      yield callback\n    }\n  }\n\n  async parallel<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promise<void>\n  async parallel<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promise<void>\n  async parallel(...args: any[]) {\n    const tasks: Promise<any>[] = []\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, session)) {\n      tasks.push(Promise.resolve(callback.apply(session, args)).catch((error) => {\n        this.logger('app').warn(error)\n      }))\n    }\n    await Promise.all(tasks)\n  }\n\n  emit<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): void\n  emit<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): void\n  emit(...args: [any, ...any[]]) {\n    this.parallel(...args)\n  }\n\n  waterfall<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  waterfall<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  async waterfall(...args: [any, ...any[]]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, session)) {\n      const result = await callback.apply(session, args)\n      args[0] = result\n    }\n    return args[0]\n  }\n\n  chain<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  chain<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  chain(...args: [any, ...any[]]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, session)) {\n      const result = callback.apply(session, args)\n      args[0] = result\n    }\n    return args[0]\n  }\n\n  serial<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  serial<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  async serial(...args: any[]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, session)) {\n      const result = await callback.apply(session, args)\n      if (isBailed(result)) return result\n    }\n  }\n\n  bail<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  bail<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  bail(...args: any[]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, session)) {\n      const result = callback.apply(session, args)\n      if (isBailed(result)) return result\n    }\n  }\n\n  on<K extends EventName>(name: K, listener: EventMap[K], prepend?: boolean): () => boolean\n  on(name: EventName, listener: Disposable, prepend = false) {\n    const method = prepend ? 'unshift' : 'push'\n\n    if (typeof name === 'string' && name in Context.deprecatedEvents) {\n      const alternative = Context.deprecatedEvents[name]\n      this.logger('app').warn(`event \"${name}\" is deprecated, use \"${alternative}\" instead`)\n      name = alternative\n    }\n\n    // handle special events\n    if (name === 'ready' && this.app.isActive) {\n      this.app._tasks.queue(sleep(0).then(() => listener()))\n      return () => false\n    } else if (name === 'dispose') {\n      this.state.disposables[method](listener)\n      return () => remove(this.state.disposables, listener)\n    }\n\n    const hooks = this.app._hooks[name] ||= []\n    if (hooks.length >= this.app.options.maxListeners) {\n      this.logger('app').warn(\n        'max listener count (%d) for event \"%s\" exceeded, which may be caused by a memory leak',\n        this.app.options.maxListeners, name,\n      )\n    }\n\n    hooks[method]([this, listener])\n    const dispose = () => {\n      remove(this.state.disposables, dispose)\n      return this.off(name, listener)\n    }\n    this.state.disposables.push(dispose)\n    return dispose\n  }\n\n  before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append = false) {\n    const seg = name.split('/')\n    seg[seg.length - 1] = 'before-' + seg[seg.length - 1]\n    return this.on(seg.join('/') as EventName, listener, !append)\n  }\n\n  once<K extends EventName>(name: K, listener: EventMap[K], prepend?: boolean): () => boolean\n  once(name: EventName, listener: Disposable, prepend = false) {\n    const dispose = this.on(name, function (...args: any[]) {\n      dispose()\n      return listener.apply(this, args)\n    }, prepend)\n    return dispose\n  }\n\n  off<K extends EventName>(name: K, listener: EventMap[K]) {\n    const index = (this.app._hooks[name] || [])\n      .findIndex(([context, callback]) => context === this && callback === listener)\n    if (index >= 0) {\n      this.app._hooks[name].splice(index, 1)\n      return true\n    }\n  }\n\n  middleware(middleware: Middleware, prepend = false) {\n    return this.on(Context.middleware, middleware, prepend)\n  }\n\n  private createTimerDispose(timer: NodeJS.Timeout) {\n    const dispose = () => {\n      clearTimeout(timer)\n      if (!this.state) return\n      return remove(this.state.disposables, dispose)\n    }\n    this.state.disposables.push(dispose)\n    return dispose\n  }\n\n  setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n    const dispose = this.createTimerDispose(setTimeout(() => {\n      dispose()\n      callback()\n    }, ms, ...args))\n    return dispose\n  }\n\n  setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n    return this.createTimerDispose(setInterval(callback, ms, ...args))\n  }\n\n  getCommand(name: string) {\n    return this.app._commands.get(name)\n  }\n\n  command<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  command<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  command(def: string, ...args: [Command.Config?] | [string, Command.Config?]) {\n    const desc = typeof args[0] === 'string' ? args.shift() as string : ''\n    const config = args[0] as Command.Config\n    const path = def.split(' ', 1)[0].toLowerCase()\n    const decl = def.slice(path.length)\n    const segments = path.split(/(?=[./])/g)\n\n    let parent: Command, root: Command\n    const list: Command[] = []\n    segments.forEach((segment, index) => {\n      const code = segment.charCodeAt(0)\n      const name = code === 46 ? parent.name + segment : code === 47 ? segment.slice(1) : segment\n      let command = this.getCommand(name)\n      if (command) {\n        if (parent) {\n          if (command === parent) {\n            throw new Error(`cannot set a command (${command.name}) as its own subcommand`)\n          }\n          if (command.parent) {\n            if (command.parent !== parent) {\n              throw new Error(`cannot create subcommand ${path}: ${command.parent.name}/${command.name} already exists`)\n            }\n          } else {\n            command.parent = parent\n            parent.children.push(command)\n          }\n        }\n        return parent = command\n      }\n      command = new Command(name, decl, this)\n      list.push(command)\n      if (!root) root = command\n      if (parent) {\n        command.parent = parent\n        command.config.authority = parent.config.authority\n        parent.children.push(command)\n      }\n      parent = command\n    })\n\n    if (desc) this.i18n.define('', `commands.${parent.name}.description`, desc)\n    Object.assign(parent.config, config)\n    list.forEach(command => this.emit('command-added', command))\n    if (!config?.patch) {\n      if (root) this.state.disposables.unshift(() => root.dispose())\n      return parent\n    }\n\n    if (root) root.dispose()\n    const command = Object.create(parent)\n    command._disposables = this.state.disposables\n    return command\n  }\n\n  getSelfIds(type?: string, assignees?: string[]): Dict<string[]> {\n    if (type) {\n      assignees ||= this.bots.filter(bot => bot.platform === type).map(bot => bot.selfId)\n      return { [type]: assignees }\n    }\n    const platforms: Dict<string[]> = {}\n    for (const bot of this.bots) {\n      (platforms[bot.platform] ||= []).push(bot.selfId)\n    }\n    return platforms\n  }\n\n  async broadcast(content: string, forced?: boolean): Promise<string[]>\n  async broadcast(channels: readonly string[], content: string, forced?: boolean): Promise<string[]>\n  async broadcast(...args: [string, boolean?] | [readonly string[], string, boolean?]) {\n    let channels: string[]\n    if (Array.isArray(args[0])) channels = args.shift() as any\n    const [content, forced] = args as [string, boolean]\n    if (!content) return []\n\n    const data = await this.database.getAssignedChannels(['id', 'assignee', 'flag', 'platform', 'guildId'])\n    const assignMap: Dict<Dict<[string, string][]>> = {}\n    for (const { id, assignee, flag, platform, guildId } of data) {\n      if (channels && !channels.includes(`${platform}:${id}`)) continue\n      if (!forced && (flag & Channel.Flag.silent)) continue\n      ((assignMap[platform] ||= {})[assignee] ||= []).push([id, guildId])\n    }\n\n    return (await Promise.all(Object.entries(assignMap).flatMap(([platform, map]) => {\n      return this.bots.map((bot) => {\n        if (bot.platform !== platform) return Promise.resolve([])\n        return bot.broadcast(map[bot.selfId] || [], content)\n      })\n    }))).flat(1)\n  }\n}\n\nexport namespace Context {\n  export interface Services {\n    bots: Adapter.BotList\n    database: Database\n    model: ModelService\n    i18n: I18n\n  }\n\n  export const Services: (keyof Services)[] = []\n\n  export function service(key: keyof Services) {\n    if (Object.prototype.hasOwnProperty.call(Context.prototype, key)) return\n    Services.push(key)\n    const privateKey = Symbol(key)\n    Object.defineProperty(Context.prototype, key, {\n      get(this: Context) {\n        const value = this.app[privateKey]\n        if (!value) return\n        defineProperty(value, Context.current, this)\n        return value\n      },\n      set(this: Context, value) {\n        const oldValue = this.app[privateKey]\n        if (oldValue === value) return\n        this.app[privateKey] = value\n        this.emit('service', key)\n        const action = value ? oldValue ? 'changed' : 'enabled' : 'disabled'\n        this.logger('service').debug(key, action)\n      },\n    })\n  }\n\n  service('bots')\n  service('database')\n  service('i18n')\n  service('model')\n\n  export const deprecatedEvents: Dict<EventName & string> = {\n    'connect': 'ready',\n    'disconnect': 'dispose',\n    'before-command': 'command/before-execute',\n  }\n}\n\ntype EventName = keyof EventMap\ntype OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never\ntype BeforeEventName = OmitSubstring<EventName & string, 'before-'>\n\nexport type BeforeEventMap = { [E in EventName & string as OmitSubstring<E, 'before-'>]: EventMap[E] }\n\nexport interface EventMap {\n  [Context.middleware]: Middleware\n\n  // internal events\n  'appellation'(name: string, session: Session): string\n  'before-parse'(content: string, session: Session): Argv\n  'before-attach-channel'(session: Session, fields: Set<Channel.Field>): void\n  'attach-channel'(session: Session): Awaitable<void | boolean>\n  'before-attach-user'(session: Session, fields: Set<User.Field>): void\n  'attach-user'(session: Session): Awaitable<void | boolean>\n  'before-attach'(session: Session): void\n  'attach'(session: Session): void\n  'before-send'(session: Session): Awaitable<void | boolean>\n  'command-added'(command: Command): void\n  'command-removed'(command: Command): void\n  'command-error'(argv: Argv, error: any): void\n  'command/before-execute'(argv: Argv): Awaitable<void | string>\n  'command/before-attach-channel'(argv: Argv, fields: Set<Channel.Field>): void\n  'command/before-attach-user'(argv: Argv, fields: Set<User.Field>): void\n  'middleware'(session: Session): void\n  'help/command'(output: string[], command: Command, session: Session): void\n  'help/option'(output: string, option: Argv.OptionDeclaration, command: Command, session: Session): string\n  'plugin-added'(state: Plugin.State): void\n  'plugin-removed'(state: Plugin.State): void\n  'ready'(): Awaitable<void>\n  'dispose'(): Awaitable<void>\n  'model'(name: keyof Tables): void\n  'service'(name: keyof Context.Services): void\n  'adapter'(name: string): void\n  'bot-added'(bot: Bot): void\n  'bot-removed'(bot: Bot): void\n  'bot-status-updated'(bot: Bot): void\n  'bot-connect'(bot: Bot): Awaitable<void>\n  'bot-disconnect'(bot: Bot): Awaitable<void>\n\n  // deprecated events\n  'connect'(): Awaitable<void>\n  'disconnect'(): Awaitable<void>\n  'before-command'(argv: Argv): Awaitable<void | string>\n}\n", "import * as utils from '@koishijs/utils'\nimport { Awaitable, Dict, Get, MaybeArray } from '@koishijs/utils'\nimport { Driver, Model, Modifier, Result, Update } from '@koishijs/orm'\nimport { Context } from './context'\n\nexport interface User {\n  id: string\n  flag: number\n  authority: number\n  name: string\n  locale: string\n}\n\nexport namespace User {\n  export enum Flag {\n    ignore = 1,\n  }\n\n  export type Field = keyof User\n  export const fields: Field[] = []\n  export type Observed<K extends Field = Field> = utils.Observed<Pick<User, K>, Promise<void>>\n}\n\nexport interface Channel {\n  id: string\n  platform: string\n  flag: number\n  assignee: string\n  guildId: string\n  locale: string\n}\n\nexport namespace Channel {\n  export enum Flag {\n    ignore = 1,\n    silent = 4,\n  }\n\n  export type Field = keyof Channel\n  export const fields: Field[] = []\n  export type Observed<K extends Field = Field> = utils.Observed<Pick<Channel, K>, Promise<void>>\n}\n\nexport interface Tables {\n  user: User\n  channel: Channel\n}\n\nexport class ModelService extends Model<Tables> {\n  constructor(protected ctx: Context) {\n    super()\n\n    this.extend('user', {\n      id: 'string(63)',\n      name: 'string(63)',\n      flag: 'unsigned(20)',\n      authority: 'unsigned(4)',\n      locale: 'string(63)',\n    }, {\n      autoInc: true,\n    })\n\n    this.extend('channel', {\n      id: 'string(63)',\n      platform: 'string(63)',\n      flag: 'unsigned(20)',\n      assignee: 'string(63)',\n      guildId: 'string(63)',\n      locale: 'string(63)',\n    }, {\n      primary: ['id', 'platform'],\n    })\n  }\n\n  extend<K extends keyof Tables>(name: K, fields?: Model.Field.Extension<Tables[K]>, extension?: Model.Extension<Tables[K]>) {\n    super.extend(name, fields, extension)\n    this.ctx.emit('model', name)\n  }\n}\n\nexport abstract class Service {\n  protected start(): Awaitable<void> {}\n  protected stop(): Awaitable<void> {}\n\n  constructor(protected ctx: Context, public name: keyof Context.Services, public immediate?: boolean) {\n    Context.service(name)\n\n    ctx.on('ready', async () => {\n      await this.start()\n      ctx[name] = this as never\n    })\n\n    ctx.on('dispose', async () => {\n      if (ctx[name] === this as never) ctx[name] = null\n      await this.stop()\n    })\n  }\n\n  get caller(): Context {\n    return this[Context.current] || this.ctx\n  }\n}\n\nexport abstract class Database extends Driver<Tables> {\n  protected start(): Awaitable<void> {}\n  protected stop(): Awaitable<void> {}\n\n  constructor(protected ctx: Context) {\n    super(ctx.model)\n\n    ctx.on('ready', async () => {\n      await this.start()\n      ctx.database = this\n    })\n\n    ctx.on('dispose', async () => {\n      if (ctx.database === this) ctx.database = null\n      await this.stop()\n    })\n  }\n\n  getUser<T extends string, K extends User.Field>(platform: T, id: string, modifier?: Modifier<K>): Promise<Result<User, K> & Record<T, string>>\n  getUser<T extends string, K extends User.Field>(platform: T, ids: string[], modifier?: Modifier<K>): Promise<Result<User, K>[]>\n  async getUser(platform: string, id: MaybeArray<string>, modifier?: Modifier<User.Field>) {\n    const data = await this.get('user', { [platform]: id }, modifier)\n    if (Array.isArray(id)) return data\n    if (data[0]) Object.assign(data[0], { [platform]: id })\n    return data[0] as any\n  }\n\n  setUser(platform: string, id: string, data: Update<User>) {\n    return this.set('user', { [platform]: id }, data)\n  }\n\n  createUser(platform: string, id: string, data: Partial<User>) {\n    return this.create('user', { [platform]: id, ...data })\n  }\n\n  getChannel<K extends Channel.Field>(platform: string, id: string, modifier?: Modifier<K>): Promise<Result<Channel, K | 'id' | 'platform'>>\n  getChannel<K extends Channel.Field>(platform: string, ids: string[], modifier?: Modifier<K>): Promise<Result<Channel, K>[]>\n  async getChannel(platform: string, id: MaybeArray<string>, modifier?: Modifier<Channel.Field>) {\n    const data = await this.get('channel', { platform, id }, modifier)\n    if (Array.isArray(id)) return data\n    if (data[0]) Object.assign(data[0], { platform, id })\n    return data[0]\n  }\n\n  getAssignedChannels<K extends Channel.Field>(fields?: K[], assignMap?: Dict<string[]>): Promise<Result<Channel, K>[]>\n  async getAssignedChannels(fields?: Channel.Field[], assignMap: Dict<string[]> = this.ctx.getSelfIds()) {\n    return this.get('channel', {\n      $or: Object.entries(assignMap).map(([platform, assignee]) => ({ platform, assignee })),\n    }, fields)\n  }\n\n  setChannel(platform: string, id: string, data: Update<Channel>) {\n    return this.set('channel', { platform, id }, data)\n  }\n\n  createChannel(platform: string, id: string, data: Partial<Channel>) {\n    return this.create('channel', { platform, id, ...data })\n  }\n}\n\nexport namespace Database {\n  type Methods<S, T> = {\n    [K in keyof S]?: S[K] extends (...args: infer R) => infer U ? (this: T, ...args: R) => U : S[K]\n  }\n\n  type Constructor<T> = new (...args: any[]) => T\n  type ExtensionMethods<T> = Methods<Database, T extends Constructor<infer I> ? I : never>\n  type Extension<T> = ((Database: T) => void) | ExtensionMethods<T>\n\n  /** @deprecated */\n  export function extend<K extends keyof Modules>(module: K, extension: Extension<Get<Modules[K], 'default'>>): void\n  export function extend<T extends Constructor<unknown>>(module: T, extension: Extension<T>): void\n  export function extend(module: any, extension: any) {\n    const Database = typeof module === 'string' ? Modules.require(module) : module\n    if (!Database) return\n\n    if (typeof extension === 'function') {\n      extension(Database)\n    } else {\n      Object.assign(Database.prototype, extension)\n    }\n  }\n}\n\nexport function unwrapExports(module: any) {\n  return module?.default || module\n}\n\nexport interface Modules {}\n\nexport namespace Modules {\n  const cache: Dict = {}\n\n  export function define(name: string, value: any) {\n    cache[name] = value\n  }\n\n  export namespace internal {\n    export function require(name: string) {\n      return cache[name]\n    }\n\n    export function resolve(name: string) {\n      if (name in cache) return name\n      throw new Error(`Cannot find module \"${name}\"`)\n    }\n\n    export function paths(name: string) {\n      const prefix1 = 'koishi-plugin-'\n      const prefix2 = '@koishijs/plugin-'\n      if (name.includes(prefix1) || name.startsWith(prefix2)) {\n        // full package path\n        return [name]\n      } else if (name[0] === '@') {\n        // scope package path\n        const index = name.indexOf('/')\n        return [name.slice(0, index + 1) + prefix1 + name.slice(index + 1)]\n      } else {\n        // normal package path\n        return [prefix1 + name, prefix2 + name]\n      }\n    }\n  }\n\n  export function require(name: string, forced = false) {\n    try {\n      const path = resolve(name)\n      const exports = internal.require(path)\n      return unwrapExports(exports)\n    } catch (error) {\n      if (forced) throw error\n    }\n  }\n\n  export function resolve(name: string) {\n    const modules = internal.paths(name)\n    for (const path of modules) {\n      try {\n        return internal.resolve(path)\n      } catch {}\n    }\n    throw new Error(`cannot resolve plugin \"${name}\"`)\n  }\n}\n", "import { Channel, Tables, User } from './database'\nimport { Command } from './command'\nimport { defineProperty, Logger, makeArray, observe, Promisify, Random, remove, segment } from '@koishijs/utils'\nimport { Argv } from './parser'\nimport { Middleware, Next } from './context'\nimport { App } from './app'\nimport { Bot } from './bot'\n\ntype Genres = 'friend' | 'channel' | 'group' | 'group-member' | 'group-role' | 'group-file' | 'group-emoji'\ntype Actions = 'added' | 'deleted' | 'updated'\ntype SessionEventCallback = (session: Session) => void\n\ndeclare module './context' {\n  interface EventMap extends Record<`${Genres}-${Actions}`, SessionEventCallback> {\n    'message': SessionEventCallback\n    'message-deleted': SessionEventCallback\n    'message-updated': SessionEventCallback\n    'reaction-added': SessionEventCallback\n    'reaction-deleted': SessionEventCallback\n    'reaction-deleted/one': SessionEventCallback\n    'reaction-deleted/all': SessionEventCallback\n    'reaction-deleted/emoji': SessionEventCallback\n    'send': SessionEventCallback\n    'friend-request': SessionEventCallback\n    'guild-request': SessionEventCallback\n    'guild-member-request': SessionEventCallback\n    'group-member/role': SessionEventCallback\n    'group-member/ban': SessionEventCallback\n    'group-member/nickname': SessionEventCallback\n    'notice/poke': SessionEventCallback\n    'notice/lucky-king': SessionEventCallback\n    'notice/honor': SessionEventCallback\n    'notice/honor/talkative': SessionEventCallback\n    'notice/honor/performer': SessionEventCallback\n    'notice/honor/emotion': SessionEventCallback\n  }\n}\n\nconst logger = new Logger('session')\n\nexport interface Session extends Session.Payload {}\n\nexport namespace Session {\n  export interface Payload {\n    platform?: string\n    selfId: string\n    type?: string\n    subtype?: string\n    messageId?: string\n    channelId?: string\n    guildId?: string\n    userId?: string\n    content?: string\n    timestamp?: number\n    author?: Bot.Author\n    quote?: Bot.Message\n    channelName?: string\n    guildName?: string\n    operatorId?: string\n    targetId?: string\n    duration?: number\n    file?: FileInfo\n  }\n}\n\nexport interface Parsed {\n  content: string\n  prefix: string\n  appel: boolean\n}\n\nexport type Computed<T> = T | ((session: Session) => T)\n\nexport class Session<U extends User.Field = never, G extends Channel.Field = never> {\n  type?: string\n  subtype?: string\n  subsubtype?: string\n  scope?: string\n\n  bot: Bot\n  app: App\n\n  selfId: string\n  operatorId?: string\n  targetId?: string\n  duration?: number\n  file?: FileInfo\n\n  id: string\n  platform?: string\n  argv?: Argv<U, G>\n  user?: User.Observed<U>\n  channel?: Channel.Observed<G>\n  guild?: Channel.Observed<G>\n  parsed?: Parsed\n\n  private _delay?: number\n  private _queued: Promise<void>\n  private _hooks: (() => void)[]\n  private _promise: Promise<string>\n\n  constructor(bot: Bot, session: Partial<Session.Payload>) {\n    Object.assign(this, session)\n    this.platform = bot.platform\n    defineProperty(this, 'app', bot.app)\n    defineProperty(this, 'bot', bot)\n    defineProperty(this, 'user', null)\n    defineProperty(this, 'channel', null)\n    defineProperty(this, 'id', Random.id())\n    defineProperty(this, '_queued', Promise.resolve())\n    defineProperty(this, '_hooks', [])\n  }\n\n  get uid() {\n    return `${this.platform}:${this.userId}`\n  }\n\n  get gid() {\n    return `${this.platform}:${this.guildId}`\n  }\n\n  get cid() {\n    return `${this.platform}:${this.channelId}`\n  }\n\n  get sid() {\n    return `${this.platform}:${this.selfId}`\n  }\n\n  toJSON(): Session.Payload {\n    return Object.fromEntries(Object.entries(this).filter(([key]) => {\n      return !key.startsWith('_') && !key.startsWith('$')\n    })) as any\n  }\n\n  private async _preprocess() {\n    let node: segment.Parsed\n    let content = this.content.trim()\n    // eslint-disable-next-line no-cond-assign\n    if (node = segment.from(content, { type: 'quote', caret: true })) {\n      content = content.slice(node.capture[0].length).trimStart()\n      this.quote = await this.bot.getMessage(node.data.channelId || this.channelId, node.data.id).catch((error) => {\n        logger.warn(error)\n        return undefined\n      })\n    }\n    return content\n  }\n\n  async preprocess() {\n    return this._promise ||= this._preprocess()\n  }\n\n  get username(): string {\n    const defaultName = this.user && this.user['name']\n      ? this.user['name']\n      : this.author\n        ? this.author.nickname || this.author.username\n        : this.userId\n    return this.app.chain('appellation', defaultName, this)\n  }\n\n  async send(content: string) {\n    if (!content) return\n    return this.bot.sendMessage(this.channelId, content, this.guildId).catch<string[]>((error) => {\n      logger.warn(error)\n      return []\n    })\n  }\n\n  cancelQueued(delay = this.app.options.delay.cancel) {\n    this._hooks.forEach(Reflect.apply)\n    this._delay = delay\n  }\n\n  async sendQueued(content: string, delay?: number) {\n    if (!content) return\n    if (typeof delay === 'undefined') {\n      const { message, character } = this.app.options.delay\n      delay = Math.max(message, character * content.length)\n    }\n    return this._queued = this._queued.then(() => new Promise<void>((resolve) => {\n      const hook = () => {\n        resolve()\n        clearTimeout(timer)\n        remove(this._hooks, hook)\n      }\n      this._hooks.push(hook)\n      const timer = setTimeout(async () => {\n        await this.send(content)\n        this._delay = delay\n        hook()\n      }, this._delay || 0)\n    }))\n  }\n\n  resolveValue<T>(source: T | ((session: Session) => T)): T {\n    return typeof source === 'function' ? Reflect.apply(source, null, [this]) : source\n  }\n\n  async getChannel<K extends Channel.Field = never>(id = this.channelId, fields: K[] = []) {\n    const { app, platform, guildId } = this\n    if (!fields.length) return { platform, id, guildId }\n    const channel = await app.database.getChannel(platform, id, fields)\n    if (channel) return channel\n    const assignee = await this.resolveValue(app.options.autoAssign) ? this.selfId : ''\n    if (assignee) {\n      return app.database.createChannel(platform, id, { assignee, guildId })\n    } else {\n      const channel = app.model.create('channel')\n      Object.assign(channel, { platform, id, guildId })\n      return channel\n    }\n  }\n\n  /** 在当前会话上绑定一个可观测频道实例 */\n  async _observeChannelLike<T extends Channel.Field = never>(channelId: string, fields: Iterable<T> = []) {\n    const fieldSet = new Set<Channel.Field>(fields)\n    const { platform } = this\n    const key = `${platform}:${channelId}`\n\n    // 如果存在满足可用的缓存数据，使用缓存代替数据获取\n    let cache = this.app._channelCache.get(this.id, key)\n    if (cache) {\n      for (const key in cache) {\n        fieldSet.delete(key as any)\n      }\n      if (!fieldSet.size) return cache\n    }\n\n    // 绑定一个新的可观测频道实例\n    const data = await this.getChannel(channelId, [...fieldSet])\n    cache = this.app._channelCache.get(this.id, key)\n    if (cache) {\n      cache.$merge(data)\n    } else {\n      cache = observe(data, diff => this.app.database.setChannel(platform, channelId, diff), `channel ${key}`)\n      this.app._channelCache.set(this.id, key, cache)\n    }\n    return cache\n  }\n\n  async observeChannel<T extends Channel.Field = never>(fields: Iterable<T> = []): Promise<Channel.Observed<T | G>> {\n    const tasks = [this._observeChannelLike(this.channelId, fields)]\n    if (this.channelId !== this.guildId) {\n      tasks.push(this._observeChannelLike(this.guildId, fields))\n    }\n    const [channel, guild = channel] = await Promise.all(tasks)\n    this.guild = guild\n    this.channel = channel\n    return channel\n  }\n\n  async getUser<K extends User.Field = never>(id = this.userId, fields: K[] = []) {\n    const { app, platform } = this\n    if (!fields.length) return { [platform]: id }\n    const user = await app.database.getUser(platform, id, fields)\n    if (user) return user\n    const authority = await this.resolveValue(app.options.autoAuthorize)\n    if (authority) {\n      return app.database.createUser(platform, id, { authority })\n    } else {\n      const user = app.model.create('user')\n      Object.assign(user, { [platform]: id, authority })\n      return user\n    }\n  }\n\n  /** 在当前会话上绑定一个可观测用户实例 */\n  async observeUser<T extends User.Field = never>(fields: Iterable<T> = []): Promise<User.Observed<T | U>> {\n    const fieldSet = new Set<User.Field>(fields)\n    const { userId, platform } = this\n\n    // 如果存在满足可用的缓存数据，使用缓存代替数据获取\n    let cache = this.app._userCache.get(this.id, this.uid)\n    if (cache) {\n      for (const key in cache) {\n        fieldSet.delete(key as any)\n      }\n      if (!fieldSet.size) return this.user = cache\n    }\n\n    // 匿名消息不会写回数据库\n    if (this.author?.anonymous) {\n      const fallback = this.app.model.create('user')\n      fallback[platform] = userId\n      fallback.authority = await this.resolveValue(this.app.options.autoAuthorize)\n      const user = observe(fallback, () => Promise.resolve())\n      return this.user = user\n    }\n\n    // 绑定一个新的可观测用户实例\n    const data = await this.getUser(userId, [...fieldSet])\n    cache = this.app._userCache.get(this.id, this.uid)\n    if (cache) {\n      cache.$merge(data)\n    } else {\n      cache = observe(data, diff => this.app.database.setUser(this.platform, userId, diff), `user ${this.uid}`)\n      this.app._userCache.set(this.id, this.uid, cache)\n    }\n    return this.user = cache\n  }\n\n  async withScope<T>(scope: string, callback: () => T) {\n    const oldScope = this.scope\n    try {\n      this.scope = scope\n      return await callback() as Promisify<T>\n    } finally {\n      this.scope = oldScope\n    }\n  }\n\n  text(path: string | string[], params: object = {}) {\n    const locales = [this.app.options.locale]\n    locales.unshift(this.user?.['locale'])\n    if (this.subtype === 'group') {\n      locales.unshift(this.guild?.['locale'])\n      locales.unshift(this.channel?.['locale'])\n    }\n    const paths = makeArray(path).map((path) => {\n      if (!path.startsWith('.')) return path\n      if (!this.scope) {\n        this.app.logger('i18n').warn(new Error('missing scope'))\n        return ''\n      }\n      return this.scope + path\n    })\n    return this.app.i18n.text(locales, paths, params)\n  }\n\n  collect<T extends 'user' | 'channel'>(key: T, argv: Argv, fields = new Set<keyof Tables[T]>()) {\n    const collect = (argv: Argv) => {\n      argv.session = this\n      if (argv.tokens) {\n        for (const { inters } of argv.tokens) {\n          inters.forEach(collect)\n        }\n      }\n      if (!this.resolve(argv)) return\n      this.app.emit(argv.session, `command/before-attach-${key}` as any, argv, fields)\n      collectFields(argv, Command[`_${key}Fields`] as any, fields)\n      collectFields(argv, argv.command[`_${key}Fields`] as any, fields)\n    }\n    collect(argv)\n    return fields\n  }\n\n  private inferCommand(argv: Argv) {\n    if (argv.command) return argv.command\n    if (argv.name) return argv.command = this.app._commands.resolve(argv.name)\n\n    const { parsed, subtype } = this\n    // guild message should have prefix or appel to be interpreted as a command call\n    if (argv.root && subtype !== 'private' && parsed.prefix === null && !parsed.appel) return\n    if (!argv.tokens.length) return\n    const cmd = this.app._commands.resolve(argv.tokens[0].content)\n    if (cmd) {\n      argv.tokens.shift()\n      return argv.command = cmd\n    }\n  }\n\n  resolve(argv: Argv) {\n    if (!this.inferCommand(argv)) return\n    if (argv.tokens?.every(token => !token.inters.length)) {\n      const { options, args, error } = argv.command.parse(argv)\n      argv.options = { ...argv.options, ...options }\n      argv.args = [...argv.args || [], ...args]\n      argv.error = error\n    }\n    return argv.command\n  }\n\n  async execute(content: string, next?: true | Next): Promise<string>\n  async execute(argv: Argv, next?: true | Next): Promise<string>\n  async execute(argv: string | Argv, next?: true | Next): Promise<string> {\n    if (typeof argv === 'string') argv = Argv.parse(argv)\n\n    argv.session = this\n    if (argv.tokens) {\n      for (const arg of argv.tokens) {\n        const { inters } = arg\n        const output: string[] = []\n        for (let i = 0; i < inters.length; ++i) {\n          output.push(await this.execute(inters[i], true))\n        }\n        for (let i = inters.length - 1; i >= 0; --i) {\n          const { pos } = inters[i]\n          arg.content = arg.content.slice(0, pos) + output[i] + arg.content.slice(pos)\n        }\n        arg.inters = []\n      }\n      if (!this.resolve(argv)) return ''\n    } else {\n      argv.command ||= this.app.getCommand(argv.name)\n      if (!argv.command) {\n        logger.warn(new Error(`cannot find command ${argv.name}`))\n        return ''\n      }\n    }\n\n    const { command } = argv\n    if (!command.context.match(this)) return ''\n\n    if (this.app.database) {\n      if (this.subtype === 'group') {\n        await this.observeChannel(this.collect('channel', argv))\n      }\n      await this.observeUser(this.collect('user', argv))\n    }\n\n    let shouldEmit = true\n    if (next === true) {\n      shouldEmit = false\n      next = undefined as Next\n    }\n\n    return this.withScope(`commands.${command.name}.messages`, async () => {\n      const result = await command.execute(argv as Argv, next as Next)\n      if (!shouldEmit) return result\n      await this.send(result)\n      return ''\n    })\n  }\n\n  middleware(middleware: Middleware) {\n    const identifier = getSessionId(this)\n    return this.app.middleware(async (session, next) => {\n      if (identifier && getSessionId(session) !== identifier) return next()\n      return middleware(session, next)\n    }, true)\n  }\n\n  prompt(timeout = this.app.options.delay.prompt) {\n    return new Promise<string>((resolve) => {\n      const dispose = this.middleware((session) => {\n        clearTimeout(timer)\n        dispose()\n        resolve(session.content)\n      })\n      const timer = setTimeout(() => {\n        dispose()\n        resolve('')\n      }, timeout)\n    })\n  }\n}\n\nexport function getSessionId(session: Session) {\n  return '' + session.userId + session.channelId\n}\n\nexport type FieldCollector<T extends keyof Tables, K = keyof Tables[T], A extends any[] = any[], O = {}> =\n  | Iterable<K>\n  | ((argv: Argv<never, never, A, O>, fields: Set<keyof Tables[T]>) => void)\n\nfunction collectFields<T extends keyof Tables>(argv: Argv, collectors: FieldCollector<T>[], fields: Set<keyof Tables[T]>) {\n  for (const collector of collectors) {\n    if (typeof collector === 'function') {\n      collector(argv, fields)\n      continue\n    }\n    for (const field of collector) {\n      fields.add(field)\n    }\n  }\n  return fields\n}\n\nexport interface FileInfo {\n  id: string\n  name: string\n  size: number\n  busid: number\n}\n", "import { Awaitable, coerce, defineProperty, Dict, escapeRegExp, Logger, makeArray, Schema, Time } from '@koishijs/utils'\nimport { Context, Next, Plugin } from './context'\nimport { Adapter } from './adapter'\nimport { Channel, ModelService, User } from './database'\nimport { Command } from './command'\nimport { Computed, Session } from './session'\nimport { I18n } from './i18n'\nimport runtime from './internal/runtime'\nimport validate from './internal/validate'\nimport suggest, { SuggestConfig } from './internal/suggest'\nimport help, { HelpConfig } from './internal/help'\n\nfunction createLeadingRE(patterns: string[], prefix = '', suffix = '') {\n  return patterns.length ? new RegExp(`^${prefix}(${patterns.map(escapeRegExp).join('|')})${suffix}`) : /$^/\n}\n\ninterface CommandMap extends Map<string, Command> {\n  resolve(key: string): Command\n}\n\nconst logger = new Logger('app')\n\nexport class App extends Context {\n  _commandList: Command[] = []\n  _commands: CommandMap = new Map<string, Command>() as never\n  _shortcuts: Command.Shortcut[] = []\n  _tasks = new TaskQueue()\n  _hooks: Record<keyof any, [Context, (...args: any[]) => any][]> = {}\n  _sessions: Dict<Session> = Object.create(null)\n  _userCache = new SharedCache<User.Observed<any>>()\n  _channelCache = new SharedCache<Channel.Observed<any>>()\n\n  public app = this\n  public options: App.Config\n  public isActive = false\n  public registry = new Plugin.Registry()\n\n  private _nameRE: RegExp\n\n  constructor(options: App.Config = {}) {\n    super(() => true)\n    this.options = new App.Config(options)\n    this.registry.set(null, {\n      id: '',\n      parent: null,\n      using: [],\n      children: [],\n      disposables: [],\n    })\n\n    this.model = new ModelService(this)\n    this.i18n = new I18n(this)\n    this.bots = new Adapter.BotList(this)\n\n    this._commands.resolve = (key) => {\n      if (!key) return\n      const segments = key.split('.')\n      let i = 1, name = segments[0], cmd: Command\n      while ((cmd = this.getCommand(name)) && i < segments.length) {\n        name = cmd.name + '.' + segments[i++]\n      }\n      return cmd\n    }\n\n    this.prepare()\n\n    // bind built-in event listeners\n    this.middleware(this._process.bind(this))\n    this.on('message', this._handleMessage.bind(this))\n\n    this.before('attach-user', (session, fields) => {\n      session.collect('user', session.argv, fields)\n    })\n\n    this.before('attach-channel', (session, fields) => {\n      session.collect('channel', session.argv, fields)\n    })\n\n    // install internal plugins\n    this.plugin(runtime)\n    this.plugin(validate)\n    this.plugin(suggest)\n    this.plugin(help, options.help)\n  }\n\n  prepare() {\n    const { nickname } = this.options\n    this.options.nickname = makeArray(nickname)\n    this._nameRE = createLeadingRE(this.options.nickname, '@?', '([,，]\\\\s*|\\\\s+)')\n  }\n\n  async start() {\n    this.isActive = true\n    logger.debug('started')\n    for (const callback of this.getHooks('ready')) {\n      this._tasks.queue(callback())\n    }\n    delete this._hooks.ready\n    await this._tasks.flush()\n  }\n\n  async stop() {\n    this.isActive = false\n    logger.debug('stopped')\n    // `dispose` event is handled by ctx.disposables\n    await Promise.all(this.state.disposables.map(dispose => dispose()))\n  }\n\n  private _resolvePrefixes(session: Session) {\n    const temp = session.resolveValue(this.options.prefix)\n    return Array.isArray(temp) ? temp : [temp || '']\n  }\n\n  private async _process(session: Session, next: Next) {\n    let capture: RegExpMatchArray\n    let atSelf = false, appel = false, prefix: string = null\n    const pattern = /^\\[CQ:(\\w+)((,\\w+=[^,\\]]*)*)\\]/\n    let content = await session.preprocess()\n\n    // strip prefix\n    if (session.subtype !== 'private' && (capture = content.match(pattern)) && capture[1] === 'at' && capture[2].includes('id=' + session.selfId)) {\n      atSelf = appel = true\n      content = content.slice(capture[0].length).trimStart()\n      // eslint-disable-next-line no-cond-assign\n    } else if (capture = content.match(this._nameRE)) {\n      appel = true\n      content = content.slice(capture[0].length)\n    }\n\n    for (const _prefix of this._resolvePrefixes(session)) {\n      if (!content.startsWith(_prefix)) continue\n      prefix = _prefix\n      content = content.slice(_prefix.length)\n    }\n\n    // store parsed message\n    defineProperty(session, 'parsed', { content, appel, prefix })\n    this.emit(session, 'before-attach', session)\n\n    if (this.database) {\n      if (session.subtype === 'group') {\n        // attach group data\n        const channelFields = new Set<Channel.Field>(['flag', 'assignee', 'guildId', 'locale'])\n        this.emit('before-attach-channel', session, channelFields)\n        const channel = await session.observeChannel(channelFields)\n        // for backwards compatibility (TODO remove in v5)\n        channel.guildId = session.guildId\n\n        // emit attach event\n        if (await this.serial(session, 'attach-channel', session)) return\n\n        // ignore some group calls\n        if (channel.flag & Channel.Flag.ignore) return\n        if (channel.assignee !== session.selfId && !atSelf) return\n      }\n\n      // attach user data\n      // authority is for suggestion\n      const userFields = new Set<User.Field>(['flag', 'authority', 'locale'])\n      this.emit('before-attach-user', session, userFields)\n      const user = await session.observeUser(userFields)\n\n      // emit attach event\n      if (await this.serial(session, 'attach-user', session)) return\n\n      // ignore some user calls\n      if (user.flag & User.Flag.ignore) return\n    }\n\n    this.emit(session, 'attach', session)\n    return next()\n  }\n\n  private async _handleMessage(session: Session) {\n    // preparation\n    this._sessions[session.id] = session\n    const queue: Next.Queue = this._hooks[Context.middleware]\n      .filter(([context]) => context.match(session))\n      .map(([, middleware]) => middleware.bind(null, session))\n\n    // execute middlewares\n    let index = 0, midStack = '', lastCall = ''\n    const { prettyErrors } = this.options\n    const next: Next = async (callback) => {\n      if (prettyErrors) {\n        lastCall = new Error().stack.split('\\n', 3)[2]\n        if (index) {\n          const capture = lastCall.match(/\\((.+)\\)/)\n          midStack = `\\n  - ${capture ? capture[1] : lastCall.slice(7)}${midStack}`\n        }\n      }\n\n      try {\n        if (!this._sessions[session.id]) {\n          throw new Error('isolated next function detected')\n        }\n        if (callback !== undefined) {\n          queue.push(next => Next.compose(callback, next))\n          if (queue.length > Next.MAX_DEPTH) {\n            throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`)\n          }\n        }\n        return await queue[index++]?.(next)\n      } catch (error) {\n        let stack = coerce(error)\n        if (prettyErrors) {\n          const index = stack.indexOf(lastCall)\n          if (index >= 0) {\n            stack = stack.slice(0, index)\n          } else {\n            stack += '\\n'\n          }\n          stack += `Middleware stack:${midStack}`\n        }\n        this.logger('session').warn(`${session.content}\\n${stack}`)\n      }\n    }\n\n    try {\n      const result = await next()\n      if (result) await session.send(result)\n    } finally {\n      // update session map\n      delete this._sessions[session.id]\n      this.emit(session, 'middleware', session)\n\n      // flush user & group data\n      this._userCache.delete(session.id)\n      this._channelCache.delete(session.id)\n      await session.user?.$update()\n      await session.channel?.$update()\n      await session.guild?.$update()\n    }\n  }\n}\n\nexport namespace App {\n  export interface DelayConfig {\n    character?: number\n    message?: number\n    cancel?: number\n    broadcast?: number\n    prompt?: number\n  }\n\n  export interface Config extends Config.Basic, Config.Features, Config.Advanced {}\n\n  export namespace Config {\n    export interface Basic extends SuggestConfig {\n      locale?: string\n      prefix?: Computed<string | string[]>\n      nickname?: string | string[]\n      autoAssign?: Computed<Awaitable<boolean>>\n      autoAuthorize?: Computed<Awaitable<number>>\n    }\n\n    export interface Features {\n      help?: false | HelpConfig\n      delay?: DelayConfig\n    }\n\n    export interface Advanced {\n      maxListeners?: number\n      prettyErrors?: boolean\n    }\n\n    export interface Static extends Schema<Config> {\n      Basic: Schema<Basic>\n      Features: Schema<Features>\n      Advanced: Schema<Advanced>\n    }\n  }\n\n  export const Config = Schema.intersect([]) as Config.Static\n\n  defineProperty(Config, 'Basic', Schema.object({\n    locale: Schema.string().default('zh').description('默认使用的语言。'),\n    prefix: Schema.union([\n      Schema.array(String),\n      Schema.transform(String, (prefix) => [prefix]),\n    ] as const).default(['']).description('指令前缀字符，可以是字符串或字符串数组。将用于指令前缀的匹配。'),\n    nickname: Schema.union([\n      Schema.array(String),\n      Schema.transform(String, (nickname) => [nickname]),\n    ] as const).description('机器人的昵称，可以是字符串或字符串数组。将用于指令前缀的匹配。'),\n    autoAssign: Schema.union([Boolean, Function]).default(true).description('当获取不到频道数据时，是否使用接受者作为代理者。'),\n    autoAuthorize: Schema.union([Schema.natural(), Function]).default(1).description('当获取不到用户数据时默认使用的权限等级。'),\n    minSimilarity: Schema.percent().default(0.4).description('用于模糊匹配的相似系数，应该是一个 0 到 1 之间的数值。数值越高，模糊匹配越严格。设置为 1 可以完全禁用模糊匹配。'),\n  }).description('基础设置'))\n\n  defineProperty(Config, 'Features', Schema.object({\n    delay: Schema.object({\n      character: Schema.natural().role('ms').default(0).description('调用 `session.sendQueued()` 时消息间发送的最小延迟，按前一条消息的字数计算。'),\n      message: Schema.natural().role('ms').default(0.1 * Time.second).description('调用 `session.sendQueued()` 时消息间发送的最小延迟，按固定值计算。'),\n      cancel: Schema.natural().role('ms').default(0).description('调用 `session.cancelQueued()` 时默认的延迟。'),\n      broadcast: Schema.natural().role('ms').default(0.5 * Time.second).description('调用 `bot.broadcast()` 时默认的延迟。'),\n      prompt: Schema.natural().role('ms').default(Time.minute).description('调用 `session.prompt()` 时默认的等待时间。'),\n    }),\n  }).description('消息设置'))\n\n  defineProperty(Config, 'Advanced', Schema.object({\n    prettyErrors: Schema.boolean().default(true).description('启用报错优化模式。在此模式下 Koishi 会对程序抛出的异常进行整理，过滤掉框架内部的调用记录，输出更易读的提示信息。'),\n    maxListeners: Schema.natural().default(64).description('每种监听器的最大数量。如果超过这个数量，Koishi 会认定为发生了内存泄漏，将产生一个警告。'),\n  }).description('高级设置'))\n\n  Config.list.push(Config.Basic, Config.Features, Config.Advanced)\n}\n\nexport function defineConfig(config: App.Config) {\n  return config\n}\n\nclass TaskQueue {\n  #internal = new Set<Promise<void>>()\n\n  queue(value: any) {\n    const task = Promise.resolve(value)\n      .catch(err => logger.warn(err))\n      .then(() => this.#internal.delete(task))\n    this.#internal.add(task)\n  }\n\n  async flush() {\n    while (this.#internal.size) {\n      await Promise.all(Array.from(this.#internal))\n    }\n  }\n}\n\nexport namespace SharedCache {\n  export interface Entry<T> {\n    value: T\n    key: string\n    refs: Set<string>\n  }\n}\n\nexport class SharedCache<T> {\n  #keyMap: Dict<SharedCache.Entry<T>> = Object.create(null)\n\n  get(ref: string, key: string) {\n    const entry = this.#keyMap[key]\n    if (!entry) return\n    entry.refs.add(ref)\n    return entry.value\n  }\n\n  set(ref: string, key: string, value: T) {\n    const entry = this.#keyMap[key] ||= { value, key, refs: new Set() }\n    entry.refs.add(ref)\n  }\n\n  delete(ref: string) {\n    for (const key in this.#keyMap) {\n      const { refs } = this.#keyMap[key]\n      refs.delete(ref)\n      if (!refs.size) {\n        delete this.#keyMap[key]\n      }\n    }\n  }\n}\n", "import { Dict, isNullable, Logger, Time } from '@koishijs/utils'\nimport { Context } from './context'\n\nconst logger = new Logger('i18n')\n\nexport namespace I18n {\n  export type Template = string | { $: string }\n  export type Node = Template | Store\n\n  export interface Store {\n    [K: string]: Node\n  }\n\n  export type Formatter = (value: any, args: string[], locale: string) => string\n  export type Renderer = (dict: Dict, params: any, locale: string) => string\n}\n\nexport class I18n {\n  _data: Dict<Dict<I18n.Template>> = {}\n  _formatters: Dict<I18n.Formatter> = {}\n  _renderers: Dict<I18n.Renderer> = {}\n\n  static isTemplate(data: any): data is I18n.Template {\n    return typeof data === 'string' || data?.$\n  }\n\n  constructor(protected ctx: Context) {\n    this.define('', { '': '' })\n    this.define('zh', require('./locales/zh'))\n    this.define('en', require('./locales/en'))\n\n    const { day, hour, minute, second } = Time\n\n    this.formatter('time', (ms: number, _, locale) => {\n      let result: string\n      if (ms >= day - hour / 2) {\n        ms += hour / 2\n        result = Math.floor(ms / day) + ' ' + this.text([locale], ['general.day'], {})\n        if (ms % day > hour) {\n          result += ` ${Math.floor(ms % day / hour)} ` + this.text([locale], ['general.hour'], {})\n        }\n      } else if (ms >= hour - minute / 2) {\n        ms += minute / 2\n        result = Math.floor(ms / hour) + ' ' + this.text([locale], ['general.hour'], {})\n        if (ms % hour > minute) {\n          result += ` ${Math.floor(ms % hour / minute)} ` + this.text([locale], ['general.minute'], {})\n        }\n      } else if (ms >= minute - second / 2) {\n        ms += second / 2\n        result = Math.floor(ms / minute) + ' ' + this.text([locale], ['general.minute'], {})\n        if (ms % minute > second) {\n          result += ` ${Math.floor(ms % minute / second)} ` + this.text([locale], ['general.second'], {})\n        }\n      } else {\n        result = Math.round(ms / second) + ' ' + this.text([locale], ['general.second'], {})\n      }\n      return result\n    })\n\n    this.renderer('list', (data, params: any[], locale) => {\n      const list = params.map((value) => {\n        return this.render(data.item, { value }, locale)\n      })\n      if (data.header) list.unshift(this.render(data.header, params, locale))\n      if (data.footer) list.push(this.render(data.footer, params, locale))\n      return list.join('\\n')\n    })\n\n    this.renderer('inline-list', (data, params: any[], locale) => {\n      let output = ''\n      params.forEach((value, index) => {\n        if (index) {\n          if (index === params.length - 1 && data.conj !== undefined) {\n            output += data.conj\n          } else {\n            output += data.separator ?? this.text([locale], ['general.comma'], {})\n          }\n        }\n        output += this.render(data.item, { value }, locale) ?? value\n      })\n      const path = params.length in data ? params.length : 'body'\n      if (data[path] === undefined) return output\n      return this.render(data[path], [output, params.length], locale)\n    })\n  }\n\n  private set(locale: string, prefix: string, value: I18n.Node) {\n    if (I18n.isTemplate(value)) {\n      const dict = this._data[locale]\n      const path = prefix.slice(0, -1)\n      if (!isNullable(dict[path]) && !locale.startsWith('$')) {\n        logger.warn('override', locale, path)\n      }\n      dict[path] = value as I18n.Template\n      this[Context.current]?.on('dispose', () => {\n        delete dict[path]\n      })\n    } else if (value) {\n      for (const key in value) {\n        this.set(locale, prefix + key + '.', value[key])\n      }\n    }\n  }\n\n  define(locale: string, dict: I18n.Store): void\n  define(locale: string, key: string, value: I18n.Node): void\n  define(locale: string, ...args: [I18n.Store] | [string, I18n.Node]) {\n    this._data[locale] ||= {}\n    if (typeof args[0] === 'string') {\n      this.set(locale, args[0] + '.', args[1])\n    } else {\n      this.set(locale, '', args[0])\n    }\n  }\n\n  formatter(name: string, callback: I18n.Formatter) {\n    this._formatters[name] = callback\n  }\n\n  renderer(name: string, callback: I18n.Renderer) {\n    this._renderers[name] = callback\n  }\n\n  render(value: I18n.Template, params: any, locale: string) {\n    if (value === undefined) return\n\n    if (typeof value !== 'string') {\n      const render = this._renderers[value.$]\n      if (!render) throw new Error(`Renderer \"${value.$}\" not found`)\n      return render(value, params, locale)\n    }\n\n    return value.replace(/\\{(.+?)\\}/g, (_, inner: string) => {\n      const [path, ...exprs] = inner.split('|')\n      const segments = path.trim().split('.')\n      let result = params\n      for (const segment of segments) {\n        result = result[segment]\n        if (isNullable(result)) return ''\n      }\n      for (const expr of exprs) {\n        const cap = expr.trim().match(/(\\w+)(?:\\((.+)\\))?/)\n        const formatter = this._formatters[cap[1]]\n        if (!formatter) throw new Error(`Formatter \"${cap[1]}\" not found`)\n        const args = cap[2] ? cap[2].split(',').map(v => v.trim()) : []\n        result = formatter(result, args, locale)\n      }\n      return result.toString()\n    })\n  }\n\n  text(locales: Iterable<string>, paths: string[], params: object) {\n    // sort locales by priority\n    const queue = new Set<string>()\n    for (const locale of locales) {\n      if (!locale) continue\n      queue.add(locale)\n    }\n    for (const locale in this._data) {\n      if (locale.startsWith('$')) continue\n      queue.add(locale)\n    }\n\n    // try every locale\n    for (const path of paths) {\n      for (const locale of queue) {\n        for (const key of ['$' + locale, locale]) {\n          const value = this._data[key]?.[path]\n          if (value === undefined) continue\n          return this.render(value, params, locale)\n        }\n      }\n    }\n\n    // path not found\n    logger.warn('missing', paths[0])\n    return paths[0]\n  }\n}\n", "import { defineProperty, valueMap } from '@koishijs/utils'\nimport { Argv } from '../parser'\nimport { Context } from '../context'\nimport { Session } from '../session'\n\nexport default function runtime(ctx: Context) {\n  ctx.before('parse', (content, session) => {\n    const argv = Argv.parse(content)\n    if (session.quote) {\n      argv.tokens.push({\n        content: session.quote.content,\n        quoted: true,\n        inters: [],\n        terminator: '',\n      })\n    }\n    return argv\n  })\n\n  ctx.before('parse', (content, session) => {\n    const { parsed, quote } = session\n    if (parsed.prefix || quote) return\n    for (const shortcut of ctx.app._shortcuts) {\n      const { name, fuzzy, command, prefix, options = {}, args = [] } = shortcut\n      if (prefix && !parsed.appel || !command.context.match(session)) continue\n      if (typeof name === 'string') {\n        if (!fuzzy && content !== name || !content.startsWith(name)) continue\n        const message = content.slice(name.length)\n        if (fuzzy && !parsed.appel && message.match(/^\\S/)) continue\n        const argv = command.parse(message.trim(), '', [...args], { ...options })\n        argv.command = command\n        return argv\n      } else {\n        const capture = name.exec(content)\n        if (!capture) continue\n        function escape(source: any) {\n          if (typeof source !== 'string') return source\n          source = source.replace(/\\$\\$/g, '@@__PLACEHOLDER__@@')\n          capture.forEach((segment, index) => {\n            if (!index || index > 9) return\n            source = source.replace(new RegExp(`\\\\$${index}`, 'g'), (segment || '').replace(/\\$/g, '@@__PLACEHOLDER__@@'))\n          })\n          return source.replace(/@@__PLACEHOLDER__@@/g, '$')\n        }\n        return {\n          command,\n          args: args.map(escape),\n          options: valueMap(options, escape),\n        }\n      }\n    }\n  })\n\n  ctx.before('attach', (session) => {\n    defineProperty(session, 'argv', ctx.bail('before-parse', session.parsed.content, session))\n    session.argv.root = true\n    session.argv.session = session\n  })\n\n  ctx.middleware((session, next) => {\n    // execute command\n    if (!session.resolve(session.argv)) return next()\n    return session.execute(session.argv, next)\n  })\n\n  function executeHelp(session: Session, name: string) {\n    if (!ctx.getCommand('help')) return\n    return session.execute({\n      name: 'help',\n      args: [name],\n    })\n  }\n\n  ctx.before('command/execute', (argv) => {\n    const { args, command, options, session } = argv\n    if (options['help'] && command._options.help) {\n      return executeHelp(session, command.name)\n    }\n\n    if (command['_actions'].length) return\n    const arg0 = args.shift() || ''\n    const subcommand = ctx.getCommand(command.name + '.' + arg0)\n    if (subcommand) {\n      return session.execute({ ...argv, command: subcommand })\n    } else {\n      return executeHelp(session, command.name)\n    }\n  })\n}\n", "import { Argv } from '../parser'\nimport { Context } from '../context'\n\nexport default function validate(ctx: Context) {\n  // add user fields\n  ctx.on('command-added', (cmd) => {\n    cmd.userFields(({ tokens, command, options = {} }, fields) => {\n      if (!command) return\n      const { authority } = command.config\n      let shouldFetchAuthority = authority > 0\n      for (const { name, authority } of Object.values(command._options)) {\n        if (name in options) {\n          if (authority > 0) shouldFetchAuthority = true\n        } else if (tokens) {\n          if (authority > 0) shouldFetchAuthority = true\n        }\n      }\n      if (shouldFetchAuthority) fields.add('authority')\n    })\n  })\n\n  // check user\n  ctx.before('command/execute', (argv: Argv<'authority'>) => {\n    const { session, options, command } = argv\n    if (!session.user) return\n\n    function sendHint(message: string, ...param: any[]) {\n      return command.config.showWarning ? session.text(message, param) : ''\n    }\n\n    // check authority\n    if (session.user.authority) {\n      const authority = command.getConfig('authority', session)\n      if (authority > session.user.authority) {\n        return sendHint('internal.low-authority')\n      }\n    }\n    for (const option of Object.values(command._options)) {\n      if (option.name in options) {\n        if (option.authority > session.user.authority) {\n          return sendHint('internal.low-authority')\n        }\n      }\n    }\n  })\n\n  // check argv\n  ctx.before('command/execute', (argv: Argv) => {\n    const { args, options, command, session } = argv\n    function sendHint(message: string, ...param: any[]) {\n      return command.config.showWarning ? session.text(message, param) : ''\n    }\n\n    // check argument count\n    if (command.config.checkArgCount) {\n      const nextArg = command._arguments[args.length] || {}\n      if (nextArg.required) {\n        return sendHint('internal.insufficient-arguments')\n      }\n      const finalArg = command._arguments[command._arguments.length - 1] || {}\n      if (args.length > command._arguments.length && finalArg.type !== 'text' && !finalArg.variadic) {\n        return sendHint('internal.redunant-arguments')\n      }\n    }\n\n    // check unknown options\n    if (command.config.checkUnknown) {\n      const unknown = Object.keys(options).filter(key => !command._options[key])\n      if (unknown.length) {\n        return sendHint('internal.unknown-option', unknown.join(', '))\n      }\n    }\n  })\n}\n", "import { distance } from 'fastest-levenshtein'\nimport { Awaitable } from '@koishijs/utils'\nimport { Context, Next } from '../context'\nimport { Session } from '../session'\nimport { getCommandNames } from './help'\n\nexport interface SuggestOptions {\n  target: string\n  items: string[]\n  next?: Next\n  prefix?: string\n  suffix: string\n  minSimilarity?: number\n  apply: (this: Session, suggestion: string, next: Next) => Awaitable<void | string>\n}\n\nexport interface SuggestConfig {\n  minSimilarity?: number\n}\n\ndeclare module '../session' {\n  interface Session {\n    suggest(options: SuggestOptions): Promise<void>\n  }\n}\n\nSession.prototype.suggest = function suggest(this: Session, options) {\n  const {\n    target,\n    items,\n    prefix = '',\n    suffix,\n    apply,\n    next = Next.compose,\n    minSimilarity = this.app.options.minSimilarity,\n  } = options\n\n  const sendNext = async (callback: Next) => {\n    const result = await next(callback)\n    if (result) await this.send(result)\n  }\n\n  let suggestions: string[], minDistance = Infinity\n  for (const name of items) {\n    const dist = distance(name, target)\n    if (name.length <= 2 || dist > name.length * minSimilarity) continue\n    if (dist === minDistance) {\n      suggestions.push(name)\n    } else if (dist < minDistance) {\n      suggestions = [name]\n      minDistance = dist\n    }\n  }\n  if (!suggestions) return sendNext(async () => prefix)\n\n  const scope = this.scope\n  return sendNext(async () => {\n    const message = prefix + this.text('suggest.hint', [suggestions.map(text => {\n      return this.text('general.quote', [text])\n    }).join(this.text('general.or'))])\n    if (suggestions.length > 1) return message\n\n    const dispose = this.middleware((session, next) => {\n      dispose()\n      const message = session.content.trim()\n      if (message && message !== '.' && message !== '。') return next()\n      return session.withScope(scope, () => {\n        return apply.call(session, suggestions[0], next)\n      })\n    })\n\n    return message + suffix\n  })\n}\n\nexport default function suggest(ctx: Context) {\n  ctx.middleware((session, next) => {\n    // use `!prefix` instead of `prefix === null` to prevent from blocking other middlewares\n    // we need to make sure that the user truly has the intension to call a command\n    const { argv, quote, subtype, parsed: { content, prefix, appel } } = session\n    if (argv.command || subtype !== 'private' && !prefix && !appel) return next()\n    const target = content.split(/\\s/, 1)[0].toLowerCase()\n    if (!target) return next()\n\n    return session.suggest({\n      target,\n      next,\n      items: getCommandNames(session),\n      prefix: session.text('suggest.command-prefix'),\n      suffix: session.text('suggest.command-suffix'),\n      async apply(suggestion, next) {\n        const newMessage = suggestion + content.slice(target.length) + (quote ? ' ' + quote.content : '')\n        return this.execute(newMessage, next)\n      },\n    })\n  })\n}\n", "import { Argv } from '../parser'\nimport { Command } from '../command'\nimport { Context } from '../context'\nimport { Channel, Tables, User } from '../database'\nimport { FieldCollector, Session } from '../session'\n\ninterface HelpOptions {\n  showHidden?: boolean\n  authority?: boolean\n}\n\nexport interface HelpConfig extends Command.Config {\n  shortcut?: boolean\n  options?: boolean\n}\n\nexport function enableHelp<U extends User.Field, G extends Channel.Field, A extends any[], O extends {}>(cmd: Command<U, G, A, O>) {\n  return cmd.option('help', '-h', {\n    hidden: true,\n    descPath: 'commands.help.options.help',\n  })\n}\n\nexport default function help(ctx: Context, config: HelpConfig = {}) {\n  if (config.options !== false) {\n    ctx.on('command-added', cmd => cmd.use(enableHelp))\n  }\n\n  const app = ctx.app\n  function findCommand(target: string) {\n    const command = app._commands.resolve(target)\n    if (command) return command\n    const shortcut = app._shortcuts.find(({ name }) => {\n      return typeof name === 'string' ? name === target : name.test(target)\n    })\n    if (shortcut) return shortcut.command\n  }\n\n  const createCollector = <T extends keyof Tables>(key: T): FieldCollector<T> => (argv, fields) => {\n    const { args: [target], session } = argv\n    const command = findCommand(target)\n    if (!command) return\n    session.collect(key, { ...argv, command, args: [], options: { help: true } }, fields)\n  }\n\n  const cmd = ctx.command('help [command:string]', { authority: 0, ...config })\n    .userFields(['authority'])\n    .userFields(createCollector('user'))\n    .channelFields(createCollector('channel'))\n    .option('authority', '-a')\n    .option('showHidden', '-H')\n    .action(async ({ session, options }, target) => {\n      if (!target) {\n        const commands = app._commandList.filter(cmd => cmd.parent === null)\n        const output = formatCommands('.global-prolog', session, commands, options)\n        const epilog = session.text('.global-epilog')\n        if (epilog) output.push(epilog)\n        return output.filter(Boolean).join('\\n')\n      }\n\n      const command = findCommand(target)\n      if (!command?.context.match(session)) {\n        return session.suggest({\n          target,\n          items: getCommandNames(session),\n          prefix: session.text('suggest.help-prefix'),\n          suffix: session.text('suggest.help-suffix'),\n          async apply(suggestion) {\n            return showHelp(ctx.getCommand(suggestion), this as any, options)\n          },\n        })\n      }\n\n      return showHelp(command, session, options)\n    })\n\n  if (config.shortcut !== false) cmd.shortcut('帮助', { fuzzy: true })\n}\n\nexport function getCommandNames(session: Session) {\n  return session.app._commandList\n    .filter(cmd => cmd.match(session) && !cmd.config.hidden)\n    .flatMap(cmd => cmd._aliases)\n}\n\nfunction* getCommands(session: Session<'authority'>, commands: Command[], showHidden = false): Generator<Command> {\n  for (const command of commands) {\n    if (!showHidden && command.config.hidden) continue\n    if (command.match(session)) {\n      yield command\n    } else {\n      yield* getCommands(session, command.children, showHidden)\n    }\n  }\n}\n\nfunction formatCommands(path: string, session: Session<'authority'>, children: Command[], options: HelpOptions) {\n  const commands = Array\n    .from(getCommands(session, children, options.showHidden))\n    .sort((a, b) => a.displayName > b.displayName ? 1 : -1)\n  if (!commands.length) return []\n\n  let hasSubcommand = false\n  const output = commands.map(({ name, displayName, config, children }) => {\n    let output = '    ' + displayName\n    if (options.authority) {\n      output += ` (${config.authority}${children.length ? (hasSubcommand = true, '*') : ''})`\n    }\n    output += '  ' + session.text([`commands.${name}.description`, ''])\n    return output\n  })\n  const hints: string[] = []\n  if (options.authority) hints.push(session.text('.hint-authority'))\n  if (hasSubcommand) hints.push(session.text('.hint-subcommand'))\n  const hintText = hints.length\n    ? session.text('general.paren', [hints.join(session.text('general.comma'))])\n    : ''\n  output.unshift(session.text(path, [hintText]))\n  return output\n}\n\nfunction getOptionVisibility(option: Argv.OptionDeclaration, session: Session<'authority'>) {\n  if (session.user && option.authority > session.user.authority) return false\n  return !session.resolveValue(option.hidden)\n}\n\nfunction getOptions(command: Command, session: Session<'authority'>, config: HelpOptions) {\n  if (command.config.hideOptions && !config.showHidden) return []\n  const options = config.showHidden\n    ? Object.values(command._options)\n    : Object.values(command._options).filter(option => getOptionVisibility(option, session))\n  if (!options.length) return []\n\n  const output = config.authority && options.some(o => o.authority)\n    ? [session.text('.available-options-with-authority')]\n    : [session.text('.available-options')]\n\n  options.forEach((option) => {\n    const authority = option.authority && config.authority ? `(${option.authority}) ` : ''\n    let line = `${authority}${option.syntax}`\n    const description = session.text(option.descPath ?? [`commands.${command.name}.options.${option.name}`, ''])\n    if (description) line += '  ' + description\n    line = command.app.chain('help/option', line, option, command, session)\n    output.push('    ' + line)\n  })\n\n  return output\n}\n\nasync function showHelp(command: Command, session: Session<'authority'>, config: HelpOptions) {\n  const output = [command.displayName + command.declaration]\n\n  const description = session.text([`commands.${command.name}.description`, ''])\n  if (description) output.push(description)\n\n  if (session.app.database) {\n    const argv: Argv = { command, args: [], options: { help: true } }\n    const userFields = session.collect('user', argv)\n    await session.observeUser(userFields)\n    if (session.subtype === 'group') {\n      const channelFields = session.collect('channel', argv)\n      await session.observeChannel(channelFields)\n    }\n  }\n\n  if (command._aliases.length > 1) {\n    output.push(session.text('.command-aliases', [Array.from(command._aliases.slice(1)).join('，')]))\n  }\n\n  session.app.emit(session, 'help/command', output, command, session)\n\n  if (session.user && command.config.authority > 1) {\n    output.push(session.text('.command-authority', [command.config.authority]))\n  }\n\n  if (command._usage) {\n    output.push(typeof command._usage === 'string' ? command._usage : await command._usage(session))\n  } else {\n    const text = session.text([`commands.${command.name}.usage`, ''])\n    if (text) output.push(text)\n  }\n\n  output.push(...getOptions(command, session, config))\n\n  if (command._examples.length) {\n    output.push(session.text('.command-examples'), ...command._examples.map(example => '    ' + example))\n  } else {\n    const text = session.text([`commands.${command.name}.examples`, ''])\n    if (text) output.push(...text.split('\\n').map(line => '    ' + line))\n  }\n\n  output.push(...formatCommands('.subcommand-prolog', session, command.children, config))\n\n  return output.filter(Boolean).join('\\n')\n}\n"],
  "mappings": "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",
  "names": []
}
