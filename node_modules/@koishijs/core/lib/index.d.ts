import * as utils from '@koishijs/utils';
import { Dict, Awaitable, Schema, Logger, MaybeArray, Promisify, Get } from '@koishijs/utils';
import { Driver, Model, Modifier, Result, Update } from '@koishijs/orm';
export interface Token {
    rest?: string;
    content: string;
    quoted: boolean;
    terminator: string;
    inters: Argv[];
}
export interface Argv<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O = {}> {
    args?: A;
    options?: O;
    error?: string;
    source?: string;
    initiator?: string;
    terminator?: string;
    session?: Session<U, G>;
    command?: Command<U, G, A, O>;
    rest?: string;
    pos?: number;
    root?: boolean;
    tokens?: Token[];
    name?: string;
    next?: Next;
}
export namespace Argv {
    export interface Interpolation {
        terminator?: string;
        parse?(source: string): Argv;
    }
    export function interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv): void;
    export class Tokenizer {
        private bracs;
        constructor();
        interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv): void;
        parseToken(source: string, stopReg?: string): Token;
        parse(source: string, terminator?: string): Argv;
        stringify(argv: Argv): string;
    }
    export function parse(source: string, terminator?: string): Argv<never, never, any[], {}>;
    export function stringify(argv: Argv): string;
    export function revert(token: Token): void;
    export interface Domain {
        string: string;
        number: number;
        boolean: boolean;
        text: string;
        rawtext: string;
        user: string;
        channel: string;
        integer: number;
        posint: number;
        natural: number;
        date: Date;
    }
    type DomainType = keyof Domain;
    type ParamType<S extends string, F> = S extends `${any}:${infer T}` ? T extends DomainType ? Domain[T] : F : F;
    type Replace<S extends string, X extends string, Y extends string> = S extends `${infer L}${X}${infer R}` ? `${L}${Y}${Replace<R, X, Y>}` : S;
    type ExtractAll<S extends string, F> = S extends `${infer L}]${infer R}` ? [ParamType<L, F>, ...ExtractAll<R, F>] : [];
    type ExtractFirst<S extends string, F> = S extends `${infer L}]${any}` ? ParamType<L, F> : boolean;
    type ExtractSpread<S extends string> = S extends `${infer L}...${infer R}` ? [...ExtractAll<L, string>, ...ExtractFirst<R, string>[]] : [...ExtractAll<S, string>, ...string[]];
    export type ArgumentType<S extends string> = ExtractSpread<Replace<S, '>', ']'>>;
    export type OptionType<S extends string> = ExtractFirst<Replace<S, '>', ']'>, any>;
    export type Type = DomainType | RegExp | string[] | Transform<any>;
    export interface Declaration {
        name?: string;
        type?: Type;
        fallback?: any;
        variadic?: boolean;
        required?: boolean;
    }
    export type Transform<T> = (source: string, session: Session) => T;
    export interface DomainConfig<T> {
        transform?: Transform<T>;
        greedy?: boolean;
    }
    export function createDomain<K extends keyof Domain>(name: K, transform: Transform<Domain[K]>, options?: DomainConfig<Domain[K]>): void;
    export function parseValue(source: string, quoted: boolean, kind: string, argv: Argv, decl?: Declaration): any;
    export interface OptionConfig<T extends Type = Type> {
        value?: any;
        fallback?: any;
        type?: T;
        /** hide the option by default */
        hidden?: boolean | ((session: Session) => boolean);
        authority?: number;
        notUsage?: boolean;
        descPath?: string;
    }
    export interface TypedOptionConfig<T extends Type> extends OptionConfig<T> {
        type: T;
    }
    export interface OptionDeclaration extends Declaration, OptionConfig {
        syntax: string;
        values?: Dict<any>;
    }
    type OptionDeclarationMap = Dict<OptionDeclaration>;
    export class CommandBase {
        readonly name: string;
        context: Context;
        declaration: string;
        _arguments: Declaration[];
        _options: OptionDeclarationMap;
        private _namedOptions;
        private _symbolicOptions;
        constructor(name: string, declaration: string, context: Context);
        _createOption(name: string, def: string, config: OptionConfig): void;
        private _assignOption;
        removeOption<K extends string>(name: K): boolean;
        parse(argv: Argv): Argv;
        parse(source: string, terminator?: string, args?: any[], options?: Dict<any>): Argv;
        private stringifyArg;
        stringify(args: readonly string[], options: any): string;
    }
}
export interface HelpConfig extends Command.Config {
    shortcut?: boolean;
    options?: boolean;
}
export function enableHelp<U extends User.Field, G extends Channel.Field, A extends any[], O extends {}>(cmd: Command<U, G, A, O>): Command<U, G, A, Extend<O, "help", boolean>>;
export function getCommandNames(session: Session): string[];
export interface SuggestOptions {
    target: string;
    items: string[];
    next?: Next;
    prefix?: string;
    suffix: string;
    minSimilarity?: number;
    apply: (this: Session, suggestion: string, next: Next) => Awaitable<void | string>;
}
export interface SuggestConfig {
    minSimilarity?: number;
}
export interface Session {
    suggest(options: SuggestOptions): Promise<void>;
}
declare namespace internal {
}
export type Extend<O extends {}, K extends string, T> = {
    [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown);
};
export namespace Command {
    interface Shortcut {
        name?: string | RegExp;
        command?: Command;
        prefix?: boolean;
        fuzzy?: boolean;
        args?: string[];
        options?: Dict;
    }
    type Action<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> = (argv: Argv<U, G, A, O>, ...args: A) => Awaitable<void | string>;
    type Usage<U extends User.Field = never, G extends Channel.Field = never> = string | ((session: Session<U, G>) => Awaitable<string>);
}
export class Command<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> extends Argv.CommandBase {
    config: Command.Config;
    children: Command[];
    parent: Command;
    _aliases: string[];
    _examples: string[];
    _usage?: Command.Usage;
    _disposed?: boolean;
    _disposables?: Disposable[];
    private _userFields;
    private _channelFields;
    private _actions;
    private _checkers;
    static enableHelp: typeof internal.enableHelp;
    static defaultConfig: Command.Config;
    static defaultOptionConfig: Argv.OptionConfig;
    private static _userFields;
    private static _channelFields;
    /** @deprecated use `command-added` event instead */
    static userFields(fields: FieldCollector<'user'>): typeof Command;
    /** @deprecated use `command-added` event instead */
    static channelFields(fields: FieldCollector<'channel'>): typeof Command;
    constructor(name: string, decl: string, context: Context);
    get app(): App;
    get displayName(): string;
    set displayName(name: string);
    private _registerAlias;
    userFields<T extends User.Field = never>(fields: FieldCollector<'user', T, A, O>): Command<U | T, G, A, O>;
    channelFields<T extends Channel.Field = never>(fields: FieldCollector<'channel', T, A, O>): Command<U, G | T, A, O>;
    alias(...names: string[]): this;
    shortcut(name: string | RegExp, config?: Command.Shortcut): this;
    subcommand<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    usage(text: Command.Usage<U, G>): this;
    example(example: string): this;
    option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<U, G, A, Extend<O, K, string>>;
    option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<U, G, A, Extend<O, K, R>>;
    option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<U, G, A, Extend<O, K, R>>;
    option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<U, G, A, Extend<O, K, Argv.OptionType<D>>>;
    match(session: Session): boolean;
    getConfig<K extends keyof Command.Config>(key: K, session: Session): Exclude<Command.Config[K], (session: Session) => any>;
    check(callback: Command.Action<U, G, A, O>, append?: boolean): this;
    before(callback: Command.Action<U, G, A, O>, append?: boolean): this;
    action(callback: Command.Action<U, G, A, O>, prepend?: boolean): this;
    use<T extends Command, R extends any[]>(callback: (command: this, ...args: R) => T, ...args: R): T;
    execute(argv: Argv<U, G, A, O>, fallback?: typeof Next.compose): Promise<string>;
    dispose(): void;
}
export namespace Command {
    interface Config {
        /** hide all options by default */
        hideOptions?: boolean;
        /** hide command */
        hidden?: boolean;
        /** min authority */
        authority?: Computed<number>;
        /** disallow unknown options */
        checkUnknown?: boolean;
        /** check argument count */
        checkArgCount?: boolean;
        /** show command warnings */
        showWarning?: boolean;
        /** depend on existing commands */
        patch?: boolean;
    }
    const Config: Schema<Config>;
}
export namespace I18n {
    type Template = string | {
        $: string;
    };
    type Node = Template | Store;
    interface Store {
        [K: string]: Node;
    }
    type Formatter = (value: any, args: string[], locale: string) => string;
    type Renderer = (dict: Dict, params: any, locale: string) => string;
}
export class I18n {
    protected ctx: Context;
    _data: Dict<Dict<I18n.Template>>;
    _formatters: Dict<I18n.Formatter>;
    _renderers: Dict<I18n.Renderer>;
    static isTemplate(data: any): data is I18n.Template;
    constructor(ctx: Context);
    private set;
    define(locale: string, dict: I18n.Store): void;
    define(locale: string, key: string, value: I18n.Node): void;
    formatter(name: string, callback: I18n.Formatter): void;
    renderer(name: string, callback: I18n.Renderer): void;
    render(value: I18n.Template, params: any, locale: string): string;
    text(locales: Iterable<string>, paths: string[], params: object): string;
}
export interface CommandMap extends Map<string, Command> {
    resolve(key: string): Command;
}
export class App extends Context {
    _commandList: Command[];
    _commands: CommandMap;
    _shortcuts: Command.Shortcut[];
    _tasks: TaskQueue;
    _hooks: Record<keyof any, [Context, (...args: any[]) => any][]>;
    _sessions: Dict<Session>;
    _userCache: SharedCache<User.Observed<any>>;
    _channelCache: SharedCache<Channel.Observed<any>>;
    app: this;
    options: App.Config;
    isActive: boolean;
    registry: Plugin.Registry;
    private _nameRE;
    constructor(options?: App.Config);
    prepare(): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    private _resolvePrefixes;
    private _process;
    private _handleMessage;
}
export namespace App {
    interface DelayConfig {
        character?: number;
        message?: number;
        cancel?: number;
        broadcast?: number;
        prompt?: number;
    }
    interface Config extends Config.Basic, Config.Features, Config.Advanced {
    }
    namespace Config {
        interface Basic extends SuggestConfig {
            locale?: string;
            prefix?: Computed<string | string[]>;
            nickname?: string | string[];
            autoAssign?: Computed<Awaitable<boolean>>;
            autoAuthorize?: Computed<Awaitable<number>>;
        }
        interface Features {
            help?: false | HelpConfig;
            delay?: DelayConfig;
        }
        interface Advanced {
            maxListeners?: number;
            prettyErrors?: boolean;
        }
        interface Static extends Schema<Config> {
            Basic: Schema<Basic>;
            Features: Schema<Features>;
            Advanced: Schema<Advanced>;
        }
    }
    const Config: Config.Static;
}
export function defineConfig(config: App.Config): App.Config;
declare class TaskQueue {
    #private;
    queue(value: any): void;
    flush(): Promise<void>;
}
export namespace SharedCache {
    interface Entry<T> {
        value: T;
        key: string;
        refs: Set<string>;
    }
}
export class SharedCache<T> {
    #private;
    get(ref: string, key: string): T;
    set(ref: string, key: string, value: T): void;
    delete(ref: string): void;
}
export interface Bot extends Bot.BaseConfig, Bot.Methods, Bot.UserBase {
}
export abstract class Bot<T extends Bot.BaseConfig = Bot.BaseConfig> {
    adapter: Adapter;
    config: T;
    app: App;
    platform: string;
    hidden?: boolean;
    internal?: any;
    selfId?: string;
    logger: Logger;
    id: string;
    private _status;
    error?: Error;
    constructor(adapter: Adapter, config: T);
    private extendModel;
    get status(): Bot.Status;
    set status(value: Bot.Status);
    resolve(): void;
    reject(error: Error): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    get sid(): string;
    /** @deprecated using `bot.session()` instead */
    createSession(session: Partial<Session>): Session<never, never>;
    session(data: Partial<Session>): Promise<Session<never, never>>;
    getGuildMemberMap(guildId: string): Promise<{
        [k: string]: string;
    }>;
    broadcast(channels: (string | [string, string])[], content: string, delay?: number): Promise<string[]>;
}
export namespace Bot {
    const library: Dict<Bot.Constructor>;
    interface BaseConfig {
        disabled?: boolean;
        protocol?: string;
        platform?: string;
    }
    interface Constructor<S extends Bot.BaseConfig = Bot.BaseConfig> {
        new (adapter: Adapter, config: S): Bot<S>;
        schema?: Schema;
    }
    type Status = 'offline' | 'online' | 'connect' | 'disconnect' | 'reconnect';
    interface Methods {
        sendMessage(channelId: string, content: string, guildId?: string): Promise<string[]>;
        sendPrivateMessage(userId: string, content: string): Promise<string[]>;
        getMessage(channelId: string, messageId: string): Promise<Message>;
        editMessage(channelId: string, messageId: string, content: string): Promise<void>;
        deleteMessage(channelId: string, messageId: string): Promise<void>;
        getSelf(): Promise<User>;
        getUser(userId: string): Promise<User>;
        getFriendList(): Promise<User[]>;
        deleteFriend(userId: string): Promise<void>;
        getGuild(guildId: string): Promise<Guild>;
        getGuildList(): Promise<Guild[]>;
        getGuildMember(guildId: string, userId: string): Promise<GuildMember>;
        getGuildMemberList(guildId: string): Promise<GuildMember[]>;
        getChannel(channelId: string, guildId?: string): Promise<Channel>;
        getChannelList(guildId: string): Promise<Channel[]>;
        handleFriendRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
        handleGuildRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
        handleGuildMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
    }
    interface Channel {
        channelId: string;
        channelName?: string;
    }
    interface Guild {
        guildId: string;
        guildName?: string;
    }
    interface UserBase {
        username?: string;
        nickname?: string;
        avatar?: string;
        discriminator?: string;
        isBot?: boolean;
    }
    interface User extends UserBase {
        userId: string;
    }
    interface GuildMember extends User {
        roles?: string[];
    }
    interface Author extends GuildMember {
        anonymous?: string;
    }
    interface Role {
        id: string;
    }
    interface MessageBase {
        messageId?: string;
        channelId?: string;
        guildId?: string;
        userId?: string;
        content?: string;
        timestamp?: number;
        author?: Author;
        quote?: Message;
    }
    interface Message extends MessageBase {
        subtype?: 'private' | 'group';
    }
}
export type Next = (next?: Next.Callback) => Promise<void | string>;
export type Middleware = (session: Session, next: Next) => Awaitable<void | string>;
export type Disposable = () => void;
export namespace Next {
    const MAX_DEPTH = 64;
    type Queue = ((next?: Next) => Promise<void | string>)[];
    type Callback = void | string | ((next?: Next) => Awaitable<void | string>);
    function compose(callback: Callback, next?: Next): Promise<string | void>;
}
export type Plugin = Plugin.Function | Plugin.Object;
export namespace Plugin {
    type Function<T = any> = (ctx: Context, options: T) => void;
    type Constructor<T = any> = new (ctx: Context, options: T) => void;
    interface Object<T = any> {
        name?: string;
        apply: Function<T>;
        Config?: Schema;
        using?: readonly (keyof Context.Services)[];
    }
    interface ObjectWithSchema<T = any> {
        name?: string;
        apply: Function;
        schema?: Schema<T, any>;
        using?: readonly (keyof Context.Services)[];
    }
    type Config<T extends Plugin> = T extends Constructor<infer U> ? U : T extends Function<infer U> ? U : T extends ObjectWithSchema<infer U> ? U : T extends Object<infer U> ? U : never;
    interface State {
        id: string;
        parent: Context;
        context?: Context;
        config?: any;
        using: readonly (keyof Context.Services)[];
        schema?: Schema;
        plugin?: Plugin;
        children: Plugin[];
        disposables: Disposable[];
    }
    class Registry extends Map<Plugin, State> {
        private resolve;
        get(plugin: Plugin): State;
        set(plugin: Plugin, state: State): this;
        has(plugin: Plugin): boolean;
        delete(plugin: Plugin): boolean;
    }
}
declare const selectors: readonly ["user", "guild", "channel", "self", "private", "platform"];
export type Filter = (session: Session) => boolean;
export type SelectorType = typeof selectors[number];
export type SelectorValue = boolean | MaybeArray<string | number>;
export type BaseSelection = {
    [K in SelectorType as `$${K}`]?: SelectorValue;
};
export interface Selection extends BaseSelection {
    $and?: Selection[];
    $or?: Selection[];
    $not?: Selection;
}
export interface Context extends Context.Services {
}
export class Context {
    filter: Filter;
    app?: App;
    private _plugin;
    static readonly middleware: unique symbol;
    static readonly current: unique symbol;
    protected constructor(filter: Filter, app?: App, _plugin?: Plugin);
    private _property;
    user(...values: string[]): Context;
    self(...values: string[]): Context;
    guild(...values: string[]): Context;
    channel(...values: string[]): Context;
    platform(...values: string[]): Context;
    private(...values: string[]): Context;
    select(options: Selection): Context;
    logger(name: string): Logger;
    any(): Context;
    never(): Context;
    union(arg: Filter | Context): Context;
    intersect(arg: Filter | Context): Context;
    exclude(arg: Filter | Context): Context;
    /** @deprecated use `ctx.exclude()` instead */
    except(arg: Filter | Context): Context;
    match(session?: Session): boolean;
    get state(): Plugin.State;
    using(using: readonly (keyof Context.Services)[], callback: Plugin.Function<void>): this;
    validate<T extends Plugin>(plugin: T, config: any): any;
    plugin(name: string, config?: any): this;
    plugin<T extends Plugin>(plugin: T, config?: boolean | Plugin.Config<T>): this;
    dispose(plugin?: Plugin): Plugin.State;
    getHooks(name: EventName, session?: Session): Generator<(...args: any[]) => any, void, unknown>;
    parallel<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promise<void>;
    parallel<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promise<void>;
    emit<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): void;
    emit<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): void;
    waterfall<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>;
    waterfall<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>;
    chain<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>;
    chain<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>;
    serial<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>;
    serial<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>;
    bail<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>;
    bail<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>;
    on<K extends EventName>(name: K, listener: EventMap[K], prepend?: boolean): () => boolean;
    before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append?: boolean): () => boolean;
    once<K extends EventName>(name: K, listener: EventMap[K], prepend?: boolean): () => boolean;
    off<K extends EventName>(name: K, listener: EventMap[K]): boolean;
    middleware(middleware: Middleware, prepend?: boolean): () => boolean;
    private createTimerDispose;
    setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean;
    setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean;
    getCommand(name: string): Command<never, never, any[], {}>;
    command<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    command<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    getSelfIds(type?: string, assignees?: string[]): Dict<string[]>;
    broadcast(content: string, forced?: boolean): Promise<string[]>;
    broadcast(channels: readonly string[], content: string, forced?: boolean): Promise<string[]>;
}
export namespace Context {
    interface Services {
        bots: Adapter.BotList;
        database: Database;
        model: ModelService;
        i18n: I18n;
    }
    const Services: (keyof Services)[];
    function service(key: keyof Services): void;
    const deprecatedEvents: Dict<EventName & string>;
}
type EventName = keyof EventMap;
type OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never;
type BeforeEventName = OmitSubstring<EventName & string, 'before-'>;
export type BeforeEventMap = {
    [E in EventName & string as OmitSubstring<E, 'before-'>]: EventMap[E];
};
export interface EventMap {
    [Context.middleware]: Middleware;
    'appellation'(name: string, session: Session): string;
    'before-parse'(content: string, session: Session): Argv;
    'before-attach-channel'(session: Session, fields: Set<Channel.Field>): void;
    'attach-channel'(session: Session): Awaitable<void | boolean>;
    'before-attach-user'(session: Session, fields: Set<User.Field>): void;
    'attach-user'(session: Session): Awaitable<void | boolean>;
    'before-attach'(session: Session): void;
    'attach'(session: Session): void;
    'before-send'(session: Session): Awaitable<void | boolean>;
    'command-added'(command: Command): void;
    'command-removed'(command: Command): void;
    'command-error'(argv: Argv, error: any): void;
    'command/before-execute'(argv: Argv): Awaitable<void | string>;
    'command/before-attach-channel'(argv: Argv, fields: Set<Channel.Field>): void;
    'command/before-attach-user'(argv: Argv, fields: Set<User.Field>): void;
    'middleware'(session: Session): void;
    'help/command'(output: string[], command: Command, session: Session): void;
    'help/option'(output: string, option: Argv.OptionDeclaration, command: Command, session: Session): string;
    'plugin-added'(state: Plugin.State): void;
    'plugin-removed'(state: Plugin.State): void;
    'ready'(): Awaitable<void>;
    'dispose'(): Awaitable<void>;
    'model'(name: keyof Tables): void;
    'service'(name: keyof Context.Services): void;
    'adapter'(name: string): void;
    'bot-added'(bot: Bot): void;
    'bot-removed'(bot: Bot): void;
    'bot-status-updated'(bot: Bot): void;
    'bot-connect'(bot: Bot): Awaitable<void>;
    'bot-disconnect'(bot: Bot): Awaitable<void>;
    'connect'(): Awaitable<void>;
    'disconnect'(): Awaitable<void>;
    'before-command'(argv: Argv): Awaitable<void | string>;
}
export interface User {
    id: string;
    flag: number;
    authority: number;
    name: string;
    locale: string;
}
export namespace User {
    enum Flag {
        ignore = 1
    }
    type Field = keyof User;
    const fields: Field[];
    type Observed<K extends Field = Field> = utils.Observed<Pick<User, K>, Promise<void>>;
}
export interface Channel {
    id: string;
    platform: string;
    flag: number;
    assignee: string;
    guildId: string;
    locale: string;
}
export namespace Channel {
    enum Flag {
        ignore = 1,
        silent = 4
    }
    type Field = keyof Channel;
    const fields: Field[];
    type Observed<K extends Field = Field> = utils.Observed<Pick<Channel, K>, Promise<void>>;
}
export interface Tables {
    user: User;
    channel: Channel;
}
export class ModelService extends Model<Tables> {
    protected ctx: Context;
    constructor(ctx: Context);
    extend<K extends keyof Tables>(name: K, fields?: Model.Field.Extension<Tables[K]>, extension?: Model.Extension<Tables[K]>): void;
}
export abstract class Service {
    protected ctx: Context;
    name: keyof Context.Services;
    immediate?: boolean;
    protected start(): Awaitable<void>;
    protected stop(): Awaitable<void>;
    constructor(ctx: Context, name: keyof Context.Services, immediate?: boolean);
    get caller(): Context;
}
export abstract class Database extends Driver<Tables> {
    protected ctx: Context;
    protected start(): Awaitable<void>;
    protected stop(): Awaitable<void>;
    constructor(ctx: Context);
    getUser<T extends string, K extends User.Field>(platform: T, id: string, modifier?: Modifier<K>): Promise<Result<User, K> & Record<T, string>>;
    getUser<T extends string, K extends User.Field>(platform: T, ids: string[], modifier?: Modifier<K>): Promise<Result<User, K>[]>;
    setUser(platform: string, id: string, data: Update<User>): Promise<void>;
    createUser(platform: string, id: string, data: Partial<User>): Promise<User>;
    getChannel<K extends Channel.Field>(platform: string, id: string, modifier?: Modifier<K>): Promise<Result<Channel, K | 'id' | 'platform'>>;
    getChannel<K extends Channel.Field>(platform: string, ids: string[], modifier?: Modifier<K>): Promise<Result<Channel, K>[]>;
    getAssignedChannels<K extends Channel.Field>(fields?: K[], assignMap?: Dict<string[]>): Promise<Result<Channel, K>[]>;
    setChannel(platform: string, id: string, data: Update<Channel>): Promise<void>;
    createChannel(platform: string, id: string, data: Partial<Channel>): Promise<Channel>;
}
export namespace Database {
    type Methods<S, T> = {
        [K in keyof S]?: S[K] extends (...args: infer R) => infer U ? (this: T, ...args: R) => U : S[K];
    };
    type Constructor<T> = new (...args: any[]) => T;
    type ExtensionMethods<T> = Methods<Database, T extends Constructor<infer I> ? I : never>;
    type Extension<T> = ((Database: T) => void) | ExtensionMethods<T>;
    /** @deprecated */
    export function extend<K extends keyof Modules>(module: K, extension: Extension<Get<Modules[K], 'default'>>): void;
    export function extend<T extends Constructor<unknown>>(module: T, extension: Extension<T>): void;
}
export function unwrapExports(module: any): any;
export interface Modules {
}
export namespace Modules {
    function define(name: string, value: any): void;
    namespace internal {
        function require(name: string): any;
        function resolve(name: string): string;
        function paths(name: string): string[];
    }
    function require(name: string, forced?: boolean): any;
    function resolve(name: string): string;
}
type Genres = 'friend' | 'channel' | 'group' | 'group-member' | 'group-role' | 'group-file' | 'group-emoji';
type Actions = 'added' | 'deleted' | 'updated';
type SessionEventCallback = (session: Session) => void;
export interface EventMap extends Record<`${Genres}-${Actions}`, SessionEventCallback> {
    'message': SessionEventCallback;
    'message-deleted': SessionEventCallback;
    'message-updated': SessionEventCallback;
    'reaction-added': SessionEventCallback;
    'reaction-deleted': SessionEventCallback;
    'reaction-deleted/one': SessionEventCallback;
    'reaction-deleted/all': SessionEventCallback;
    'reaction-deleted/emoji': SessionEventCallback;
    'send': SessionEventCallback;
    'friend-request': SessionEventCallback;
    'guild-request': SessionEventCallback;
    'guild-member-request': SessionEventCallback;
    'group-member/role': SessionEventCallback;
    'group-member/ban': SessionEventCallback;
    'group-member/nickname': SessionEventCallback;
    'notice/poke': SessionEventCallback;
    'notice/lucky-king': SessionEventCallback;
    'notice/honor': SessionEventCallback;
    'notice/honor/talkative': SessionEventCallback;
    'notice/honor/performer': SessionEventCallback;
    'notice/honor/emotion': SessionEventCallback;
}
export interface Session extends Session.Payload {
}
export namespace Session {
    interface Payload {
        platform?: string;
        selfId: string;
        type?: string;
        subtype?: string;
        messageId?: string;
        channelId?: string;
        guildId?: string;
        userId?: string;
        content?: string;
        timestamp?: number;
        author?: Bot.Author;
        quote?: Bot.Message;
        channelName?: string;
        guildName?: string;
        operatorId?: string;
        targetId?: string;
        duration?: number;
        file?: FileInfo;
    }
}
export interface Parsed {
    content: string;
    prefix: string;
    appel: boolean;
}
export type Computed<T> = T | ((session: Session) => T);
export class Session<U extends User.Field = never, G extends Channel.Field = never> {
    type?: string;
    subtype?: string;
    subsubtype?: string;
    scope?: string;
    bot: Bot;
    app: App;
    selfId: string;
    operatorId?: string;
    targetId?: string;
    duration?: number;
    file?: FileInfo;
    id: string;
    platform?: string;
    argv?: Argv<U, G>;
    user?: User.Observed<U>;
    channel?: Channel.Observed<G>;
    guild?: Channel.Observed<G>;
    parsed?: Parsed;
    private _delay?;
    private _queued;
    private _hooks;
    private _promise;
    constructor(bot: Bot, session: Partial<Session.Payload>);
    get uid(): string;
    get gid(): string;
    get cid(): string;
    get sid(): string;
    toJSON(): Session.Payload;
    private _preprocess;
    preprocess(): Promise<string>;
    get username(): string;
    send(content: string): Promise<string[]>;
    cancelQueued(delay?: number): void;
    sendQueued(content: string, delay?: number): Promise<void>;
    resolveValue<T>(source: T | ((session: Session) => T)): T;
    getChannel<K extends Channel.Field = never>(id?: string, fields?: K[]): Promise<Result<Channel, "id" | "platform" | K, (...args: any) => any>>;
    /** 在当前会话上绑定一个可观测频道实例 */
    _observeChannelLike<T extends Channel.Field = never>(channelId: string, fields?: Iterable<T>): Promise<Channel.Observed<any>>;
    observeChannel<T extends Channel.Field = never>(fields?: Iterable<T>): Promise<Channel.Observed<T | G>>;
    getUser<K extends User.Field = never>(id?: string, fields?: K[]): Promise<User | {
        [x: string]: string;
    }>;
    /** 在当前会话上绑定一个可观测用户实例 */
    observeUser<T extends User.Field = never>(fields?: Iterable<T>): Promise<User.Observed<T | U>>;
    withScope<T>(scope: string, callback: () => T): Promise<T extends Promise<infer S> ? S : T>;
    text(path: string | string[], params?: object): string;
    collect<T extends 'user' | 'channel'>(key: T, argv: Argv, fields?: Set<keyof Tables[T]>): Set<keyof Tables[T]>;
    private inferCommand;
    resolve(argv: Argv): Command<never, never, any[], {}>;
    execute(content: string, next?: true | Next): Promise<string>;
    execute(argv: Argv, next?: true | Next): Promise<string>;
    middleware(middleware: Middleware): () => boolean;
    prompt(timeout?: number): Promise<string>;
}
export function getSessionId(session: Session): string;
export type FieldCollector<T extends keyof Tables, K = keyof Tables[T], A extends any[] = any[], O = {}> = Iterable<K> | ((argv: Argv<never, never, A, O>, fields: Set<keyof Tables[T]>) => void);
export interface FileInfo {
    id: string;
    name: string;
    size: number;
    busid: number;
}
export abstract class Adapter<S extends Bot.BaseConfig = Bot.BaseConfig, T = {}> {
    ctx: Context;
    config: T;
    bots: Bot<S>[];
    platform: string;
    protected abstract start(): Awaitable<void>;
    protected abstract stop(): Awaitable<void>;
    constructor(ctx: Context, config: T);
    connect(bot: Bot): Awaitable<void>;
    disconnect(bot: Bot): Awaitable<void>;
    dispatch(session: Session): void;
}
export namespace Adapter {
    interface Constructor<T extends Bot.BaseConfig = Bot.BaseConfig, S = any> {
        new (ctx: Context, options?: S): Adapter<T>;
        [redirect]?(bot: any): string;
        schema?: Schema;
    }
    const redirect: unique symbol;
    const library: Dict<Constructor>;
    const configMap: Dict;
    type BotConfig<R> = R & {
        bots?: R[];
    };
    type PluginConfig<S = any, R = any> = S & BotConfig<R>;
    function join(platform: string, protocol: string): string;
    function define<T extends Bot.BaseConfig, S>(platform: string, bot: Bot.Constructor<T>, adapter: Constructor<T, S>): Plugin.Object<PluginConfig<S, T>>;
    function define<T extends Bot.BaseConfig, S, K extends string>(platform: string, bot: Bot.Constructor<T>, adapters: Record<K, Constructor<T, S>>, redirect?: (config: T) => K): Plugin.Object<PluginConfig<S, T>>;
    class BotList extends Array<Bot> {
        private app;
        adapters: Dict<Adapter>;
        constructor(app: App);
        get(sid: string): Bot<Bot.BaseConfig>;
        create<T extends Bot>(platform: string, options: any, constructor?: new (adapter: Adapter, config: any) => T): T;
        remove(id: string): Promise<void>;
        private resolve;
    }
}
export * from '@koishijs/utils';
export * from '@koishijs/orm';
export const version: string;
