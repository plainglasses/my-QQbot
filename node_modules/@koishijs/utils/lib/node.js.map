{
  "version": 3,
  "sources": ["../src/index.ts", "../src/logger/node.ts", "../src/time.ts", "../src/misc.ts", "../src/observe.ts", "../src/random.ts", "../src/string.ts"],
  "sourcesContent": ["import segment from '@koishijs/segment'\n\nexport { segment, segment as s }\n\nexport * from './logger'\nexport * from './misc'\nexport * from './observe'\nexport * from './random'\nexport * from './string'\nexport * from './time'\n", "import { format, inspect } from 'util'\nimport { stderr } from 'supports-color'\nimport { Time } from '../time'\nimport { Dict } from '../misc'\n\nconst c16 = [6, 2, 3, 4, 5, 1]\nconst c256 = [\n  20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,\n  63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113,\n  129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,\n  169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,\n  201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,\n]\n\nexport namespace Logger {\n  export interface LevelConfig {\n    base: number\n    [K: string]: Level\n  }\n\n  export type Level = number | LevelConfig\n  export type Function = (format: any, ...param: any[]) => void\n  export type Type = 'success' | 'error' | 'info' | 'warn' | 'debug'\n\n  export interface Target {\n    colors?: number\n    showDiff?: boolean\n    showTime?: string\n    print(text: string): void\n  }\n}\n\nexport interface Logger extends Record<Logger.Type, Logger.Function> {\n}\n\nexport class Logger {\n  // log levels\n  static readonly SILENT = 0\n  static readonly SUCCESS = 1\n  static readonly ERROR = 1\n  static readonly INFO = 2\n  static readonly WARN = 2\n  static readonly DEBUG = 3\n\n  // global config\n  static timestamp = 0\n  static colors = stderr ? stderr.has256 ? c256 : c16 : []\n  static instances: Dict<Logger> = {}\n\n  static targets: Logger.Target[] = [{\n    colors: stderr && stderr.level,\n    print(text: string) {\n      process.stderr.write(text + '\\n')\n    },\n  }]\n\n  static formatters: Dict<(value: any, target: Logger.Target, logger: Logger) => string> = {\n    c: (value, target, logger) => Logger.color(target, logger.code, value),\n    C: (value, target) => Logger.color(target, 15, value, ';1'),\n    o: (value, target) => inspect(value, { colors: !!target.colors }).replace(/\\s*\\n\\s*/g, ' '),\n  }\n\n  static levels: Logger.LevelConfig = {\n    base: 2,\n  }\n\n  static color(target: Logger.Target, code: number, value: any, decoration = '') {\n    if (!target.colors) return '' + value\n    return `\\u001b[3${code < 8 ? code : '8;5;' + code}${target.colors >= 2 ? decoration : ''}m${value}\\u001b[0m`\n  }\n\n  static code(name: string) {\n    let hash = 0\n    for (let i = 0; i < name.length; i++) {\n      hash = ((hash << 3) - hash) + name.charCodeAt(i)\n      hash |= 0\n    }\n    return Logger.colors[Math.abs(hash) % Logger.colors.length]\n  }\n\n  private code: number\n\n  constructor(public name: string) {\n    if (name in Logger.instances) return Logger.instances[name]\n\n    Logger.instances[name] = this\n    this.code = Logger.code(name)\n    this.createMethod('success', '[S] ', Logger.SUCCESS)\n    this.createMethod('error', '[E] ', Logger.ERROR)\n    this.createMethod('info', '[I] ', Logger.INFO)\n    this.createMethod('warn', '[W] ', Logger.WARN)\n    this.createMethod('debug', '[D] ', Logger.DEBUG)\n  }\n\n  extend = (namespace: string) => {\n    return new Logger(`${this.name}:${namespace}`)\n  }\n\n  createMethod(name: Logger.Type, prefix: string, minLevel: number) {\n    this[name] = (...args) => {\n      if (this.level < minLevel) return\n      const now = Date.now()\n      for (const target of Logger.targets) {\n        let indent = 4, output = ''\n        if (target.showTime) {\n          indent += target.showTime.length + 1\n          output += Time.template(target.showTime + ' ')\n        }\n        output += prefix + this.color(target, this.name, ';1') + ' ' + this.format(target, indent, ...args)\n        if (target.showDiff) {\n          const diff = Logger.timestamp && now - Logger.timestamp\n          output += this.color(target, ' +' + Time.formatTimeShort(diff))\n        }\n        target.print(output)\n      }\n      Logger.timestamp = now\n    }\n  }\n\n  private color(target: Logger.Target, value: any, decoration = '') {\n    return Logger.color(target, this.code, value, decoration)\n  }\n\n  private format(target: Logger.Target, indent: number, ...args: any[]) {\n    if (args[0] instanceof Error) {\n      args[0] = args[0].stack || args[0].message\n    } else if (typeof args[0] !== 'string') {\n      args.unshift('%O')\n    }\n\n    let index = 0\n    args[0] = (args[0] as string).replace(/%([a-zA-Z%])/g, (match, format) => {\n      if (match === '%%') return '%'\n      index += 1\n      const formatter = Logger.formatters[format]\n      if (typeof formatter === 'function') {\n        match = formatter(args[index], target, this)\n        args.splice(index, 1)\n        index -= 1\n      }\n      return match\n    }).replace(/\\n/g, '\\n' + ' '.repeat(indent))\n\n    return format(...args)\n  }\n\n  get level() {\n    const paths = this.name.split(':')\n    let config: Logger.Level = Logger.levels\n    do {\n      config = config[paths.shift()] ?? config['base']\n    } while (paths.length && typeof config === 'object')\n    return config as number\n  }\n\n  set level(value) {\n    const paths = this.name.split(':')\n    let config = Logger.levels\n    while (paths.length > 1) {\n      const name = paths.shift()\n      const value = config[name]\n      if (typeof value === 'object') {\n        config = value\n      } else {\n        config = config[name] = { base: value ?? config.base }\n      }\n    }\n    config[paths[0]] = value\n  }\n}\n", "export namespace Time {\n  export const millisecond = 1\n  export const second = 1000\n  export const minute = second * 60\n  export const hour = minute * 60\n  export const day = hour * 24\n  export const week = day * 7\n\n  let timezoneOffset = new Date().getTimezoneOffset()\n\n  export function setTimezoneOffset(offset: number) {\n    timezoneOffset = offset\n  }\n\n  export function getTimezoneOffset() {\n    return timezoneOffset\n  }\n\n  export function getDateNumber(date: number | Date = new Date(), offset?: number) {\n    if (typeof date === 'number') date = new Date(date)\n    if (offset === undefined) offset = timezoneOffset\n    return Math.floor((date.valueOf() / minute - offset) / 1440)\n  }\n\n  export function fromDateNumber(value: number, offset?: number) {\n    const date = new Date(value * day)\n    if (offset === undefined) offset = timezoneOffset\n    return new Date(+date + offset * minute)\n  }\n\n  const numeric = /\\d+(?:\\.\\d+)?/.source\n  const timeRegExp = new RegExp(`^${[\n    'w(?:eek(?:s)?)?',\n    'd(?:ay(?:s)?)?',\n    'h(?:our(?:s)?)?',\n    'm(?:in(?:ute)?(?:s)?)?',\n    's(?:ec(?:ond)?(?:s)?)?',\n  ].map(unit => `(${numeric}${unit})?`).join('')}$`)\n\n  export function parseTime(source: string) {\n    const capture = timeRegExp.exec(source)\n    if (!capture) return 0\n    return (parseFloat(capture[1]) * week || 0)\n      + (parseFloat(capture[2]) * day || 0)\n      + (parseFloat(capture[3]) * hour || 0)\n      + (parseFloat(capture[4]) * minute || 0)\n      + (parseFloat(capture[5]) * second || 0)\n  }\n\n  export function parseDate(date: string) {\n    const parsed = parseTime(date)\n    if (parsed) {\n      date = Date.now() + parsed as any\n    } else if (/^\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().toLocaleDateString()}-${date}`\n    } else if (/^\\d{1,2}-\\d{1,2}-\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().getFullYear()}-${date}`\n    }\n    return date ? new Date(date) : new Date()\n  }\n\n  export function formatTimeShort(ms: number) {\n    const abs = Math.abs(ms)\n    if (abs >= day - hour / 2) {\n      return Math.round(ms / day) + 'd'\n    } else if (abs >= hour - minute / 2) {\n      return Math.round(ms / hour) + 'h'\n    } else if (abs >= minute - second / 2) {\n      return Math.round(ms / minute) + 'm'\n    } else if (abs >= second) {\n      return Math.round(ms / second) + 's'\n    }\n    return ms + 'ms'\n  }\n\n  export function formatTime(ms: number) {\n    let result: string\n    if (ms >= day - hour / 2) {\n      ms += hour / 2\n      result = Math.floor(ms / day) + ' 天'\n      if (ms % day > hour) {\n        result += ` ${Math.floor(ms % day / hour)} 小时`\n      }\n    } else if (ms >= hour - minute / 2) {\n      ms += minute / 2\n      result = Math.floor(ms / hour) + ' 小时'\n      if (ms % hour > minute) {\n        result += ` ${Math.floor(ms % hour / minute)} 分钟`\n      }\n    } else if (ms >= minute - second / 2) {\n      ms += second / 2\n      result = Math.floor(ms / minute) + ' 分钟'\n      if (ms % minute > second) {\n        result += ` ${Math.floor(ms % minute / second)} 秒`\n      }\n    } else {\n      result = Math.round(ms / second) + ' 秒'\n    }\n    return result\n  }\n\n  const dayMap = ['日', '一', '二', '三', '四', '五', '六']\n\n  function toDigits(source: number, length = 2) {\n    return source.toString().padStart(length, '0')\n  }\n\n  export function template(template: string, time = new Date()) {\n    return template\n      .replace('yyyy', time.getFullYear().toString())\n      .replace('yy', time.getFullYear().toString().slice(2))\n      .replace('MM', toDigits(time.getMonth() + 1))\n      .replace('dd', toDigits(time.getDate()))\n      .replace('hh', toDigits(time.getHours()))\n      .replace('mm', toDigits(time.getMinutes()))\n      .replace('ss', toDigits(time.getSeconds()))\n      .replace('SSS', toDigits(time.getMilliseconds(), 3))\n  }\n\n  function toHourMinute(time: Date) {\n    return `${toDigits(time.getHours())}:${toDigits(time.getMinutes())}`\n  }\n\n  export function formatTimeInterval(time: Date, interval?: number) {\n    if (!interval) {\n      return template('yyyy-MM-dd hh:mm:ss', time)\n    } else if (interval === day) {\n      return `每天 ${toHourMinute(time)}`\n    } else if (interval === week) {\n      return `每周${dayMap[time.getDay()]} ${toHourMinute(time)}`\n    } else {\n      return `${template('yyyy-MM-dd hh:mm:ss', time)} 起每隔 ${formatTime(interval)}`\n    }\n  }\n}\n", "import Schema, { isNullable } from 'schemastery'\n\nexport { Schema }\n\nexport { isNullable, isPlainObject, valueMap, clone } from 'schemastery'\n\nexport function noop(): any {}\n\nexport function contain(array1: readonly any[], array2: readonly any[]) {\n  return array2.every(item => array1.includes(item))\n}\n\nexport function intersection<T>(array1: readonly T[], array2: readonly T[]) {\n  return array1.filter(item => array2.includes(item))\n}\n\nexport function difference<S>(array1: readonly S[], array2: readonly any[]) {\n  return array1.filter(item => !array2.includes(item))\n}\n\nexport function union<T>(array1: readonly T[], array2: readonly T[]) {\n  return Array.from(new Set([...array1, ...array2]))\n}\n\nexport function deduplicate<T>(array: readonly T[]) {\n  return [...new Set(array)]\n}\n\nexport function remove<T>(list: T[], item: T) {\n  const index = list.indexOf(item)\n  if (index >= 0) {\n    list.splice(index, 1)\n    return true\n  }\n}\n\nexport function isInteger(source: any) {\n  return typeof source === 'number' && Math.floor(source) === source\n}\n\nexport async function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function enumKeys<T extends string>(data: Record<T, string | number>) {\n  return Object.values(data).filter(value => typeof value === 'string') as T[]\n}\n\nexport function defineEnumProperty<T extends object>(object: T, key: keyof T, value: T[keyof T]) {\n  object[key] = value\n  object[value as any] = key\n}\n\nexport function merge<T extends object>(head: T, base: T): T {\n  Object.entries(base).forEach(([key, value]) => {\n    if (typeof head[key] === 'undefined') return head[key] = base[key]\n    if (typeof value === 'object' && typeof head[key] === 'object') {\n      head[key] = merge(head[key], value)\n    }\n  })\n  return head\n}\n\nexport function pick<T, K extends keyof T>(source: T, keys?: Iterable<K>, forced?: boolean) {\n  if (!keys) return { ...source }\n  const result = {} as Pick<T, K>\n  for (const key of keys) {\n    if (forced || key in source) result[key] = source[key]\n  }\n  return result\n}\n\nexport function omit<T, K extends keyof T>(source: T, keys?: Iterable<K>) {\n  if (!keys) return { ...source }\n  const result = { ...source } as Omit<T, K>\n  for (const key of keys) {\n    Reflect.deleteProperty(result, key)\n  }\n  return result\n}\n\nexport function defineProperty<T, K extends keyof T>(object: T, key: K, value: T[K]): void\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any): void\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any) {\n  Object.defineProperty(object, key, { writable: true, value })\n}\n\nexport function assertProperty<O, K extends keyof O>(config: O, key: K) {\n  if (!config[key]) throw new Error(`missing configuration \"${key}\"`)\n  return config[key]\n}\n\nexport function coerce(val: any) {\n  const { stack } = val instanceof Error ? val : new Error(val as any)\n  return stack\n}\n\nexport function makeArray<T>(source: T | T[]) {\n  return Array.isArray(source) ? source : isNullable(source) ? [] : [source]\n}\n\nexport function renameProperty<O extends object, K extends keyof O, T extends string>(config: O, key: K, oldKey: T) {\n  config[key] = Reflect.get(config, oldKey)\n  Reflect.deleteProperty(config, oldKey)\n}\n\ntype Global = NodeJS.Global & Window & typeof globalThis\n\ntype GlobalClass = {\n  [K in keyof Global]: Global[K] extends new (...args: any[]) => infer T ? T : never\n}\n\nconst root: any = typeof self !== 'undefined' ? self : global\n\nexport function isType<K extends keyof GlobalClass>(type: K, value: any): value is GlobalClass[K] {\n  return type in root && value instanceof root[type]\n    || Object.prototype.toString.call(value).slice(8, -1) === type\n}\n\nexport type Dict<T = any> = { [key: string]: T }\nexport type Get<T extends {}, K> = K extends keyof T ? T[K] : never\nexport type Extract<S, T, U = S> = S extends T ? U : never\nexport type MaybeArray<T> = [T] extends [unknown[]] ? T : T | T[]\nexport type Promisify<T> = Promise<T extends Promise<infer S> ? S : T>\nexport type Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>\nexport type Intersect<U> = (U extends any ? (arg: U) => void : never) extends ((arg: infer I) => void) ? I : never\n", "import { defineProperty, isType, noop } from './misc'\n\nconst immutable = ['number', 'string', 'bigint', 'boolean', 'symbol', 'function']\nconst builtin = ['Date', 'RegExp', 'Set', 'Map', 'WeakSet', 'WeakMap', 'Array']\n\nfunction observeProperty(value: any, update: any) {\n  if (isType('Date', value)) {\n    return observeDate(value, update)\n  } else if (Array.isArray(value)) {\n    return observeArray(value, update)\n  } else {\n    return observeObject(value, update)\n  }\n}\n\nfunction untracked(key: string | symbol) {\n  return typeof key === 'symbol' || key.startsWith('$')\n}\n\nfunction observeObject<T extends object>(target: T, notify?: (key: string | symbol) => void): T {\n  const update = notify\n  if (!notify) {\n    const diff = Object.create(null)\n    defineProperty(target, '$diff', diff)\n    notify = (key) => {\n      if (untracked(key)) return\n      diff[key] = target[key]\n    }\n  }\n\n  const proxy = new Proxy(target as Observed<T>, {\n    get(target, key) {\n      const value = Reflect.get(target, key)\n      if (!value || immutable.includes(typeof value) || untracked(key)) return value\n      return observeProperty(value, update || (() => notify(key)))\n    },\n    set(target, key, value) {\n      const unchanged = target[key] === value\n      const result = Reflect.set(target, key, value)\n      if (unchanged || !result) return result\n      notify(key)\n      return true\n    },\n    deleteProperty(target, key) {\n      const unchanged = !(key in target)\n      const result = Reflect.deleteProperty(target, key)\n      if (unchanged || !result) return result\n      notify(key)\n      return true\n    },\n  })\n\n  return proxy\n}\n\nconst arrayProxyMethods = ['pop', 'shift', 'splice', 'sort']\n\nfunction observeArray<T>(target: T[], update: () => void) {\n  const proxy: Record<number, T> = {}\n\n  for (const method of arrayProxyMethods) {\n    defineProperty(target, method, function (...args: any[]) {\n      update()\n      return Array.prototype[method].apply(this, args)\n    })\n  }\n\n  return new Proxy(target, {\n    get(target, key) {\n      if (key in proxy) return proxy[key]\n      const value = target[key]\n      if (!value || immutable.includes(typeof value) || typeof key === 'symbol' || isNaN(key as any)) return value\n      return observeProperty(value, update)\n    },\n    set(target, key, value) {\n      if (typeof key !== 'symbol' && !isNaN(key as any) && target[key] !== value) update()\n      return Reflect.set(target, key, value)\n    },\n  })\n}\n\nfunction observeDate(target: Date, update: () => void) {\n  for (const method of Object.getOwnPropertyNames(Date.prototype)) {\n    if (method === 'valueOf') continue\n    defineProperty(target, method, function (...args: any[]) {\n      const oldValue = target.valueOf()\n      const result = Date.prototype[method].apply(this, args)\n      if (target.valueOf() !== oldValue) update()\n      return result\n    })\n  }\n  return target\n}\n\nexport type Observed<T, R = any> = T & {\n  $diff: Partial<T>\n  $update: () => R\n  $merge: (value: Partial<T>) => Observed<T, R>\n}\n\ntype UpdateFunction<T, R> = (diff: Partial<T>) => R\n\nexport function observe<T extends object>(target: T, label?: string | number): Observed<T, void>\nexport function observe<T extends object, R>(target: T, update: UpdateFunction<T, R>, label?: string | number): Observed<T, R>\nexport function observe<T extends object, R>(target: T, ...args: [(string | number)?] | [UpdateFunction<T, R>, (string | number)?]) {\n  if (immutable.includes(typeof target)) {\n    throw new Error(`cannot observe immutable type \"${typeof target}\"`)\n  } else if (!target) {\n    throw new Error('cannot observe null or undefined')\n  }\n\n  const type = Object.prototype.toString.call(target).slice(8, -1)\n  if (builtin.includes(type)) {\n    throw new Error(`cannot observe instance of type \"${type}\"`)\n  }\n\n  let update: UpdateFunction<T, R> = noop\n  if (typeof args[0] === 'function') update = args.shift() as any\n\n  const observer = observeObject(target, null) as Observed<T>\n\n  defineProperty(observer, '$update', function $update(this: Observed<T>) {\n    const diff = { ...this.$diff }\n    const fields = Object.keys(diff)\n    if (fields.length) {\n      for (const key in this.$diff) {\n        delete this.$diff[key]\n      }\n      return update(diff)\n    }\n  })\n\n  defineProperty(observer, '$merge', function $merge(this: Observed<T>, value: Partial<T>) {\n    for (const key in value) {\n      if (key in this.$diff) {\n        throw new Error(`unresolved diff key \"${key}\"`)\n      }\n      target[key] = value[key]\n    }\n    return this\n  })\n\n  return observer\n}\n", "/**\n * random operations\n */\nexport class Random {\n  constructor(private value = Math.random()) {}\n\n  bool(probability: number) {\n    if (probability >= 1) return true\n    if (probability <= 0) return false\n    return this.value < probability\n  }\n\n  /**\n   * random real\n   * @param start start number\n   * @param end end number\n   * @returns a random real in the interval [start, end)\n   */\n  real(end: number): number\n  real(start: number, end: number): number\n  real(...args: [number, number?]): number {\n    const start = args.length > 1 ? args[0] : 0\n    const end = args[args.length - 1]\n    return this.value * (end - start) + start\n  }\n\n  /**\n   * random integer\n   * @param start start number\n   * @param end end number\n   * @returns a random integer in the interval [start, end)\n   */\n  int(end: number): number\n  int(start: number, end: number): number\n  int(...args: [number, number?]): number {\n    return Math.floor(this.real(...args))\n  }\n\n  pick<T>(source: readonly T[]) {\n    return source[Math.floor(this.value * source.length)]\n  }\n\n  splice<T>(source: T[]) {\n    return source.splice(Math.floor(this.value * source.length), 1)[0]\n  }\n\n  weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T {\n    const total = Object.entries(weights).reduce((prev, [, curr]) => prev + (curr as number), 0)\n    const pointer = this.value * total\n    let counter = 0\n    for (const key in weights) {\n      counter += weights[key]\n      if (pointer < counter) return key\n    }\n  }\n}\n\nexport namespace Random {\n  const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  export function id(length = 8, radix = 16) {\n    let result = ''\n    for (let i = 0; i < length; ++i) {\n      result += chars[Math.floor(Math.random() * radix)]\n    }\n    return result\n  }\n\n  /**\n   * random real\n   * @param start start number\n   * @param end end number\n   * @returns a random real in the interval [start, end)\n   */\n  export function real(end: number): number\n  export function real(start: number, end: number): number\n  export function real(...args: [number, number?]): number {\n    return new Random().real(...args)\n  }\n\n  /**\n   * random integer\n   * @param start start number\n   * @param end end number\n   * @returns a random integer in the interval [start, end)\n   */\n  export function int(end: number): number\n  export function int(start: number, end: number): number\n  export function int(...args: [number, number?]): number {\n    return new Random().int(...args)\n  }\n\n  export function pick<T>(source: readonly T[]) {\n    return new Random().pick(source)\n  }\n\n  export function shuffle<T>(source: readonly T[]) {\n    const clone = source.slice()\n    const result: T[] = []\n    for (let i = source.length; i > 0; --i) {\n      result.push(new Random().splice(clone))\n    }\n    return result\n  }\n\n  export function multiPick<T>(source: T[], count: number) {\n    source = source.slice()\n    const result: T[] = []\n    const length = Math.min(source.length, count)\n    for (let i = 0; i < length; i += 1) {\n      const index = Math.floor(Math.random() * source.length)\n      const [item] = source.splice(index, 1)\n      result.push(item)\n    }\n    return result\n  }\n\n  export function weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T {\n    return new Random().weightedPick(weights)\n  }\n\n  export function bool(probability: number) {\n    return new Random().bool(probability)\n  }\n}\n", "function deepen(modifyString: (source: string) => string) {\n  function modifyObject<T extends unknown>(source: T): T {\n    if (typeof source !== 'object' || !source) return source\n    if (Array.isArray(source)) return source.map(modifyObject) as any\n    const result = {} as any\n    for (const key in source) {\n      result[modifyString(key)] = modifyObject(source[key])\n    }\n    return result as T\n  }\n\n  return function<T> (source: T): T {\n    if (typeof source === 'string') {\n      return modifyString(source) as any\n    } else {\n      return modifyObject(source)\n    }\n  }\n}\n\nexport const camelCase = deepen(source => source.replace(/[_-][a-z]/g, str => str.slice(1).toUpperCase()))\nexport const paramCase = deepen(source => uncapitalize(source).replace(/_/g, '-').replace(/(?<!^)[A-Z]/g, str => '-' + str.toLowerCase()))\nexport const snakeCase = deepen(source => uncapitalize(source).replace(/-/g, '_').replace(/(?<!^)[A-Z]/g, str => '_' + str.toLowerCase()))\n\nexport const camelize = camelCase\nexport const hyphenate = paramCase\n\nnamespace Letter {\n  /* eslint-disable @typescript-eslint/member-delimiter-style */\n  interface LowerToUpper {\n    a: 'A', b: 'B', c: 'C', d: 'D', e: 'E', f: 'F', g: 'G', h: 'H', i: 'I', j: 'J', k: 'K', l: 'L', m: 'M',\n    n: 'N', o: 'O', p: 'P', q: 'Q', r: 'R', s: 'S', t: 'T', u: 'U', v: 'V', w: 'W', x: 'X', y: 'Y', z: 'Z',\n  }\n\n  interface UpperToLower {\n    A: 'a', B: 'b', C: 'c', D: 'd', E: 'e', F: 'f', G: 'g', H: 'h', I: 'i', J: 'j', K: 'k', L: 'l', M: 'm',\n    N: 'n', O: 'o', P: 'p', Q: 'q', R: 'r', S: 's', T: 't', U: 'u', V: 'v', W: 'w', X: 'x', Y: 'y', Z: 'z',\n  }\n  /* eslint-enable @typescript-eslint/member-delimiter-style */\n\n  export type Upper = keyof UpperToLower\n  export type Lower = keyof LowerToUpper\n\n  export type ToUpper<S extends string> = S extends Lower ? LowerToUpper[S] : S\n  export type ToLower<S extends string, P extends string = ''> = S extends Upper ? `${P}${UpperToLower[S]}` : S\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport type camelize<S extends string> = S extends `${infer L}-${infer M}${infer R}` ? `${L}${Letter.ToUpper<M>}${camelize<R>}` : S\nexport type hyphenate<S extends string> = S extends `${infer L}${infer R}` ? `${Letter.ToLower<L, '-'>}${hyphenate<R>}` : S\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport function capitalize(source: string) {\n  return source.charAt(0).toUpperCase() + source.slice(1)\n}\n\nexport function uncapitalize(source: string) {\n  return source.charAt(0).toLowerCase() + source.slice(1)\n}\n\n// eslint-disable-next-line no-new-func\nexport const interpolate = new Function('template', 'context', 'pattern', `\n  return template.replace(pattern || /\\\\{\\\\{([\\\\s\\\\S]+?)\\\\}\\\\}/g, (_, expr) => {\n    try {\n      with (context) {\n        const result = eval(expr)\n        return result === undefined ? '' : result\n      }\n    } catch {\n      return ''\n    }\n  })\n`) as ((template: string, context: object, pattern?: RegExp) => string)\n\nexport function escapeRegExp(source: string) {\n  return source\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n    .replace(/-/g, '\\\\x2d')\n}\n\nexport function trimSlash(source: string) {\n  return source.replace(/\\/$/, '')\n}\n\nexport function sanitize(source: string) {\n  if (!source.startsWith('/')) source = '/' + source\n  return trimSlash(source)\n}\n\n/** @deprecated use template service instead */\nexport function template(path: string | string[], ...params: any[]) {\n  if (!Array.isArray(path)) path = [path]\n  for (const item of path) {\n    const source = template.get(item)\n    if (typeof source === 'string') {\n      return template.format(source, ...params)\n    }\n  }\n  return path[0]\n}\n\nfunction deepAssign(head: any, base: any): any {\n  Object.entries(base).forEach(([key, value]) => {\n    if (typeof value === 'object' && typeof head[key] === 'object') {\n      head[key] = deepAssign(head[key], value)\n    } else {\n      head[key] = base[key]\n    }\n  })\n  return head\n}\n\nexport namespace template {\n  export type Node = string | Store\n\n  export interface Store {\n    [K: string]: Node\n  }\n\n  const store: Store = {}\n\n  export function set(path: string, value: Node) {\n    const seg = path.split('.')\n    let node: Node = store\n    while (seg.length > 1) {\n      node = node[seg.shift()] ||= {}\n    }\n    deepAssign(node, { [seg[0]]: value })\n  }\n\n  export function get(path: string) {\n    const seg = path.split('.')\n    let node: Node = store\n    do {\n      node = node[seg.shift()]\n    } while (seg.length && node)\n    if (typeof node === 'string') return node\n  }\n\n  export function format(source: string, ...params: any[]) {\n    if (params[0] && typeof params[0] === 'object') {\n      source = interpolate(source, params[0])\n    }\n    let result = ''\n    let cap: RegExpExecArray\n    // eslint-disable-next-line no-cond-assign\n    while (cap = /\\{(\\w+)\\}/.exec(source)) {\n      result += source.slice(0, cap.index) + (cap[1] in params ? params[cap[1]] : '')\n      source = source.slice(cap.index + cap[0].length)\n    }\n    return result + source\n  }\n}\n\nexport { template as t }\n"],
  "mappings": "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",
  "names": []
}
