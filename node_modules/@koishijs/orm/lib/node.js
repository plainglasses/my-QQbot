var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// plugins/database/orm/src/index.ts
__export(exports, {
  Driver: () => Driver,
  DriverError: () => DriverError,
  Model: () => Model,
  ModelError: () => ModelError,
  executeEval: () => executeEval,
  executeQuery: () => executeQuery,
  executeSort: () => executeSort,
  executeUpdate: () => executeUpdate,
  isEvalExpr: () => isEvalExpr
});

// plugins/database/orm/src/driver.ts
var import_utils = __toModule(require("@koishijs/utils"));

// plugins/database/orm/src/error.ts
var ModelError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ModelError";
  }
};
__name(ModelError, "ModelError");
var DriverError = class extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
    this.name = "DriverError";
  }
  static check(error, code) {
    if (!(error instanceof DriverError))
      return false;
    return !code || error.message === code;
  }
};
__name(DriverError, "DriverError");

// plugins/database/orm/src/driver.ts
var Driver = class {
  constructor(model) {
    this.model = model;
  }
  resolveTable(name) {
    const config = this.model.config[name];
    if (config)
      return config;
    throw new ModelError(`unknown table name "${name}"`);
  }
  resolveQuery(name, query = {}) {
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number"].includes(typeof query)) {
      const { primary } = this.resolveTable(name);
      if (Array.isArray(primary)) {
        throw new ModelError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveModifier(name, modifier) {
    if (!modifier)
      modifier = {};
    if (Array.isArray(modifier))
      modifier = { fields: modifier };
    if (modifier.fields) {
      const fields = Object.keys(this.resolveTable(name).fields);
      modifier.fields = modifier.fields.flatMap((key) => {
        if (fields.includes(key))
          return key;
        const prefix = key + ".";
        return fields.filter((path) => path.startsWith(prefix));
      });
    }
    return modifier;
  }
  resolveUpdate(name, update) {
    const { primary } = this.resolveTable(name);
    if ((0, import_utils.makeArray)(primary).some((key) => key in update)) {
      throw new ModelError(`cannot modify primary key`);
    }
    return this.model.format(name, update);
  }
  resolveData(name, data, fields) {
    var _a;
    data = this.model.format(name, data);
    for (const key in this.model.config[name].fields) {
      (_a = data[key]) != null ? _a : data[key] = null;
    }
    return this.model.parse(name, (0, import_utils.pick)(data, fields));
  }
};
__name(Driver, "Driver");

// plugins/database/orm/src/eval.ts
function isEvalExpr(value) {
  return Object.keys(value).some((key) => key.startsWith("$"));
}
__name(isEvalExpr, "isEvalExpr");
function getRecursive(path, data) {
  let value = data;
  for (const key of path.split(".")) {
    if (!value)
      return;
    value = value[key];
  }
  return value;
}
__name(getRecursive, "getRecursive");
var evalOperators = {
  $: getRecursive,
  $if: ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse),
  $ifNull: ([value, fallback], data) => {
    var _a;
    return (_a = executeEval(data, value)) != null ? _a : executeEval(data, fallback);
  },
  $add: (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0),
  $multiply: (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1),
  $subtract: ([left, right], data) => executeEval(data, left) - executeEval(data, right),
  $divide: ([left, right], data) => executeEval(data, left) - executeEval(data, right),
  $concat: (args, data) => args.map((arg) => executeEval(data, arg)).join(""),
  $eq: ([left, right], data) => executeEval(data, left).valueOf() === executeEval(data, right).valueOf(),
  $ne: ([left, right], data) => executeEval(data, left).valueOf() !== executeEval(data, right).valueOf(),
  $gt: ([left, right], data) => executeEval(data, left).valueOf() > executeEval(data, right).valueOf(),
  $gte: ([left, right], data) => executeEval(data, left).valueOf() >= executeEval(data, right).valueOf(),
  $lt: ([left, right], data) => executeEval(data, left).valueOf() < executeEval(data, right).valueOf(),
  $lte: ([left, right], data) => executeEval(data, left).valueOf() <= executeEval(data, right).valueOf(),
  $sum: (expr, table) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0),
  $avg: (expr, table) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length,
  $min: (expr, table) => Math.min(...table.map((data) => executeAggr(expr, data))),
  $max: (expr, table) => Math.max(...table.map((data) => executeAggr(expr, data))),
  $count: (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size
};
function executeEvalExpr(expr, data) {
  for (const key in expr) {
    if (key in evalOperators) {
      return evalOperators[key](expr[key], data);
    }
  }
  return expr;
}
__name(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (typeof expr === "number" || typeof expr === "string" || typeof expr === "boolean" || expr instanceof Date || expr === null || expr === void 0) {
    return expr;
  }
  return executeEvalExpr(expr, data);
}
__name(executeEval, "executeEval");
function executeUpdate(data, update) {
  for (const key in update) {
    let root = data;
    const path = key.split(".");
    const last = path.pop();
    for (const key2 of path) {
      root = root[key2] || (root[key2] = {});
    }
    root[last] = executeEval(data, update[key]);
  }
  return data;
}
__name(executeUpdate, "executeUpdate");

// plugins/database/orm/src/model.ts
var import_utils2 = __toModule(require("@koishijs/utils"));
var Model = class {
  constructor() {
    this.config = {};
  }
  extend(name, fields = {}, extension = {}) {
    var _a, _b, _c;
    const { primary, autoInc, unique = [], foreign } = extension;
    const table = (_a = this.config)[name] || (_a[name] = {
      primary: "id",
      unique: [],
      foreign: {},
      fields: {},
      internal: { "": {} }
    });
    table.primary = primary || table.primary;
    table.autoInc = autoInc || table.autoInc;
    table.unique.push(...unique);
    Object.assign(table.foreign, foreign);
    for (const key in fields) {
      if (typeof fields[key] === "function") {
        const index = key.lastIndexOf(".");
        const prefix = key.slice(0, index + 1);
        const method = key.slice(index + 1);
        ((_c = (_b = table.internal)[prefix]) != null ? _c : _b[prefix] = {})[method] = fields[key];
      } else {
        table.fields[key] = Model.Field.parse(fields[key]);
      }
    }
    this.checkIndex(table, table.primary);
    table.unique.forEach((index) => this.checkIndex(table, index));
  }
  checkIndex(table, index) {
    for (const key of (0, import_utils2.makeArray)(index)) {
      if (!table.fields[key]) {
        throw new ModelError(`missing field definition for index key "${key}"`);
      }
    }
  }
  create(name, data) {
    const { fields, primary } = this.config[name];
    const result = {};
    const keys = (0, import_utils2.makeArray)(primary);
    for (const key in fields) {
      if (!keys.includes(key) && !(0, import_utils2.isNullable)(fields[key].initial)) {
        result[key] = (0, import_utils2.clone)(fields[key].initial);
      }
    }
    return this.parse(name, __spreadValues(__spreadValues({}, result), data));
  }
  resolveValue(name, key, value) {
    var _a;
    if ((0, import_utils2.isNullable)(value))
      return value;
    const { fields } = this.config[name];
    if (((_a = fields[key]) == null ? void 0 : _a.type) === "time") {
      const date = new Date(0);
      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date;
    }
    return value;
  }
  parse(name, source) {
    var _a, _b;
    const { internal } = this.config[name];
    const result = Object.create(internal[""]);
    for (const key in source) {
      let node = result;
      const segments = key.split(".").reverse();
      let prefix = "";
      for (let index = segments.length - 1; index > 0; index--) {
        const segment = segments[index];
        prefix += segment + ".";
        node = (_b = node[segment]) != null ? _b : node[segment] = Object.create((_a = internal[prefix]) != null ? _a : {});
      }
      if (key in source) {
        const value = this.resolveValue(name, key, source[key]);
        node[segments[0]] = value;
      }
    }
    return result;
  }
  format(name, source, prefix = "", result = {}) {
    const fields = Object.keys(this.config[name].fields);
    Object.entries(source).map(([key, value]) => {
      key = prefix + key;
      if (fields.includes(key)) {
        result[key] = this.resolveValue(name, key, value);
      } else if (!value || typeof value !== "object" || isEvalExpr(value)) {
        const field = fields.find((field2) => key.startsWith(field2 + "."));
        if (field)
          result[key] = value;
      } else {
        this.format(name, value, key + ".", result);
      }
    });
    return result;
  }
};
__name(Model, "Model");
(function(Model2) {
  let Field;
  (function(Field2) {
    Field2.number = ["integer", "unsigned", "float", "double", "decimal"];
    Field2.string = ["char", "string", "text"];
    Field2.date = ["timestamp", "date", "time"];
    Field2.object = ["list", "json"];
    const regexp = /^(\w+)(?:\((.+)\))?$/;
    function parse(source) {
      if (typeof source !== "string")
        return __spreadValues({ initial: null }, source);
      const capture = regexp.exec(source);
      if (!capture)
        throw new ModelError("invalid field definition");
      const type = capture[1];
      const args = (capture[2] || "").split(",");
      const field = { type };
      if (field.initial === void 0) {
        if (Field2.number.includes(field.type))
          field.initial = 0;
        if (Field2.string.includes(field.type))
          field.initial = "";
        if (field.type === "list")
          field.initial = [];
        if (field.type === "json")
          field.initial = {};
      }
      if (type === "decimal") {
        field.precision = +args[0];
        field.scale = +args[1];
      } else if (args[0]) {
        field.length = +args[0];
      }
      return field;
    }
    Field2.parse = parse;
    __name(parse, "parse");
  })(Field = Model2.Field || (Model2.Field = {}));
})(Model || (Model = {}));

// plugins/database/orm/src/query.ts
var queryOperators = {
  $or: (query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false),
  $and: (query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true),
  $not: (query, data) => !executeFieldQuery(query, data),
  $eq: (query, data) => data.valueOf() === query.valueOf(),
  $ne: (query, data) => data.valueOf() !== query.valueOf(),
  $gt: (query, data) => data.valueOf() > query.valueOf(),
  $gte: (query, data) => data.valueOf() >= query.valueOf(),
  $lt: (query, data) => data.valueOf() < query.valueOf(),
  $lte: (query, data) => data.valueOf() <= query.valueOf(),
  $in: (query, data) => query.includes(data),
  $nin: (query, data) => !query.includes(data),
  $regex: (query, data) => query.test(data),
  $regexFor: (query, data) => new RegExp(data, "i").test(query),
  $bitsAllSet: (query, data) => (query & data) === query,
  $bitsAllClear: (query, data) => (query & data) === 0,
  $bitsAnySet: (query, data) => (query & data) !== 0,
  $bitsAnyClear: (query, data) => (query & data) !== query,
  $el: (query, data) => data.some((item) => executeFieldQuery(query, item)),
  $size: (query, data) => data.length === query
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (typeof query === "string" || typeof query === "number" || query instanceof Date) {
    return data.valueOf() === query.valueOf();
  }
  for (const key in query) {
    if (key in queryOperators) {
      if (!queryOperators[key](query[key], data))
        return false;
    }
  }
  return true;
}
__name(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query) {
  const entries = Object.entries(query);
  return entries.every(([key, value]) => {
    if (key === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2), true);
    } else if (key === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2), false);
    } else if (key === "$not") {
      return !executeQuery(data, value);
    } else if (key === "$expr") {
      return executeEval(data, value);
    }
    try {
      if (!(key in data))
        return false;
      return executeFieldQuery(value, data[key]);
    } catch {
      return false;
    }
  });
}
__name(executeQuery, "executeQuery");
function executeSort(data, sort) {
  return data.sort((a, b) => {
    for (const key in sort) {
      const dir = sort[key] === "asc" ? 1 : -1;
      const x = a[key], y = b[key];
      if (x < y)
        return -dir;
      if (x > y)
        return dir;
    }
    return 0;
  });
}
__name(executeSort, "executeSort");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Driver,
  DriverError,
  Model,
  ModelError,
  executeEval,
  executeQuery,
  executeSort,
  executeUpdate,
  isEvalExpr
});
//# sourceMappingURL=node.js.map
