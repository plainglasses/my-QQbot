import { Intersect, Dict, MaybeArray, Extract } from '@koishijs/utils';
export class ModelError extends Error {
    name: string;
}
export namespace DriverError {
    type Code = 'duplicate-entry';
}
export class DriverError<T extends DriverError.Code> extends Error {
    code: T;
    name: string;
    constructor(code: T, message?: string);
    static check<T extends DriverError.Code>(error: any, code?: DriverError.Code): error is DriverError<T>;
}
export type Values<S> = S[keyof S];
export type Keys<O, T = any> = Values<{
    [K in keyof O]: O[K] extends T ? K : never;
}> & string;
export type Atomic = number | string | boolean | bigint | symbol | Date;
export type Indexable = string | number;
export type Comparable = string | number | Date;
type FlatWrap<S, T, P extends string> = {
    [K in P]?: S;
} | (S extends Atomic | T ? never : string extends keyof S ? never : FlatMap<S, T, `${P}.`>);
type FlatMap<S, T = never, P extends string = ''> = Values<{
    [K in keyof S & string as `${P}${K}`]: FlatWrap<S[K], S | T, `${P}${K}`>;
}>;
export type Flatten<S> = Intersect<FlatMap<S>>;
export function isEvalExpr(value: any): value is Eval.UniveralExpr;
type $Date = Date;
export type Uneval<T, U> = U extends number ? Eval.Number<T> : U extends string ? Eval.String<T> : U extends boolean ? Eval.Boolean<T> : U extends $Date ? Eval.Date<T> : any;
export type Eval<U> = U extends number ? number : U extends boolean ? boolean : U extends string ? string : U extends symbol ? any : U extends Eval.NumberExpr ? number : U extends Eval.StringExpr ? string : U extends Eval.BooleanExpr ? boolean : U extends Eval.AggregationExpr ? number : never;
export namespace Eval {
    export type GeneralExpr = UniveralExpr & NumberExpr & StringExpr & BooleanExpr & AggregationExpr;
    export type Number<T = any, A = never> = A | number | NumberExpr<T, A>;
    export type String<T = any, A = never> = string | StringExpr<T, A>;
    export type Boolean<T = any, A = never> = boolean | BooleanExpr<T, A>;
    export type Date<T = any> = $Date | DateExpr<T>;
    export type Aggregation<T = any> = Number<{}, AggregationExpr<T>>;
    export interface UniveralExpr<T = any, U = any> {
        $?: Keys<Flatten<T>, U>;
        $if?: [any, Uneval<T, U>, Uneval<T, U>];
        $ifNull?: Uneval<T, U>[];
    }
    export interface NumberExpr<T = any, A = never> extends UniveralExpr<T, number> {
        $add?: Number<T, A>[];
        $multiply?: Number<T, A>[];
        $subtract?: [Number<T, A>, Number<T, A>];
        $divide?: [Number<T, A>, Number<T, A>];
    }
    export interface StringExpr<T = any, A = never> extends UniveralExpr<T, string> {
        $concat?: String<T, A>[];
    }
    type ComparableBinary<T, A> = [Number<T, A>, Number<T, A>] | [String<T, A>, String<T, A>] | [Boolean<T, A>, Boolean<T, A>] | [Date<T>, Date<T>];
    export interface BooleanExpr<T = any, A = never> extends UniveralExpr<T, boolean> {
        $eq?: ComparableBinary<T, A>;
        $ne?: ComparableBinary<T, A>;
        $gt?: ComparableBinary<T, A>;
        $gte?: ComparableBinary<T, A>;
        $lt?: ComparableBinary<T, A>;
        $lte?: ComparableBinary<T, A>;
    }
    export interface DateExpr<T = any> extends UniveralExpr<T, $Date> {
    }
    export interface AggregationExpr<T = any> {
        $sum?: Keys<Flatten<T>, number> | NumberExpr<T>;
        $avg?: Keys<Flatten<T>, number> | NumberExpr<T>;
        $max?: Keys<Flatten<T>, number> | NumberExpr<T>;
        $min?: Keys<Flatten<T>, number> | NumberExpr<T>;
        $count?: Keys<Flatten<T>> | NumberExpr<T> | StringExpr<T> | BooleanExpr<T>;
    }
}
type MapUneval<S, T> = {
    [K in keyof S]?: Uneval<T, S[K]>;
};
export type Update<T> = MapUneval<Flatten<T>, T>;
export function executeEval(data: any, expr: any): any;
export function executeUpdate(data: any, update: any): any;
export class Model<T = any> {
    config: Dict<Model.Config>;
    extend<K extends Keys<T>>(name: K, fields?: Model.Field.Extension<T[K]>, extension?: Model.Extension<T[K]>): void;
    private checkIndex;
    create<K extends Keys<T>>(name: K, data?: {}): T[K];
    resolveValue(name: string, key: string, value: any): any;
    parse<K extends Keys<T>>(name: K, source: object): any;
    format<K extends Keys<T>>(name: K, source: object, prefix?: string, result?: T[K]): T[K];
}
export namespace Model {
    interface Extension<O = any> {
        autoInc?: boolean;
        primary?: MaybeArray<Keys<O>>;
        unique?: MaybeArray<Keys<O>>[];
        foreign?: {
            [K in keyof O]?: [string, string];
        };
    }
    interface Config<O = any> extends Extension<O> {
        fields?: Field.Config<O>;
        internal?: Field.Internal<O>;
    }
    interface Field<T = any> {
        type: Field.Type<T>;
        length?: number;
        nullable?: boolean;
        initial?: T;
        precision?: number;
        scale?: number;
    }
    namespace Field {
        export const number: Type[];
        export const string: Type[];
        export const date: Type[];
        export const object: Type[];
        export type Type<T = any> = T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal' : T extends string ? 'char' | 'string' | 'text' : T extends Date ? 'timestamp' | 'date' | 'time' : T extends unknown[] ? 'list' | 'json' : T extends object ? 'json' : never;
        type Shorthand<S extends string> = S | `${S}(${any})`;
        type MapField<O = any> = {
            [K in keyof O]?: O[K] extends (...args: any) => any ? O[K] : Field<O[K]> | Shorthand<Type<O[K]>>;
        };
        export type Extension<O = any> = MapField<Flatten<O>>;
        export type Config<O = any> = {
            [K in keyof O]?: O[K] extends (...args: any) => any ? never : Field<O[K]>;
        };
        export type Internal<O = any> = {
            [K in keyof O]?: O[K] extends (...args: any) => any ? O[K] : never;
        };
        export function parse(source: string | Field): Field;
    }
}
export type Query<T = any> = Query.Expr<T> | Query.Shorthand<Indexable>;
export namespace Query {
    interface FieldExpr<T = any> {
        $or?: FieldQuery<T>[];
        $and?: FieldQuery<T>[];
        $not?: FieldQuery<T>;
        $in?: Extract<T, Indexable, T[]>;
        $nin?: Extract<T, Indexable, T[]>;
        $eq?: Extract<T, Comparable>;
        $ne?: Extract<T, Comparable>;
        $gt?: Extract<T, Comparable>;
        $gte?: Extract<T, Comparable>;
        $lt?: Extract<T, Comparable>;
        $lte?: Extract<T, Comparable>;
        $el?: T extends (infer U)[] ? FieldQuery<U> : never;
        $size?: Extract<T, any[], number>;
        $regex?: Extract<T, string, RegExp>;
        $regexFor?: Extract<T, string>;
        $bitsAllClear?: Extract<T, number>;
        $bitsAllSet?: Extract<T, number>;
        $bitsAnyClear?: Extract<T, number>;
        $bitsAnySet?: Extract<T, number>;
    }
    interface LogicalExpr<T = any> {
        $or?: Expr<T>[];
        $and?: Expr<T>[];
        $not?: Expr<T>;
        $expr?: Eval.Boolean<T>;
    }
    type Shorthand<T = any> = Extract<T, Comparable> | Extract<T, Indexable, T[]> | Extract<T, string, RegExp>;
    type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>;
    type Expr<T = any> = LogicalExpr<T> & {
        [K in keyof T]?: FieldQuery<T[K]>;
    };
}
export function executeQuery(data: any, query: Query.Expr): boolean;
export type Modifier<T extends string = string> = T[] | Modifier.Expr<T>;
export namespace Modifier {
    interface Expr<K extends string = string> {
        limit?: number;
        offset?: number;
        fields?: K[];
        /** @experimental */
        sort?: Dict<'asc' | 'desc'>;
    }
}
export function executeSort(data: any[], sort: Dict<'asc' | 'desc'>): any[];
export type Result<S, K, T = (...args: any) => any> = {
    [P in keyof S as S[P] extends T ? P : P extends K ? P : never]: S[P];
};
export namespace Driver {
    interface Stats {
        size?: number;
        tables?: Dict<TableStats>;
    }
    interface TableStats {
        count: number;
        size: number;
    }
}
export abstract class Driver<S = any> {
    model: Model<S>;
    abstract drop(): Promise<void>;
    abstract stats(): Promise<Driver.Stats>;
    abstract get<T extends Keys<S>, K extends Keys<S[T]>>(table: T, query: Query<S[T]>, modifier?: Modifier<K>): Promise<Result<S[T], K>[]>;
    abstract set<T extends Keys<S>>(table: T, query: Query<S[T]>, data: Update<S[T]>): Promise<void>;
    abstract remove<T extends Keys<S>>(table: T, query: Query<S[T]>): Promise<void>;
    abstract create<T extends Keys<S>>(table: T, data: Partial<S[T]>): Promise<S[T]>;
    abstract upsert<T extends Keys<S>>(table: T, data: Update<S[T]>[], keys?: MaybeArray<Keys<Flatten<S[T]>, Indexable>>): Promise<void>;
    abstract eval<T extends Keys<S>, E extends Eval.Aggregation<S[T]>>(table: T, expr: E, query?: Query<S[T]>): Promise<Eval<E>>;
    constructor(model: Model<S>);
    protected resolveTable<T extends Keys<S>>(name: T): Model.Config<any>;
    protected resolveQuery<T extends Keys<S>>(name: T, query?: Query<T>): Query.Expr<S[T]>;
    protected resolveModifier<T extends Keys<S>>(name: T, modifier: Modifier): Modifier.Expr;
    protected resolveUpdate<T extends Keys<S>>(name: T, update: any): S[T];
    protected resolveData<T extends Keys<S>>(name: T, data: any, fields: string[]): any;
}
