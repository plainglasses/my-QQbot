{
  "version": 3,
  "sources": ["../src/index.ts", "../src/driver.ts", "../src/error.ts", "../src/eval.ts", "../src/model.ts", "../src/query.ts"],
  "sourcesContent": ["export * from './driver'\nexport * from './error'\nexport * from './eval'\nexport * from './model'\nexport * from './query'\nexport * from './utils'\n", "import { Dict, makeArray, MaybeArray, pick } from '@koishijs/utils'\nimport { ModelError } from './error'\nimport { Eval, Update } from './eval'\nimport { Model } from './model'\nimport { Modifier, Query } from './query'\nimport { Flatten, Indexable, Keys } from './utils'\n\nexport type Result<S, K, T = (...args: any) => any> = {\n  [P in keyof S as S[P] extends T ? P : P extends K ? P : never]: S[P]\n}\n\nexport namespace Driver {\n  export interface Stats {\n    size?: number\n    tables?: Dict<TableStats>\n  }\n\n  export interface TableStats {\n    count: number\n    size: number\n  }\n}\n\nexport abstract class Driver<S = any> {\n  abstract drop(): Promise<void>\n  abstract stats(): Promise<Driver.Stats>\n  abstract get<T extends Keys<S>, K extends Keys<S[T]>>(table: T, query: Query<S[T]>, modifier?: Modifier<K>): Promise<Result<S[T], K>[]>\n  abstract set<T extends Keys<S>>(table: T, query: Query<S[T]>, data: Update<S[T]>): Promise<void>\n  abstract remove<T extends Keys<S>>(table: T, query: Query<S[T]>): Promise<void>\n  abstract create<T extends Keys<S>>(table: T, data: Partial<S[T]>): Promise<S[T]>\n  abstract upsert<T extends Keys<S>>(table: T, data: Update<S[T]>[], keys?: MaybeArray<Keys<Flatten<S[T]>, Indexable>>): Promise<void>\n  abstract eval<T extends Keys<S>, E extends Eval.Aggregation<S[T]>>(table: T, expr: E, query?: Query<S[T]>): Promise<Eval<E>>\n\n  constructor(public model: Model<S>) {}\n\n  protected resolveTable<T extends Keys<S>>(name: T) {\n    const config = this.model.config[name]\n    if (config) return config\n    throw new ModelError(`unknown table name \"${name}\"`)\n  }\n\n  protected resolveQuery<T extends Keys<S>>(name: T, query: Query<T> = {}): Query.Expr<S[T]> {\n    if (Array.isArray(query) || query instanceof RegExp || ['string', 'number'].includes(typeof query)) {\n      const { primary } = this.resolveTable(name)\n      if (Array.isArray(primary)) {\n        throw new ModelError('invalid shorthand for composite primary key')\n      }\n      return { [primary]: query } as any\n    }\n    return query as any\n  }\n\n  protected resolveModifier<T extends Keys<S>>(name: T, modifier: Modifier): Modifier.Expr {\n    if (!modifier) modifier = {}\n    if (Array.isArray(modifier)) modifier = { fields: modifier }\n    if (modifier.fields) {\n      const fields = Object.keys(this.resolveTable(name).fields)\n      modifier.fields = modifier.fields.flatMap((key) => {\n        if (fields.includes(key)) return key\n        const prefix = key + '.'\n        return fields.filter(path => path.startsWith(prefix))\n      })\n    }\n    return modifier\n  }\n\n  protected resolveUpdate<T extends Keys<S>>(name: T, update: any) {\n    const { primary } = this.resolveTable(name)\n    if (makeArray(primary).some(key => key in update)) {\n      throw new ModelError(`cannot modify primary key`)\n    }\n    return this.model.format(name, update)\n  }\n\n  protected resolveData<T extends Keys<S>>(name: T, data: any, fields: string[]) {\n    data = this.model.format(name, data)\n    for (const key in this.model.config[name].fields) {\n      data[key] ??= null\n    }\n    return this.model.parse(name, pick(data, fields))\n  }\n}\n", "export class ModelError extends Error {\n  name = 'ModelError'\n}\n\nexport namespace DriverError {\n  export type Code =\n    | 'duplicate-entry'\n}\n\nexport class DriverError<T extends DriverError.Code> extends Error {\n  name = 'DriverError'\n\n  constructor(public code: T, message?: string) {\n    super(message || code.replace('-', ' '))\n  }\n\n  static check<T extends DriverError.Code>(error: any, code?: DriverError.Code): error is DriverError<T> {\n    if (!(error instanceof DriverError)) return false\n    return !code || error.message === code\n  }\n}\n", "import { Flatten, Keys } from './utils'\n\nexport function isEvalExpr(value: any): value is Eval.UniveralExpr {\n  return Object.keys(value).some(key => key.startsWith('$'))\n}\n\ntype $Date = Date\n\nexport type Uneval<T, U> =\n  | U extends number ? Eval.Number<T>\n  : U extends string ? Eval.String<T>\n  : U extends boolean ? Eval.Boolean<T>\n  : U extends $Date ? Eval.Date<T>\n  : any\n\nexport type Eval<U> =\n  | U extends number ? number\n  : U extends boolean ? boolean\n  : U extends string ? string\n  : U extends symbol ? any\n  : U extends Eval.NumberExpr ? number\n  : U extends Eval.StringExpr ? string\n  : U extends Eval.BooleanExpr ? boolean\n  : U extends Eval.AggregationExpr ? number\n  : never\n\nexport namespace Eval {\n  export type GeneralExpr = UniveralExpr & NumberExpr & StringExpr & BooleanExpr & AggregationExpr\n  export type Number<T = any, A = never> = A | number | NumberExpr<T, A>\n  export type String<T = any, A = never> = string | StringExpr<T, A>\n  export type Boolean<T = any, A = never> = boolean | BooleanExpr<T, A>\n  export type Date<T = any> = $Date | DateExpr<T>\n  export type Aggregation<T = any> = Number<{}, AggregationExpr<T>>\n\n  export interface UniveralExpr<T = any, U = any> {\n    $?: Keys<Flatten<T>, U>\n    $if?: [any, Uneval<T, U>, Uneval<T, U>]\n    $ifNull?: Uneval<T, U>[]\n  }\n\n  export interface NumberExpr<T = any, A = never> extends UniveralExpr<T, number> {\n    $add?: Number<T, A>[]\n    $multiply?: Number<T, A>[]\n    $subtract?: [Number<T, A>, Number<T, A>]\n    $divide?: [Number<T, A>, Number<T, A>]\n  }\n\n  export interface StringExpr<T = any, A = never> extends UniveralExpr<T, string> {\n    $concat?: String<T, A>[]\n  }\n\n  type ComparableBinary<T, A> =\n    | [Number<T, A>, Number<T, A>]\n    | [String<T, A>, String<T, A>]\n    | [Boolean<T, A>, Boolean<T, A>]\n    | [Date<T>, Date<T>]\n\n  export interface BooleanExpr<T = any, A = never> extends UniveralExpr<T, boolean> {\n    $eq?: ComparableBinary<T, A>\n    $ne?: ComparableBinary<T, A>\n    $gt?: ComparableBinary<T, A>\n    $gte?: ComparableBinary<T, A>\n    $lt?: ComparableBinary<T, A>\n    $lte?: ComparableBinary<T, A>\n  }\n\n  export interface DateExpr<T = any> extends UniveralExpr<T, $Date> {}\n\n  export interface AggregationExpr<T = any> {\n    $sum?: Keys<Flatten<T>, number> | NumberExpr<T>\n    $avg?: Keys<Flatten<T>, number> | NumberExpr<T>\n    $max?: Keys<Flatten<T>, number> | NumberExpr<T>\n    $min?: Keys<Flatten<T>, number> | NumberExpr<T>\n    $count?: Keys<Flatten<T>> | NumberExpr<T> | StringExpr<T> | BooleanExpr<T>\n  }\n}\n\ntype MapUneval<S, T> = {\n  [K in keyof S]?: Uneval<T, S[K]>\n}\n\nexport type Update<T> = MapUneval<Flatten<T>, T>\n\ntype EvalOperators = {\n  [K in keyof Eval.GeneralExpr]?: (args: Eval.GeneralExpr[K], data: any) => any\n}\n\nfunction getRecursive(path: string, data: any) {\n  let value = data\n  for (const key of path.split('.')) {\n    if (!value) return\n    value = value[key]\n  }\n  return value\n}\n\nconst evalOperators: EvalOperators = {\n  // universal\n  $: getRecursive,\n  $if: ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse),\n  $ifNull: ([value, fallback], data) => executeEval(data, value) ?? executeEval(data, fallback),\n\n  // number\n  $add: (args, data) => args.reduce<number>((prev, curr) => prev + executeEval(data, curr), 0),\n  $multiply: (args, data) => args.reduce<number>((prev, curr) => prev * executeEval(data, curr), 1),\n  $subtract: ([left, right], data) => executeEval(data, left) - executeEval(data, right),\n  $divide: ([left, right], data) => executeEval(data, left) - executeEval(data, right),\n\n  // string\n  $concat: (args, data) => args.map(arg => executeEval(data, arg)).join(''),\n\n  // boolean\n  $eq: ([left, right], data) => executeEval(data, left).valueOf() === executeEval(data, right).valueOf(),\n  $ne: ([left, right], data) => executeEval(data, left).valueOf() !== executeEval(data, right).valueOf(),\n  $gt: ([left, right], data) => executeEval(data, left).valueOf() > executeEval(data, right).valueOf(),\n  $gte: ([left, right], data) => executeEval(data, left).valueOf() >= executeEval(data, right).valueOf(),\n  $lt: ([left, right], data) => executeEval(data, left).valueOf() < executeEval(data, right).valueOf(),\n  $lte: ([left, right], data) => executeEval(data, left).valueOf() <= executeEval(data, right).valueOf(),\n\n  // aggregation\n  $sum: (expr, table: any[]) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0),\n  $avg: (expr, table: any[]) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length,\n  $min: (expr, table: any[]) => Math.min(...table.map(data => executeAggr(expr, data))),\n  $max: (expr, table: any[]) => Math.max(...table.map(data => executeAggr(expr, data))),\n  $count: (expr, table: any[]) => new Set(table.map(data => executeAggr(expr, data))).size,\n}\n\nfunction executeEvalExpr(expr: any, data: any) {\n  for (const key in expr) {\n    if (key in evalOperators) {\n      return evalOperators[key](expr[key], data)\n    }\n  }\n  return expr\n}\n\nfunction executeAggr(expr: any, data: any) {\n  if (typeof expr === 'string') {\n    return getRecursive(expr, data)\n  }\n  return executeEvalExpr(expr, data)\n}\n\nexport function executeEval(data: any, expr: any) {\n  if (typeof expr === 'number' || typeof expr === 'string' || typeof expr === 'boolean' || expr instanceof Date || expr === null || expr === undefined) {\n    return expr\n  }\n  return executeEvalExpr(expr, data)\n}\n\nexport function executeUpdate(data: any, update: any) {\n  for (const key in update) {\n    let root = data\n    const path = key.split('.')\n    const last = path.pop()\n    for (const key of path) {\n      root = root[key] ||= {}\n    }\n    root[last] = executeEval(data, update[key])\n  }\n  return data\n}\n", "import { clone, Dict, isNullable, makeArray, MaybeArray } from '@koishijs/utils'\nimport { isEvalExpr } from './eval'\nimport { ModelError } from './error'\nimport { Flatten, Keys } from './utils'\n\nexport class Model<T = any> {\n  public config: Dict<Model.Config> = {}\n\n  extend<K extends Keys<T>>(name: K, fields?: Model.Field.Extension<T[K]>, extension?: Model.Extension<T[K]>): void\n  extend(name: Keys<T>, fields = {}, extension: Model.Extension = {}) {\n    const { primary, autoInc, unique = [], foreign } = extension\n    const table = this.config[name] ||= {\n      primary: 'id',\n      unique: [],\n      foreign: {},\n      fields: {},\n      internal: { '': {} },\n    }\n\n    table.primary = primary || table.primary\n    table.autoInc = autoInc || table.autoInc\n    table.unique.push(...unique)\n    Object.assign(table.foreign, foreign)\n\n    for (const key in fields) {\n      if (typeof fields[key] === 'function') {\n        const index = key.lastIndexOf('.')\n        const prefix = key.slice(0, index + 1)\n        const method = key.slice(index + 1)\n        ;(table.internal[prefix] ??= {})[method] = fields[key]\n      } else {\n        table.fields[key] = Model.Field.parse(fields[key])\n      }\n    }\n\n    // check index\n    this.checkIndex(table, table.primary)\n    table.unique.forEach(index => this.checkIndex(table, index))\n  }\n\n  private checkIndex(table: Model.Config, index: MaybeArray<string>) {\n    for (const key of makeArray(index)) {\n      if (!table.fields[key]) {\n        throw new ModelError(`missing field definition for index key \"${key}\"`)\n      }\n    }\n  }\n\n  create<K extends Keys<T>>(name: K, data?: {}) {\n    const { fields, primary } = this.config[name]\n    const result = {}\n    const keys = makeArray(primary)\n    for (const key in fields) {\n      if (!keys.includes(key) && !isNullable(fields[key].initial)) {\n        result[key] = clone(fields[key].initial)\n      }\n    }\n    return this.parse(name, { ...result, ...data }) as T[K]\n  }\n\n  resolveValue(name: string, key: string, value: any) {\n    if (isNullable(value)) return value\n    const { fields } = this.config[name]\n    if (fields[key]?.type === 'time') {\n      const date = new Date(0)\n      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds())\n      return date\n    }\n    return value\n  }\n\n  parse<K extends Keys<T>>(name: K, source: object) {\n    const { internal } = this.config[name]\n    const result: any = Object.create(internal[''])\n    for (const key in source) {\n      let node = result\n      const segments = key.split('.').reverse()\n      let prefix = ''\n      for (let index = segments.length - 1; index > 0; index--) {\n        const segment = segments[index]\n        prefix += segment + '.'\n        node = node[segment] ??= Object.create(internal[prefix] ?? {})\n      }\n      if (key in source) {\n        const value = this.resolveValue(name, key, source[key])\n        node[segments[0]] = value\n      }\n    }\n    return result\n  }\n\n  format<K extends Keys<T>>(name: K, source: object, prefix = '', result = {} as T[K]) {\n    const fields = Object.keys(this.config[name].fields)\n    Object.entries(source).map(([key, value]) => {\n      key = prefix + key\n      if (fields.includes(key)) {\n        result[key] = this.resolveValue(name, key, value)\n      } else if (!value || typeof value !== 'object' || isEvalExpr(value)) {\n        // drop unknown fields\n        const field = fields.find(field => key.startsWith(field + '.'))\n        if (field) result[key] = value\n      } else {\n        this.format(name, value, key + '.', result)\n      }\n    })\n    return result\n  }\n}\n\nexport namespace Model {\n  export interface Extension<O = any> {\n    autoInc?: boolean\n    primary?: MaybeArray<Keys<O>>\n    unique?: MaybeArray<Keys<O>>[]\n    foreign?: {\n      [K in keyof O]?: [string, string]\n    }\n  }\n\n  export interface Config<O = any> extends Extension<O> {\n    fields?: Field.Config<O>\n    internal?: Field.Internal<O>\n  }\n\n  export interface Field<T = any> {\n    type: Field.Type<T>\n    length?: number\n    nullable?: boolean\n    initial?: T\n    precision?: number\n    scale?: number\n  }\n\n  export namespace Field {\n    export const number: Type[] = ['integer', 'unsigned', 'float', 'double', 'decimal']\n    export const string: Type[] = ['char', 'string', 'text']\n    export const date: Type[] = ['timestamp', 'date', 'time']\n    export const object: Type[] = ['list', 'json']\n\n    export type Type<T = any> =\n      | T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal'\n      : T extends string ? 'char' | 'string' | 'text'\n      : T extends Date ? 'timestamp' | 'date' | 'time'\n      : T extends unknown[] ? 'list' | 'json'\n      : T extends object ? 'json'\n      : never\n\n    type Shorthand<S extends string> = S | `${S}(${any})`\n\n    type MapField<O = any> = {\n      [K in keyof O]?: O[K] extends (...args: any) => any\n        ? O[K]\n        : Field<O[K]> | Shorthand<Type<O[K]>>\n    }\n\n    export type Extension<O = any> = MapField<Flatten<O>>\n\n    export type Config<O = any> = {\n      [K in keyof O]?: O[K] extends (...args: any) => any ? never : Field<O[K]>\n    }\n\n    export type Internal<O = any> = {\n      [K in keyof O]?: O[K] extends (...args: any) => any ? O[K] : never\n    }\n\n    const regexp = /^(\\w+)(?:\\((.+)\\))?$/\n\n    export function parse(source: string | Field): Field {\n      if (typeof source !== 'string') return { initial: null, ...source }\n\n      // parse string definition\n      const capture = regexp.exec(source)\n      if (!capture) throw new ModelError('invalid field definition')\n      const type = capture[1] as Type\n      const args = (capture[2] || '').split(',')\n      const field: Field = { type }\n\n      // set default initial value\n      if (field.initial === undefined) {\n        if (number.includes(field.type)) field.initial = 0\n        if (string.includes(field.type)) field.initial = ''\n        if (field.type === 'list') field.initial = []\n        if (field.type === 'json') field.initial = {}\n      }\n\n      // set length information\n      if (type === 'decimal') {\n        field.precision = +args[0]\n        field.scale = +args[1]\n      } else if (args[0]) {\n        field.length = +args[0]\n      }\n\n      return field\n    }\n  }\n}\n", "import { Dict, Extract } from '@koishijs/utils'\nimport { Eval, executeEval } from './eval'\nimport { Comparable, Indexable } from './utils'\n\nexport type Query<T = any> = Query.Expr<T> | Query.Shorthand<Indexable>\n\nexport namespace Query {\n  export interface FieldExpr<T = any> {\n    // logical\n    $or?: FieldQuery<T>[]\n    $and?: FieldQuery<T>[]\n    $not?: FieldQuery<T>\n\n    // membership\n    $in?: Extract<T, Indexable, T[]>\n    $nin?: Extract<T, Indexable, T[]>\n\n    // arithmatic\n    $eq?: Extract<T, Comparable>\n    $ne?: Extract<T, Comparable>\n    $gt?: Extract<T, Comparable>\n    $gte?: Extract<T, Comparable>\n    $lt?: Extract<T, Comparable>\n    $lte?: Extract<T, Comparable>\n\n    // list\n    $el?: T extends (infer U)[] ? FieldQuery<U> : never\n    $size?: Extract<T, any[], number>\n\n    // regexp\n    $regex?: Extract<T, string, RegExp>\n    $regexFor?: Extract<T, string>\n\n    // bitwise\n    $bitsAllClear?: Extract<T, number>\n    $bitsAllSet?: Extract<T, number>\n    $bitsAnyClear?: Extract<T, number>\n    $bitsAnySet?: Extract<T, number>\n  }\n\n  export interface LogicalExpr<T = any> {\n    $or?: Expr<T>[]\n    $and?: Expr<T>[]\n    $not?: Expr<T>\n    $expr?: Eval.Boolean<T>\n  }\n\n  export type Shorthand<T = any> =\n    | Extract<T, Comparable>\n    | Extract<T, Indexable, T[]>\n    | Extract<T, string, RegExp>\n\n  export type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>\n\n  export type Expr<T = any> = LogicalExpr<T> & {\n    [K in keyof T]?: FieldQuery<T[K]>\n  }\n}\n\ntype QueryOperators = {\n  [K in keyof Query.FieldExpr]?: (query: Query.FieldExpr[K], data: any) => boolean\n}\n\nconst queryOperators: QueryOperators = {\n  // logical\n  $or: (query, data) => query.reduce((prev, query) => prev || executeFieldQuery(query, data), false),\n  $and: (query, data) => query.reduce((prev, query) => prev && executeFieldQuery(query, data), true),\n  $not: (query, data) => !executeFieldQuery(query, data),\n\n  // comparison\n  $eq: (query, data) => data.valueOf() === query.valueOf(),\n  $ne: (query, data) => data.valueOf() !== query.valueOf(),\n  $gt: (query, data) => data.valueOf() > query.valueOf(),\n  $gte: (query, data) => data.valueOf() >= query.valueOf(),\n  $lt: (query, data) => data.valueOf() < query.valueOf(),\n  $lte: (query, data) => data.valueOf() <= query.valueOf(),\n\n  // membership\n  $in: (query, data) => query.includes(data),\n  $nin: (query, data) => !query.includes(data),\n\n  // regexp\n  $regex: (query, data) => query.test(data),\n  $regexFor: (query, data) => new RegExp(data, 'i').test(query),\n\n  // bitwise\n  $bitsAllSet: (query, data) => (query & data) === query,\n  $bitsAllClear: (query, data) => (query & data) === 0,\n  $bitsAnySet: (query, data) => (query & data) !== 0,\n  $bitsAnyClear: (query, data) => (query & data) !== query,\n\n  // list\n  $el: (query, data) => data.some(item => executeFieldQuery(query, item)),\n  $size: (query, data) => data.length === query,\n}\n\nfunction executeFieldQuery(query: Query.FieldQuery, data: any) {\n  // shorthand syntax\n  if (Array.isArray(query)) {\n    return query.includes(data)\n  } else if (query instanceof RegExp) {\n    return query.test(data)\n  } else if (typeof query === 'string' || typeof query === 'number' || query instanceof Date) {\n    return data.valueOf() === query.valueOf()\n  }\n\n  for (const key in query) {\n    if (key in queryOperators) {\n      if (!queryOperators[key](query[key], data)) return false\n    }\n  }\n\n  return true\n}\n\nexport function executeQuery(data: any, query: Query.Expr): boolean {\n  const entries: [string, any][] = Object.entries(query)\n  return entries.every(([key, value]) => {\n    // execute logical query\n    if (key === '$and') {\n      return (value as Query.Expr[]).reduce((prev, query) => prev && executeQuery(data, query), true)\n    } else if (key === '$or') {\n      return (value as Query.Expr[]).reduce((prev, query) => prev || executeQuery(data, query), false)\n    } else if (key === '$not') {\n      return !executeQuery(data, value)\n    } else if (key === '$expr') {\n      return executeEval(data, value)\n    }\n\n    // execute field query\n    try {\n      if (!(key in data)) return false\n      return executeFieldQuery(value, data[key])\n    } catch {\n      return false\n    }\n  })\n}\n\nexport type Modifier<T extends string = string> = T[] | Modifier.Expr<T>\n\nexport namespace Modifier {\n  export interface Expr<K extends string = string> {\n    limit?: number\n    offset?: number\n    fields?: K[]\n    /** @experimental */\n    sort?: Dict<'asc' | 'desc'>\n  }\n}\n\nexport function executeSort(data: any[], sort: Dict<'asc' | 'desc'>) {\n  return data.sort((a, b) => {\n    for (const key in sort) {\n      const dir = sort[key] === 'asc' ? 1 : -1\n      const x = a[key], y = b[key]\n      if (x < y) return -dir\n      if (x > y) return dir\n    }\n    return 0\n  })\n}\n"],
  "mappings": "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",
  "names": []
}
