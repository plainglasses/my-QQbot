{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["type Dict<T = any> = { [key: string]: T }\ntype Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>\n\ntype Global = NodeJS.Global & Window & typeof globalThis\n\ntype GlobalClass = {\n  [K in keyof Global]: Global[K] extends new (...args: any[]) => infer T ? T : never\n}\n\nconst root: any = typeof self !== 'undefined' ? self : global\n\nfunction isType<K extends keyof GlobalClass>(type: K, value: any): value is GlobalClass[K] {\n  return type in root && value instanceof root[type]\n    || Object.prototype.toString.call(value).slice(8, -1) === type\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ninterface segment {\n  type: string\n  data: segment.Data\n}\n\nfunction segment(type: string, data: segment.Data = {}) {\n  if (type === 'text') return segment.escape(String(data.content))\n  let output = '[CQ:' + type\n  for (const key in data) {\n    if (data[key]) output += `,${key}=${segment.escape(data[key], true)}`\n  }\n  return output + ']'\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype primitive = string | number | boolean\n\nnamespace segment {\n  export type Chain = segment.Parsed[]\n  export type Data = Dict<primitive>\n  export type Transformer = string | ((data: Dict<string>, index: number, chain: Chain) => string)\n  export type AsyncTransformer = string | ((data: Dict<string>, index: number, chain: Chain) => Awaitable<string>)\n\n  export interface Parsed extends segment {\n    data: Dict<string>\n    capture?: RegExpExecArray\n  }\n\n  export function escape(source: any, inline = false) {\n    const result = String(source)\n      .replace(/&/g, '&amp;')\n      .replace(/\\[/g, '&#91;')\n      .replace(/\\]/g, '&#93;')\n    return inline\n      ? result.replace(/,/g, '&#44;').replace(/(\\ud83c[\\udf00-\\udfff])|(\\ud83d[\\udc00-\\ude4f\\ude80-\\udeff])|[\\u2600-\\u2B55]/g, ' ')\n      : result\n  }\n\n  export function unescape(source: string) {\n    return String(source)\n      .replace(/&#91;/g, '[')\n      .replace(/&#93;/g, ']')\n      .replace(/&#44;/g, ',')\n      .replace(/&amp;/g, '&')\n  }\n\n  export function join(chain: segment[]) {\n    return chain.map(node => segment(node.type, node.data)).join('')\n  }\n\n  export interface FindOptions {\n    type?: string\n    caret?: boolean\n  }\n\n  export function from(source: string, options: FindOptions = {}): segment.Parsed {\n    let regExpSource = `\\\\[CQ:(${options.type || '\\\\w+'})((,\\\\w+=[^,\\\\]]*)*)\\\\]`\n    if (options.caret) regExpSource = '^' + regExpSource\n    const capture = new RegExp(regExpSource).exec(source)\n    if (!capture) return null\n    const [, type, attrs] = capture\n    const data: Dict<string> = {}\n    attrs && attrs.slice(1).split(',').forEach((str) => {\n      const index = str.indexOf('=')\n      data[str.slice(0, index)] = unescape(str.slice(index + 1))\n    })\n    return { type, data, capture }\n  }\n\n  export function parse(source: string) {\n    const chain: Chain = []\n    let result: segment.Parsed\n    while ((result = from(source))) {\n      const { capture } = result\n      if (capture.index) {\n        chain.push({ type: 'text', data: { content: unescape(source.slice(0, capture.index)) } })\n      }\n      chain.push(result)\n      source = source.slice(capture.index + capture[0].length)\n    }\n    if (source) chain.push({ type: 'text', data: { content: unescape(source) } })\n    return chain\n  }\n\n  export function transform(source: string | Chain, rules: Dict<Transformer>, dropOthers = false) {\n    const chain = typeof source === 'string' ? parse(source) : source\n    return chain.map(({ type, data, capture }, index, chain) => {\n      const transformer = rules[type]\n      if (typeof transformer === 'string') return transformer\n      if (typeof transformer === 'function') return transformer(data, index, chain)\n      if (dropOthers) return ''\n      if (capture && type !== 'text') return capture[0]\n      return segment(type, data)\n    }).join('')\n  }\n\n  export async function transformAsync(source: string | Chain, rules: Dict<AsyncTransformer>) {\n    const chain = typeof source === 'string' ? parse(source) : source\n    const cache = new Map<Parsed, string>()\n    await Promise.all(chain.map(async (node, index, chain) => {\n      const transformer = rules[node.type]\n      if (!transformer) return\n      cache.set(node, typeof transformer === 'string' ? transformer : await transformer(node.data, index, chain))\n    }))\n    return chain.map(node => cache.get(node) || segment(node.type, node.data)).join('')\n  }\n\n  export type Factory<T> = (value: T, data?: segment.Data) => string\n\n  function createFactory(type: string, key: string): Factory<primitive> {\n    return (value, data = {}) => segment(type, { ...data, [key]: value })\n  }\n\n  function createAssetFactory(type: string): Factory<string | Buffer | ArrayBuffer> {\n    return (value, data = {}) => {\n      if (isType('Buffer', value)) {\n        value = 'base64://' + value.toString('base64')\n      } else if (isType('ArrayBuffer', value)) {\n        value = 'base64://' + Buffer.from(value).toString('base64')\n      }\n      return segment(type, { ...data, url: value })\n    }\n  }\n\n  export const at = createFactory('at', 'id')\n  export const sharp = createFactory('sharp', 'id')\n  export const quote = createFactory('quote', 'id')\n  export const image = createAssetFactory('image')\n  export const video = createAssetFactory('video')\n  export const audio = createAssetFactory('audio')\n  export const file = createAssetFactory('file')\n}\n\nexport default segment\n"],
  "mappings": "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",
  "names": []
}
