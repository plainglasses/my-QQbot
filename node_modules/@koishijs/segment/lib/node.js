var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// packages/segment/src/index.ts
__export(exports, {
  default: () => src_default
});
var root = typeof self !== "undefined" ? self : global;
function isType(type, value) {
  return type in root && value instanceof root[type] || Object.prototype.toString.call(value).slice(8, -1) === type;
}
__name(isType, "isType");
function segment(type, data = {}) {
  if (type === "text")
    return segment.escape(String(data.content));
  let output = "[CQ:" + type;
  for (const key in data) {
    if (data[key])
      output += `,${key}=${segment.escape(data[key], true)}`;
  }
  return output + "]";
}
__name(segment, "segment");
(function(segment2) {
  function escape(source, inline = false) {
    const result = String(source).replace(/&/g, "&amp;").replace(/\[/g, "&#91;").replace(/\]/g, "&#93;");
    return inline ? result.replace(/,/g, "&#44;").replace(/(\ud83c[\udf00-\udfff])|(\ud83d[\udc00-\ude4f\ude80-\udeff])|[\u2600-\u2B55]/g, " ") : result;
  }
  segment2.escape = escape;
  __name(escape, "escape");
  function unescape(source) {
    return String(source).replace(/&#91;/g, "[").replace(/&#93;/g, "]").replace(/&#44;/g, ",").replace(/&amp;/g, "&");
  }
  segment2.unescape = unescape;
  __name(unescape, "unescape");
  function join(chain) {
    return chain.map((node) => segment2(node.type, node.data)).join("");
  }
  segment2.join = join;
  __name(join, "join");
  function from(source, options = {}) {
    let regExpSource = `\\[CQ:(${options.type || "\\w+"})((,\\w+=[^,\\]]*)*)\\]`;
    if (options.caret)
      regExpSource = "^" + regExpSource;
    const capture = new RegExp(regExpSource).exec(source);
    if (!capture)
      return null;
    const [, type, attrs] = capture;
    const data = {};
    attrs && attrs.slice(1).split(",").forEach((str) => {
      const index = str.indexOf("=");
      data[str.slice(0, index)] = unescape(str.slice(index + 1));
    });
    return { type, data, capture };
  }
  segment2.from = from;
  __name(from, "from");
  function parse(source) {
    const chain = [];
    let result;
    while (result = from(source)) {
      const { capture } = result;
      if (capture.index) {
        chain.push({ type: "text", data: { content: unescape(source.slice(0, capture.index)) } });
      }
      chain.push(result);
      source = source.slice(capture.index + capture[0].length);
    }
    if (source)
      chain.push({ type: "text", data: { content: unescape(source) } });
    return chain;
  }
  segment2.parse = parse;
  __name(parse, "parse");
  function transform(source, rules, dropOthers = false) {
    const chain = typeof source === "string" ? parse(source) : source;
    return chain.map(({ type, data, capture }, index, chain2) => {
      const transformer = rules[type];
      if (typeof transformer === "string")
        return transformer;
      if (typeof transformer === "function")
        return transformer(data, index, chain2);
      if (dropOthers)
        return "";
      if (capture && type !== "text")
        return capture[0];
      return segment2(type, data);
    }).join("");
  }
  segment2.transform = transform;
  __name(transform, "transform");
  async function transformAsync(source, rules) {
    const chain = typeof source === "string" ? parse(source) : source;
    const cache = new Map();
    await Promise.all(chain.map(async (node, index, chain2) => {
      const transformer = rules[node.type];
      if (!transformer)
        return;
      cache.set(node, typeof transformer === "string" ? transformer : await transformer(node.data, index, chain2));
    }));
    return chain.map((node) => cache.get(node) || segment2(node.type, node.data)).join("");
  }
  segment2.transformAsync = transformAsync;
  __name(transformAsync, "transformAsync");
  function createFactory(type, key) {
    return (value, data = {}) => segment2(type, __spreadProps(__spreadValues({}, data), { [key]: value }));
  }
  __name(createFactory, "createFactory");
  function createAssetFactory(type) {
    return (value, data = {}) => {
      if (isType("Buffer", value)) {
        value = "base64://" + value.toString("base64");
      } else if (isType("ArrayBuffer", value)) {
        value = "base64://" + Buffer.from(value).toString("base64");
      }
      return segment2(type, __spreadProps(__spreadValues({}, data), { url: value }));
    };
  }
  __name(createAssetFactory, "createAssetFactory");
  segment2.at = createFactory("at", "id");
  segment2.sharp = createFactory("sharp", "id");
  segment2.quote = createFactory("quote", "id");
  segment2.image = createAssetFactory("image");
  segment2.video = createAssetFactory("video");
  segment2.audio = createAssetFactory("audio");
  segment2.file = createAssetFactory("file");
})(segment || (segment = {}));
var src_default = segment;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=node.js.map
