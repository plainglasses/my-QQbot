/// <reference types="node" />
declare type Dict<T = any> = {
    [key: string]: T;
};
declare type Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>;
interface segment {
    type: string;
    data: segment.Data;
}
declare function segment(type: string, data?: segment.Data): string;
declare type primitive = string | number | boolean;
declare namespace segment {
    type Chain = segment.Parsed[];
    type Data = Dict<primitive>;
    type Transformer = string | ((data: Dict<string>, index: number, chain: Chain) => string);
    type AsyncTransformer = string | ((data: Dict<string>, index: number, chain: Chain) => Awaitable<string>);
    interface Parsed extends segment {
        data: Dict<string>;
        capture?: RegExpExecArray;
    }
    function escape(source: any, inline?: boolean): string;
    function unescape(source: string): string;
    function join(chain: segment[]): string;
    interface FindOptions {
        type?: string;
        caret?: boolean;
    }
    function from(source: string, options?: FindOptions): segment.Parsed;
    function parse(source: string): Chain;
    function transform(source: string | Chain, rules: Dict<Transformer>, dropOthers?: boolean): string;
    function transformAsync(source: string | Chain, rules: Dict<AsyncTransformer>): Promise<string>;
    type Factory<T> = (value: T, data?: segment.Data) => string;
    const at: Factory<primitive>;
    const sharp: Factory<primitive>;
    const quote: Factory<primitive>;
    const image: Factory<string | ArrayBuffer | Buffer>;
    const video: Factory<string | ArrayBuffer | Buffer>;
    const audio: Factory<string | ArrayBuffer | Buffer>;
    const file: Factory<string | ArrayBuffer | Buffer>;
}
export default segment;
