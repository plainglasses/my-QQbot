{
  "version": 3,
  "sources": ["../src/index.ts", "../src/quester.ts", "../src/router.ts", "../src/adapter.ts", "../src/assets.ts", "../src/cache.ts"],
  "sourcesContent": ["import { App, Context, Modules, Schema } from '@koishijs/core'\nimport { trimSlash } from '@koishijs/utils'\nimport { Cache } from './cache'\nimport { Assets } from './assets'\nimport { Quester } from './quester'\nimport { Router } from './router'\n\nexport * from './adapter'\nexport * from './assets'\nexport * from './cache'\nexport * from './quester'\nexport * from './router'\n\nexport * from '@koishijs/core'\nexport * from '@koishijs/utils'\n\ndeclare module '@koishijs/core' {\n  interface App {\n    baseDir: string\n  }\n\n  namespace Context {\n    interface Services {\n      assets: Assets\n      cache: Cache\n      http: Quester\n      router: Router\n    }\n  }\n}\n\nApp.Config.list.unshift(App.Config.Network)\nApp.Config.list.push(Schema.object({\n  request: Quester.Config,\n  assets: App.Config.Assets,\n}))\n\n// use node require\nModules.internal.require = require\nModules.internal.resolve = require.resolve\n\nContext.service('assets')\nContext.service('cache')\nContext.service('http')\nContext.service('router')\n\nconst prepare = App.prototype.prepare\nApp.prototype.prepare = function (this: App, ...args) {\n  this.baseDir ??= process.cwd()\n  this.http = Quester.create(this.options.request)\n  prepare.call(this, ...args)\n  Router.prepare(this)\n}\n\nconst start = App.prototype.start\nApp.prototype.start = async function (this: App, ...args) {\n  const { host, port, selfUrl } = this.options\n  if (selfUrl) this.options.selfUrl = trimSlash(selfUrl)\n  if (port) {\n    await new Promise<void>(resolve => this._httpServer.listen(port, host, resolve))\n    this.logger('app').info('server listening at %c', `http://${host}:${port}`)\n    this.on('dispose', () => {\n      this.logger('app').info('http server closing')\n      this._wsServer?.close()\n      this._httpServer?.close()\n    })\n  }\n  return start.call(this, ...args)\n}\n", "import { Schema } from '@koishijs/core'\nimport { Dict } from '@koishijs/utils'\nimport { Agent } from 'http'\nimport ProxyAgent from 'proxy-agent'\nimport axios, { AxiosRequestConfig, AxiosResponse, Method } from 'axios'\n\ndeclare module '@koishijs/core' {\n  namespace App {\n    interface Config {\n      request?: Quester.Config\n    }\n  }\n\n  interface Adapter {\n    http?: Quester\n  }\n}\n\nexport interface Quester {\n  <T = any>(method: Method, url: string, config?: AxiosRequestConfig): Promise<T>\n  axios<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>\n  extend(config: Quester.Config): Quester\n  config: Quester.Config\n  head(url: string, config?: AxiosRequestConfig): Promise<Dict<string>>\n  get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>\n  delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>\n  post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>\n  put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>\n  patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>\n}\n\nexport namespace Quester {\n  export interface Config {\n    headers?: Dict\n    endpoint?: string\n    timeout?: number\n    proxyAgent?: string\n  }\n\n  export const Config = createSchema()\n\n  export function createSchema(config: Config = {}): Schema<Config> {\n    return Schema.object({\n      endpoint: Schema.string().role('url').description('API 请求的终结点。').default(config.endpoint),\n      proxyAgent: Schema.string().role('url').description('使用的代理服务器地址。').default(config.proxyAgent),\n      headers: Schema.dict(String).description('要附加的额外请求头。').default(config.headers || {}),\n      timeout: Schema.natural().role('ms').description('等待连接建立的最长时间。').default(config.timeout),\n    }).description('请求设置')\n  }\n\n  const agents: Dict<Agent> = {}\n\n  function getAgent(url: string) {\n    return agents[url] ||= new ProxyAgent(url)\n  }\n\n  export function create(config: Quester.Config = {}) {\n    const { endpoint = '' } = config\n\n    const options: AxiosRequestConfig = {\n      timeout: config.timeout,\n      headers: config.headers,\n    }\n\n    if (config.proxyAgent) {\n      options.httpAgent = getAgent(config.proxyAgent)\n      options.httpsAgent = getAgent(config.proxyAgent)\n    }\n\n    const request = async (url: string, config: AxiosRequestConfig = {}) => axios({\n      ...options,\n      ...config,\n      url: endpoint + url,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    })\n\n    const http = (async (method, url, config) => {\n      const response = await request(url, { ...config, method })\n      return response.data\n    }) as Quester\n\n    http.config = config\n    http.axios = request as any\n    http.extend = (newConfig) => create({ ...config, ...newConfig })\n\n    http.get = (url, config) => http('GET', url, config)\n    http.delete = (url, config) => http('DELETE', url, config)\n    http.post = (url, data, config) => http('POST', url, { ...config, data })\n    http.put = (url, data, config) => http('PUT', url, { ...config, data })\n    http.patch = (url, data, config) => http('PATCH', url, { ...config, data })\n    http.head = async (url, config) => {\n      const response = await request(url, { ...config, method: 'HEAD' })\n      return response.headers\n    }\n\n    return http\n  }\n}\n", "import { App, Context, Schema } from '@koishijs/core'\nimport { defineProperty, MaybeArray, remove } from '@koishijs/utils'\nimport { createServer, IncomingMessage, Server } from 'http'\nimport { pathToRegexp } from 'path-to-regexp'\nimport parseUrl from 'parseurl'\nimport WebSocket from 'ws'\nimport KoaRouter from '@koa/router'\nimport Koa from 'koa'\n\ndeclare module 'koa' {\n  // koa-bodyparser\n  interface Request {\n    body?: any\n    rawBody?: string\n  }\n}\n\ndeclare module '@koishijs/core' {\n  interface App {\n    _httpServer?: Server\n    _wsServer?: WebSocket.Server\n  }\n\n  namespace App {\n    interface Config extends Config.Network {}\n\n    namespace Config {\n      interface Static {\n        Network: Schema<Network>\n      }\n\n      interface Network {\n        host?: string\n        port?: number\n        selfUrl?: string\n      }\n    }\n  }\n}\n\ndefineProperty(App.Config, 'Network', Schema.object({\n  host: Schema.string().default('localhost').description('要监听的 IP 地址。如果将此设置为 `0.0.0.0` 将监听所有地址，包括局域网和公网地址。'),\n  port: Schema.natural().max(65535).description('要监听的端口。'),\n  selfUrl: Schema.string().role('url').description('应用暴露在公网的地址。部分插件 (例如 github 和 telegram) 需要用到。'),\n}).description('网络设置'))\n\ntype WebSocketCallback = (socket: WebSocket, request: IncomingMessage) => void\n\nexport class WebSocketLayer {\n  clients = new Set<WebSocket>()\n  regexp: RegExp\n\n  constructor(private router: Router, path: MaybeArray<string | RegExp>, public callback?: WebSocketCallback) {\n    this.regexp = pathToRegexp(path)\n  }\n\n  accept(socket: WebSocket, request: IncomingMessage) {\n    if (!this.regexp.test(parseUrl(request).pathname)) return\n    this.clients.add(socket)\n    socket.on('close', () => {\n      this.clients.delete(socket)\n    })\n    this.callback?.(socket, request)\n    return true\n  }\n\n  close() {\n    remove(this.router.wsStack, this)\n    for (const socket of this.clients) {\n      socket.close()\n    }\n  }\n}\n\nexport class Router extends KoaRouter {\n  wsStack: WebSocketLayer[] = []\n\n  /**\n   * hack into router methods to make sure that koa middlewares are disposable\n   */\n  register(...args: Parameters<KoaRouter['register']>) {\n    const layer = super.register(...args)\n    const context: Context = this[Context.current]\n    context?.state.disposables.push(() => {\n      remove(this.stack, layer)\n    })\n    return layer\n  }\n\n  ws(path: MaybeArray<string | RegExp>, callback?: WebSocketCallback) {\n    const layer = new WebSocketLayer(this, path, callback)\n    this.wsStack.push(layer)\n    const context: Context = this[Context.current]\n    context?.state.disposables.push(() => {\n      remove(this.wsStack, layer)\n    })\n    return layer\n  }\n\n  static prepare(app: App) {\n    // create server\n    const koa = new Koa()\n    app.router = new Router()\n    koa.use(require('koa-bodyparser')())\n    koa.use(app.router.routes())\n    koa.use(app.router.allowedMethods())\n\n    app._httpServer = createServer(koa.callback())\n    app._wsServer = new WebSocket.Server({\n      server: app._httpServer,\n    })\n\n    app._wsServer.on('connection', (socket, request) => {\n      for (const manager of app.router.wsStack) {\n        if (manager.accept(socket, request)) return\n      }\n      socket.close()\n    })\n  }\n}\n", "import { Adapter, Bot, Context, Schema } from '@koishijs/core'\nimport { Awaitable, Logger, Time } from '@koishijs/utils'\nimport WebSocket from 'ws'\n\ndeclare module '@koishijs/core' {\n  interface Bot {\n    socket?: WebSocket\n  }\n}\n\nexport namespace InjectedAdapter {\n  const logger = new Logger('adapter')\n\n  export namespace WebSocketClient {\n    export interface Config {\n      retryLazy?: number\n      retryTimes?: number\n      retryInterval?: number\n    }\n  }\n\n  export abstract class WebSocketClient<S extends Bot.BaseConfig, T extends WebSocketClient.Config> extends Adapter<S, T> {\n    protected abstract prepare(bot: Bot<S>): Awaitable<WebSocket>\n    protected abstract accept(bot: Bot<S>): void\n\n    public config: T\n    public isListening = false\n\n    static Config: Schema<WebSocketClient.Config> = Schema.object({\n      retryTimes: Schema.natural().description('初次连接时的最大重试次数，仅用于 ws 协议。').default(6),\n      retryInterval: Schema.natural().role('ms').description('初次连接时的重试时间间隔，仅用于 ws 协议。').default(5 * Time.second),\n      retryLazy: Schema.natural().role('ms').description('连接关闭后的重试时间间隔，仅用于 ws 协议。').default(Time.minute),\n    }).description('连接设置')\n\n    constructor(ctx: Context, config: T) {\n      super(ctx, {\n        retryLazy: Time.minute,\n        retryInterval: 5 * Time.second,\n        retryTimes: 6,\n        ...config,\n      })\n    }\n\n    connect(bot: Bot<S>) {\n      let _retryCount = 0\n      const { retryTimes, retryInterval, retryLazy } = this.config\n\n      const reconnect = async (initial = false) => {\n        logger.debug('websocket client opening')\n        const socket = await this.prepare(bot)\n        const url = socket.url.replace(/\\?.+/, '')\n\n        socket.on('error', error => logger.debug(error))\n\n        socket.on('close', (code, reason) => {\n          bot.socket = null\n          logger.debug(`websocket closed with ${code}`)\n          if (!this.isListening || bot.config.disabled) return bot.status = 'offline'\n\n          // remove query args to protect privacy\n          const message = reason.toString() || `failed to connect to ${url}`\n          let timeout = retryInterval\n          if (_retryCount >= retryTimes) {\n            if (initial) {\n              return bot.reject(new Error(message))\n            } else {\n              timeout = retryLazy\n            }\n          }\n\n          _retryCount++\n          bot.status = 'reconnect'\n          logger.warn(`${message}, will retry in ${Time.formatTimeShort(timeout)}...`)\n          setTimeout(() => {\n            if (this.isListening && !bot.config.disabled) reconnect()\n          }, timeout)\n        })\n\n        socket.on('open', () => {\n          _retryCount = 0\n          bot.socket = socket\n          logger.info('connect to server: %c', url)\n          this.accept(bot)\n        })\n      }\n\n      reconnect(true)\n    }\n\n    disconnect(bot: Bot) {\n      bot.socket?.close()\n    }\n\n    start() {\n      this.isListening = true\n    }\n\n    stop() {\n      this.isListening = false\n      logger.debug('websocket client closing')\n      for (const bot of this.bots) {\n        bot.socket?.close()\n      }\n    }\n  }\n}\n\nObject.assign(Adapter, InjectedAdapter)\n", "import { App, Context, Schema, Service } from '@koishijs/core'\nimport { defineProperty, segment } from '@koishijs/utils'\nimport { createHash } from 'crypto'\nimport { basename } from 'path'\nimport FileType from 'file-type'\n\ndeclare module '@koishijs/core' {\n  namespace App {\n    interface Config {\n      assets?: Config.Assets\n    }\n\n    namespace Config {\n      interface Static {\n        Assets?: Schema<Assets>\n      }\n\n      interface Assets {\n        whitelist?: string[]\n      }\n    }\n  }\n}\n\ndefineProperty(App.Config, 'Assets', Schema.object({\n  whitelist: Schema.array(Schema.string().required().role('url')).description('不处理的白名单 URL 列表。'),\n}).description('资源设置'))\n\nconst PROTOCOL_BASE64 = 'base64://'\n\nexport abstract class Assets extends Service {\n  static types = ['image', 'audio', 'video']\n  protected types: readonly string[] = Assets.types\n\n  abstract upload(url: string, file: string): Promise<string>\n  abstract stats(): Promise<Assets.Stats>\n\n  constructor(ctx: Context) {\n    super(ctx, 'assets')\n  }\n\n  public async transform(content: string) {\n    return await segment.transformAsync(content, Object.fromEntries(this.types.map((type) => {\n      return [type, async (data) => {\n        if (this.ctx.app.options.assets.whitelist.some(prefix => data.url.startsWith(prefix))) {\n          return segment(type, data)\n        } else {\n          return segment(type, { url: await this.upload(data.url, data.file) })\n        }\n      }]\n    })))\n  }\n\n  protected async download(url: string) {\n    if (url.startsWith(PROTOCOL_BASE64)) {\n      return Buffer.from(url.slice(PROTOCOL_BASE64.length), 'base64')\n    }\n    const data = await this.ctx.http.get<ArrayBuffer>(url, { responseType: 'arraybuffer' })\n    return Buffer.from(data)\n  }\n\n  protected async analyze(url: string, name = ''): Promise<Assets.FileInfo> {\n    const buffer = await this.download(url)\n    const hash = createHash('sha1').update(buffer).digest('hex')\n    if (name) {\n      name = basename(name)\n      if (!name.startsWith('.')) {\n        name = `-${name}`\n      }\n    } else {\n      const fileType = await FileType.fromBuffer(buffer)\n      if (fileType) {\n        name = `.${fileType.ext}`\n      }\n    }\n    return { buffer, hash, name, filename: `${hash}${name}` }\n  }\n}\n\nexport namespace Assets {\n  export interface Stats {\n    assetCount?: number\n    assetSize?: number\n  }\n\n  export interface FileInfo {\n    buffer: Buffer\n    hash: string\n    name: string\n    filename: string\n  }\n}\n", "import { Dict } from '@koishijs/utils'\nimport { Context, Service } from '@koishijs/core'\n\nexport abstract class Cache extends Service {\n  private static kConfig = Symbol('cache.config')\n\n  constructor(ctx: Context) {\n    super(ctx, 'cache')\n  }\n\n  abstract clear<T extends keyof Cache.Tables>(table: T): Promise<void>\n  abstract get<T extends keyof Cache.Tables>(table: T, key: string): Promise<Cache.Tables[T]>\n  abstract set<T extends keyof Cache.Tables>(table: T, key: string, value: Cache.Tables[T], maxAge?: number): Promise<void>\n  abstract del<T extends keyof Cache.Tables>(table: T, key: string): Promise<void>\n\n  get #tables(): Dict<Cache.TableConfig> {\n    return this.ctx.app[Cache.kConfig] ||= {}\n  }\n\n  table<T extends keyof Cache.Tables>(table: T, config?: Cache.TableConfig) {\n    return config ? this.#tables[table] = config : this.#tables[table]\n  }\n}\n\nexport namespace Cache {\n  export interface TableConfig {\n    maxAge?: number\n    maxSize?: number\n  }\n\n  export interface Tables {\n    misc: any\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
