var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// packages/koishi/src/index.ts
__export(exports, {
  Assets: () => Assets,
  Cache: () => Cache,
  InjectedAdapter: () => InjectedAdapter,
  Quester: () => Quester,
  Router: () => Router,
  WebSocketLayer: () => WebSocketLayer
});
var import_core6 = __toModule(require("@koishijs/core"));
var import_utils4 = __toModule(require("@koishijs/utils"));

// packages/koishi/src/quester.ts
var import_core = __toModule(require("@koishijs/core"));
var import_proxy_agent = __toModule(require("proxy-agent"));
var import_axios = __toModule(require("axios"));
var Quester;
(function(Quester2) {
  Quester2.Config = createSchema();
  function createSchema(config = {}) {
    return import_core.Schema.object({
      endpoint: import_core.Schema.string().role("url").description("API 请求的终结点。").default(config.endpoint),
      proxyAgent: import_core.Schema.string().role("url").description("使用的代理服务器地址。").default(config.proxyAgent),
      headers: import_core.Schema.dict(String).description("要附加的额外请求头。").default(config.headers || {}),
      timeout: import_core.Schema.natural().role("ms").description("等待连接建立的最长时间。").default(config.timeout)
    }).description("请求设置");
  }
  Quester2.createSchema = createSchema;
  __name(createSchema, "createSchema");
  const agents = {};
  function getAgent(url) {
    return agents[url] || (agents[url] = new import_proxy_agent.default(url));
  }
  __name(getAgent, "getAgent");
  function create(config = {}) {
    const { endpoint = "" } = config;
    const options = {
      timeout: config.timeout,
      headers: config.headers
    };
    if (config.proxyAgent) {
      options.httpAgent = getAgent(config.proxyAgent);
      options.httpsAgent = getAgent(config.proxyAgent);
    }
    const request = /* @__PURE__ */ __name(async (url, config2 = {}) => (0, import_axios.default)(__spreadProps(__spreadValues(__spreadValues({}, options), config2), {
      url: endpoint + url,
      headers: __spreadValues(__spreadValues({}, options.headers), config2.headers)
    })), "request");
    const http = /* @__PURE__ */ __name(async (method, url, config2) => {
      const response = await request(url, __spreadProps(__spreadValues({}, config2), { method }));
      return response.data;
    }, "http");
    http.config = config;
    http.axios = request;
    http.extend = (newConfig) => create(__spreadValues(__spreadValues({}, config), newConfig));
    http.get = (url, config2) => http("GET", url, config2);
    http.delete = (url, config2) => http("DELETE", url, config2);
    http.post = (url, data, config2) => http("POST", url, __spreadProps(__spreadValues({}, config2), { data }));
    http.put = (url, data, config2) => http("PUT", url, __spreadProps(__spreadValues({}, config2), { data }));
    http.patch = (url, data, config2) => http("PATCH", url, __spreadProps(__spreadValues({}, config2), { data }));
    http.head = async (url, config2) => {
      const response = await request(url, __spreadProps(__spreadValues({}, config2), { method: "HEAD" }));
      return response.headers;
    };
    return http;
  }
  Quester2.create = create;
  __name(create, "create");
})(Quester || (Quester = {}));

// packages/koishi/src/router.ts
var import_core2 = __toModule(require("@koishijs/core"));
var import_utils = __toModule(require("@koishijs/utils"));
var import_http = __toModule(require("http"));
var import_path_to_regexp = __toModule(require("path-to-regexp"));
var import_parseurl = __toModule(require("parseurl"));
var import_ws = __toModule(require("ws"));
var import_router = __toModule(require("@koa/router"));
var import_koa = __toModule(require("koa"));
(0, import_utils.defineProperty)(import_core2.App.Config, "Network", import_core2.Schema.object({
  host: import_core2.Schema.string().default("localhost").description("要监听的 IP 地址。如果将此设置为 `0.0.0.0` 将监听所有地址，包括局域网和公网地址。"),
  port: import_core2.Schema.natural().max(65535).description("要监听的端口。"),
  selfUrl: import_core2.Schema.string().role("url").description("应用暴露在公网的地址。部分插件 (例如 github 和 telegram) 需要用到。")
}).description("网络设置"));
var WebSocketLayer = class {
  constructor(router, path, callback) {
    this.router = router;
    this.callback = callback;
    this.clients = new Set();
    this.regexp = (0, import_path_to_regexp.pathToRegexp)(path);
  }
  accept(socket, request) {
    var _a;
    if (!this.regexp.test((0, import_parseurl.default)(request).pathname))
      return;
    this.clients.add(socket);
    socket.on("close", () => {
      this.clients.delete(socket);
    });
    (_a = this.callback) == null ? void 0 : _a.call(this, socket, request);
    return true;
  }
  close() {
    (0, import_utils.remove)(this.router.wsStack, this);
    for (const socket of this.clients) {
      socket.close();
    }
  }
};
__name(WebSocketLayer, "WebSocketLayer");
var Router = class extends import_router.default {
  constructor() {
    super(...arguments);
    this.wsStack = [];
  }
  register(...args) {
    const layer = super.register(...args);
    const context = this[import_core2.Context.current];
    context == null ? void 0 : context.state.disposables.push(() => {
      (0, import_utils.remove)(this.stack, layer);
    });
    return layer;
  }
  ws(path, callback) {
    const layer = new WebSocketLayer(this, path, callback);
    this.wsStack.push(layer);
    const context = this[import_core2.Context.current];
    context == null ? void 0 : context.state.disposables.push(() => {
      (0, import_utils.remove)(this.wsStack, layer);
    });
    return layer;
  }
  static prepare(app) {
    const koa = new import_koa.default();
    app.router = new Router();
    koa.use(require("koa-bodyparser")());
    koa.use(app.router.routes());
    koa.use(app.router.allowedMethods());
    app._httpServer = (0, import_http.createServer)(koa.callback());
    app._wsServer = new import_ws.default.Server({
      server: app._httpServer
    });
    app._wsServer.on("connection", (socket, request) => {
      for (const manager of app.router.wsStack) {
        if (manager.accept(socket, request))
          return;
      }
      socket.close();
    });
  }
};
__name(Router, "Router");

// packages/koishi/src/adapter.ts
var import_core3 = __toModule(require("@koishijs/core"));
var import_utils2 = __toModule(require("@koishijs/utils"));
var InjectedAdapter;
(function(InjectedAdapter2) {
  const logger = new import_utils2.Logger("adapter");
  class WebSocketClient extends import_core3.Adapter {
    constructor(ctx, config) {
      super(ctx, __spreadValues({
        retryLazy: import_utils2.Time.minute,
        retryInterval: 5 * import_utils2.Time.second,
        retryTimes: 6
      }, config));
      this.isListening = false;
    }
    connect(bot) {
      let _retryCount = 0;
      const { retryTimes, retryInterval, retryLazy } = this.config;
      const reconnect = /* @__PURE__ */ __name(async (initial = false) => {
        logger.debug("websocket client opening");
        const socket = await this.prepare(bot);
        const url = socket.url.replace(/\?.+/, "");
        socket.on("error", (error) => logger.debug(error));
        socket.on("close", (code, reason) => {
          bot.socket = null;
          logger.debug(`websocket closed with ${code}`);
          if (!this.isListening || bot.config.disabled)
            return bot.status = "offline";
          const message = reason.toString() || `failed to connect to ${url}`;
          let timeout = retryInterval;
          if (_retryCount >= retryTimes) {
            if (initial) {
              return bot.reject(new Error(message));
            } else {
              timeout = retryLazy;
            }
          }
          _retryCount++;
          bot.status = "reconnect";
          logger.warn(`${message}, will retry in ${import_utils2.Time.formatTimeShort(timeout)}...`);
          setTimeout(() => {
            if (this.isListening && !bot.config.disabled)
              reconnect();
          }, timeout);
        });
        socket.on("open", () => {
          _retryCount = 0;
          bot.socket = socket;
          logger.info("connect to server: %c", url);
          this.accept(bot);
        });
      }, "reconnect");
      reconnect(true);
    }
    disconnect(bot) {
      var _a;
      (_a = bot.socket) == null ? void 0 : _a.close();
    }
    start() {
      this.isListening = true;
    }
    stop() {
      var _a;
      this.isListening = false;
      logger.debug("websocket client closing");
      for (const bot of this.bots) {
        (_a = bot.socket) == null ? void 0 : _a.close();
      }
    }
  }
  __name(WebSocketClient, "WebSocketClient");
  WebSocketClient.Config = import_core3.Schema.object({
    retryTimes: import_core3.Schema.natural().description("初次连接时的最大重试次数，仅用于 ws 协议。").default(6),
    retryInterval: import_core3.Schema.natural().role("ms").description("初次连接时的重试时间间隔，仅用于 ws 协议。").default(5 * import_utils2.Time.second),
    retryLazy: import_core3.Schema.natural().role("ms").description("连接关闭后的重试时间间隔，仅用于 ws 协议。").default(import_utils2.Time.minute)
  }).description("连接设置");
  InjectedAdapter2.WebSocketClient = WebSocketClient;
})(InjectedAdapter || (InjectedAdapter = {}));
Object.assign(import_core3.Adapter, InjectedAdapter);

// packages/koishi/src/assets.ts
var import_core4 = __toModule(require("@koishijs/core"));
var import_utils3 = __toModule(require("@koishijs/utils"));
var import_crypto = __toModule(require("crypto"));
var import_path = __toModule(require("path"));
var import_file_type = __toModule(require("file-type"));
(0, import_utils3.defineProperty)(import_core4.App.Config, "Assets", import_core4.Schema.object({
  whitelist: import_core4.Schema.array(import_core4.Schema.string().required().role("url")).description("不处理的白名单 URL 列表。")
}).description("资源设置"));
var PROTOCOL_BASE64 = "base64://";
var _Assets = class extends import_core4.Service {
  constructor(ctx) {
    super(ctx, "assets");
    this.types = _Assets.types;
  }
  async transform(content) {
    return await import_utils3.segment.transformAsync(content, Object.fromEntries(this.types.map((type) => {
      return [type, async (data) => {
        if (this.ctx.app.options.assets.whitelist.some((prefix) => data.url.startsWith(prefix))) {
          return (0, import_utils3.segment)(type, data);
        } else {
          return (0, import_utils3.segment)(type, { url: await this.upload(data.url, data.file) });
        }
      }];
    })));
  }
  async download(url) {
    if (url.startsWith(PROTOCOL_BASE64)) {
      return Buffer.from(url.slice(PROTOCOL_BASE64.length), "base64");
    }
    const data = await this.ctx.http.get(url, { responseType: "arraybuffer" });
    return Buffer.from(data);
  }
  async analyze(url, name = "") {
    const buffer = await this.download(url);
    const hash = (0, import_crypto.createHash)("sha1").update(buffer).digest("hex");
    if (name) {
      name = (0, import_path.basename)(name);
      if (!name.startsWith(".")) {
        name = `-${name}`;
      }
    } else {
      const fileType = await import_file_type.default.fromBuffer(buffer);
      if (fileType) {
        name = `.${fileType.ext}`;
      }
    }
    return { buffer, hash, name, filename: `${hash}${name}` };
  }
};
var Assets = _Assets;
__name(Assets, "Assets");
Assets.types = ["image", "audio", "video"];

// packages/koishi/src/cache.ts
var import_core5 = __toModule(require("@koishijs/core"));
var _tables, tables_get;
var _Cache = class extends import_core5.Service {
  constructor(ctx) {
    super(ctx, "cache");
    __privateAdd(this, _tables);
  }
  table(table, config) {
    return config ? __privateGet(this, _tables, tables_get)[table] = config : __privateGet(this, _tables, tables_get)[table];
  }
};
var Cache = _Cache;
__name(Cache, "Cache");
_tables = new WeakSet();
tables_get = /* @__PURE__ */ __name(function() {
  var _a, _b;
  return (_a = this.ctx.app)[_b = _Cache.kConfig] || (_a[_b] = {});
}, "#tables");
Cache.kConfig = Symbol("cache.config");

// packages/koishi/src/index.ts
__reExport(exports, __toModule(require("@koishijs/core")));
__reExport(exports, __toModule(require("@koishijs/utils")));
import_core6.App.Config.list.unshift(import_core6.App.Config.Network);
import_core6.App.Config.list.push(import_core6.Schema.object({
  request: Quester.Config,
  assets: import_core6.App.Config.Assets
}));
import_core6.Modules.internal.require = require;
import_core6.Modules.internal.resolve = require.resolve;
import_core6.Context.service("assets");
import_core6.Context.service("cache");
import_core6.Context.service("http");
import_core6.Context.service("router");
var prepare = import_core6.App.prototype.prepare;
import_core6.App.prototype.prepare = function(...args) {
  var _a;
  (_a = this.baseDir) != null ? _a : this.baseDir = process.cwd();
  this.http = Quester.create(this.options.request);
  prepare.call(this, ...args);
  Router.prepare(this);
};
var start = import_core6.App.prototype.start;
import_core6.App.prototype.start = async function(...args) {
  const { host, port, selfUrl } = this.options;
  if (selfUrl)
    this.options.selfUrl = (0, import_utils4.trimSlash)(selfUrl);
  if (port) {
    await new Promise((resolve) => this._httpServer.listen(port, host, resolve));
    this.logger("app").info("server listening at %c", `http://${host}:${port}`);
    this.on("dispose", () => {
      var _a, _b;
      this.logger("app").info("http server closing");
      (_a = this._wsServer) == null ? void 0 : _a.close();
      (_b = this._httpServer) == null ? void 0 : _b.close();
    });
  }
  return start.call(this, ...args);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Assets,
  Cache,
  InjectedAdapter,
  Quester,
  Router,
  WebSocketLayer
});
//# sourceMappingURL=index.js.map
