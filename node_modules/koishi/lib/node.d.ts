/// <reference types="koishi/lib" />
/// <reference types="ws" />
/// <reference types="node" />
/// <reference types="koa__router" />
import { Awaitable, Dict, MaybeArray } from '@koishijs/utils';
import WebSocket from 'ws';
import { AxiosRequestConfig, AxiosResponse, Method } from 'axios';
import { IncomingMessage, Server } from 'http';
import KoaRouter from '@koa/router';
declare module 'koishi' {
    interface Bot {
        socket?: WebSocket;
    }
    export namespace Adapter {
        namespace WebSocketClient {
            interface Config {
                retryLazy?: number;
                retryTimes?: number;
                retryInterval?: number;
            }
        }
        abstract class WebSocketClient<S extends Bot.BaseConfig, T extends WebSocketClient.Config> extends Adapter<S, T> {
            protected abstract prepare(bot: Bot<S>): Awaitable<WebSocket>;
            protected abstract accept(bot: Bot<S>): void;
            config: T;
            isListening: boolean;
            static Config: Schema<WebSocketClient.Config>;
            constructor(ctx: Context, config: T);
            connect(bot: Bot<S>): void;
            disconnect(bot: Bot): void;
            start(): void;
            stop(): void;
        }
    }
    namespace App {
        interface Config {
            assets?: Config.Assets;
        }
        namespace Config {
            interface Static {
                Assets?: Schema<Assets>;
            }
            interface Assets {
                whitelist?: string[];
            }
        }
    }
    export abstract class Assets extends Service {
        static types: string[];
        protected types: readonly string[];
        abstract upload(url: string, file: string): Promise<string>;
        abstract stats(): Promise<Assets.Stats>;
        constructor(ctx: Context);
        transform(content: string): Promise<string>;
        protected download(url: string): Promise<Buffer>;
        protected analyze(url: string, name?: string): Promise<Assets.FileInfo>;
    }
    export namespace Assets {
        interface Stats {
            assetCount?: number;
            assetSize?: number;
        }
        interface FileInfo {
            buffer: Buffer;
            hash: string;
            name: string;
            filename: string;
        }
    }
    export abstract class Cache extends Service {
        #private;
        private static kConfig;
        constructor(ctx: Context);
        abstract clear<T extends keyof Cache.Tables>(table: T): Promise<void>;
        abstract get<T extends keyof Cache.Tables>(table: T, key: string): Promise<Cache.Tables[T]>;
        abstract set<T extends keyof Cache.Tables>(table: T, key: string, value: Cache.Tables[T], maxAge?: number): Promise<void>;
        abstract del<T extends keyof Cache.Tables>(table: T, key: string): Promise<void>;
        table<T extends keyof Cache.Tables>(table: T, config?: Cache.TableConfig): Cache.TableConfig;
    }
    export namespace Cache {
        interface TableConfig {
            maxAge?: number;
            maxSize?: number;
        }
        interface Tables {
            misc: any;
        }
    }
    namespace App {
        interface Config {
            request?: Quester.Config;
        }
    }
    interface Adapter {
        http?: Quester;
    }
    export interface Quester {
        <T = any>(method: Method, url: string, config?: AxiosRequestConfig): Promise<T>;
        axios<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
        extend(config: Quester.Config): Quester;
        config: Quester.Config;
        head(url: string, config?: AxiosRequestConfig): Promise<Dict<string>>;
        get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
        delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
        post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
        put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
        patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    }
    export namespace Quester {
        interface Config {
            headers?: Dict;
            endpoint?: string;
            timeout?: number;
            proxyAgent?: string;
        }
        const Config: Schema<Config, Config>;
        function createSchema(config?: Config): Schema<Config>;
        function create(config?: Quester.Config): Quester;
    }
    interface App {
        _httpServer?: Server;
        _wsServer?: WebSocket.Server;
    }
    namespace App {
        interface Config extends Config.Network {
        }
        namespace Config {
            interface Static {
                Network: Schema<Network>;
            }
            interface Network {
                host?: string;
                port?: number;
                selfUrl?: string;
            }
        }
    }
    type WebSocketCallback = (socket: WebSocket, request: IncomingMessage) => void;
    export class WebSocketLayer {
        private router;
        callback?: WebSocketCallback;
        clients: Set<WebSocket>;
        regexp: RegExp;
        constructor(router: Router, path: MaybeArray<string | RegExp>, callback?: WebSocketCallback);
        accept(socket: WebSocket, request: IncomingMessage): boolean;
        close(): void;
    }
    export class Router extends KoaRouter {
        wsStack: WebSocketLayer[];
        /**
         * hack into router methods to make sure that koa middlewares are disposable
         */
        register(...args: Parameters<KoaRouter['register']>): KoaRouter.Layer;
        ws(path: MaybeArray<string | RegExp>, callback?: WebSocketCallback): WebSocketLayer;
        static prepare(app: App): void;
    }
    interface App {
        baseDir: string;
    }
    namespace Context {
        interface Services {
            assets: Assets;
            cache: Cache;
            http: Quester;
            router: Router;
        }
    }
}
declare module 'koa' {
    interface Request {
        body?: any;
        rawBody?: string;
    }
}
